#!/bin/bash

#######################################################################################
# DAP Application Manager - All-in-One Script
# 
# Manages the complete DAP (Database Application Platform) lifecycle:
# - Application start/stop/restart/status
# - Database cleanup and sample data setup  
# - Browser cache clearing guidance
# - Development environment management
#
# Usage: ./dap [command]
# Commands: start, stop, restart, status, reset, clean-restart, test, add-sample, reset-sample, help
#######################################################################################

set -e

# Configuration - Load from environment or use defaults
APP_NAME="DAP Application"
DB_CONTAINER="$(docker ps -a --format '{{.Names}}' | grep -E '^dap[-_]db[-_]1$|^dap_db_1$|^dap-db-1$|^db$' | head -n 1)"
BACKEND_PORT="${BACKEND_PORT:-4000}"
FRONTEND_PORT="${FRONTEND_PORT:-5173}"
# Use the directory of this script as the project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$SCRIPT_DIR"
BACKEND_DIR="$PROJECT_DIR/backend"
FRONTEND_DIR="$PROJECT_DIR/frontend"

# Dependency checks (Docker, Node.js, npm, lsof, pkill)
for dep in docker node npm lsof pkill; do
    if ! command -v $dep >/dev/null 2>&1; then
        echo "[ERROR] Required dependency '$dep' is not installed or not in PATH. Please install it before running this script."
        exit 1
    fi
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_header() { echo -e "${PURPLE}=== $1 ===${NC}"; }

# Check if a port is in use
check_port() {
    local port=$1
    lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1
}

# Kill processes on a specific port
kill_port() {
    local port=$1
    local service_name=$2
    
    if check_port $port; then
        log_info "Stopping $service_name on port $port..."
        local pids=$(lsof -Pi :$port -sTCP:LISTEN -t 2>/dev/null || true)
        if [ ! -z "$pids" ]; then
            echo "$pids" | xargs kill -TERM 2>/dev/null || true
            sleep 2
            local remaining_pids=$(lsof -Pi :$port -sTCP:LISTEN -t 2>/dev/null || true)
            if [ ! -z "$remaining_pids" ]; then
                echo "$remaining_pids" | xargs kill -KILL 2>/dev/null || true
            fi
            log_success "$service_name stopped"
        fi
    else
        log_info "$service_name not running on port $port"
    fi
}

# Kill Node.js processes related to the project
kill_node_processes() {
    log_info "Stopping all Node.js processes related to the project..."
    pkill -f "ts-node-dev.*src/server.ts" 2>/dev/null || true
    pkill -f "vite.*--port.*5173" 2>/dev/null || true
    pkill -f "npm.*exec.*ts-node-dev" 2>/dev/null || true
    pkill -f "npm.*exec.*vite" 2>/dev/null || true
    sleep 2
    kill_port $BACKEND_PORT "Backend API"
    kill_port $FRONTEND_PORT "Frontend Dev Server"
    log_success "Node.js processes stopped"
}

# Manage Docker containers
manage_docker() {
    local action=$1
    
    case $action in
        start)
            log_info "Starting PostgreSQL database container..."
            if docker ps -a --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                if docker ps --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                    log_info "Database container already running"
                else
                    docker start $DB_CONTAINER
                    log_success "Database container started"
                fi
            else
                log_warning "Database container $DB_CONTAINER not found. Attempting to create it with 'docker compose up -d db'..."
                (cd "$PROJECT_DIR" && docker compose up -d db)
                # Wait for container to appear
                local max_attempts=10
                local attempt=1
                while [ $attempt -le $max_attempts ]; do
                    if docker ps -a --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                        log_success "Database container $DB_CONTAINER created"
                        break
                    fi
                    sleep 1
                    ((attempt++))
                done
                if ! docker ps -a --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                    log_error "Failed to create database container $DB_CONTAINER. Please check your docker-compose.yml."
                    return 1
                fi
            fi
            
            log_info "Waiting for database to be ready..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
                if docker exec $DB_CONTAINER pg_isready -U postgres >/dev/null 2>&1; then
                    log_success "Database is ready"
                    break
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                    log_error "Database failed to become ready within 30 seconds"
                    return 1
                fi
                
                echo -n "."
                sleep 1
                ((attempt++))
            done
            ;;
            
        stop)
            log_info "Stopping PostgreSQL database container..."
            if docker ps --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                docker stop $DB_CONTAINER
                log_success "Database container stopped"
            else
                log_info "Database container not running"
            fi
            ;;
            
        status)
            if docker ps --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                log_success "Database container is running"
                docker exec $DB_CONTAINER pg_isready -U postgres >/dev/null 2>&1 && log_success "Database is accepting connections"
            elif docker ps -a --format "table {{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
                log_warning "Database container exists but is not running"
            else
                log_error "Database container not found"
            fi
            ;;
    esac
}

# Start backend
start_backend() {
    log_info "Starting Backend GraphQL API..."
    
    if check_port $BACKEND_PORT; then
        log_warning "Backend already running on port $BACKEND_PORT"
        return 0
    fi
    
    cd "$BACKEND_DIR"
    
    if [ ! -d "node_modules" ]; then
        log_info "Installing backend dependencies..."
        npm install
    fi
    
    log_info "Starting backend server on port $BACKEND_PORT..."
    nohup npm run dev > ../backend.log 2>&1 &
    local backend_pid=$!
    
    local max_attempts=20
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if check_port $BACKEND_PORT; then
            log_success "Backend API started successfully (PID: $backend_pid)"
            return 0
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            log_error "Backend failed to start within 20 seconds"
            return 1
        fi
        
        echo -n "."
        sleep 1
        ((attempt++))
    done
}

# Start frontend
start_frontend() {
    log_info "Starting Frontend React App..."
    
    if check_port $FRONTEND_PORT; then
        log_warning "Frontend already running on port $FRONTEND_PORT"
        return 0
    fi
    
    cd "$FRONTEND_DIR"
    
    if [ ! -d "node_modules" ]; then
        log_info "Installing frontend dependencies..."
        npm install
    fi
    
    log_info "Starting frontend dev server on port $FRONTEND_PORT..."
    nohup npm run dev > ../frontend.log 2>&1 &
    local frontend_pid=$!
    
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if check_port $FRONTEND_PORT; then
            log_success "Frontend dev server started successfully (PID: $frontend_pid)"
            log_success "Frontend available at: http://localhost:$FRONTEND_PORT"
            return 0
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            log_error "Frontend failed to start within 30 seconds"
            return 1
        fi
        
        echo -n "."
        sleep 1
        ((attempt++))
    done
}

# Show application status
show_status() {
    log_header "APPLICATION STATUS"
    
    echo -e "${CYAN}Database (PostgreSQL):${NC}"
    manage_docker status
    
    echo -e "\n${CYAN}Backend API (GraphQL):${NC}"
    if check_port $BACKEND_PORT; then
        log_success "Backend running on port $BACKEND_PORT"
        log_info "API endpoint: http://localhost:$BACKEND_PORT/graphql"
    else
        log_error "Backend not running on port $BACKEND_PORT"
    fi
    
    echo -e "\n${CYAN}Frontend (React/Vite):${NC}"
    if check_port $FRONTEND_PORT; then
        log_success "Frontend running on port $FRONTEND_PORT"
        log_info "Web interface: http://localhost:$FRONTEND_PORT"
    else
        log_error "Frontend not running on port $FRONTEND_PORT"
    fi
    
    echo -e "\n${CYAN}Quick Database Check:${NC}"
    if check_port $BACKEND_PORT && docker exec $DB_CONTAINER pg_isready -U postgres >/dev/null 2>&1; then
        local product_count=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Product\";" 2>/dev/null | tr -d ' ')
        local task_count=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Task\";" 2>/dev/null | tr -d ' ')
        log_info "Database contains: $product_count products, $task_count tasks"
    else
        log_warning "Cannot check database content (database not accessible)"
    fi
}

# Clean database and add sample data
clean_database() {
    log_header "CLEAN DATABASE SETUP"
    log_warning "This will DELETE all existing data and create clean sample data!"
    echo "(Confirmation prompt removed for automation)"
    
    log_info "Cleaning database..."
    
    # Clean all tables
    # Ensure the database container is running
    if ! docker ps --format '{{.Names}}' | grep -q "^$DB_CONTAINER$"; then
        log_error "Database container $DB_CONTAINER is not running. Please start it with 'docker compose up -d db'."
        return 1
    fi

    # Wait for database to be healthy
    local max_attempts=30
    local attempt=1
    while [ $attempt -le $max_attempts ]; do
        if docker exec $DB_CONTAINER pg_isready -U postgres >/dev/null 2>&1; then
            break
        fi
        sleep 1
        ((attempt++))
    done
    if ! docker exec $DB_CONTAINER pg_isready -U postgres >/dev/null 2>&1; then
        log_error "Database is not ready after waiting. Please check the container logs."
        return 1
    fi

    # Clean tables
    docker exec $DB_CONTAINER psql -U postgres -d dap -c "DELETE FROM \"TaskOutcome\"; DELETE FROM \"Task\"; DELETE FROM \"Outcome\"; DELETE FROM \"License\"; DELETE FROM \"CustomerProduct\"; DELETE FROM \"CustomerSolution\"; DELETE FROM \"Product\"; DELETE FROM \"AuditLog\"; DELETE FROM \"ChangeItem\"; DELETE FROM \"ChangeSet\"; DELETE FROM \"Telemetry\";" 2>&1 | tee /tmp/dap_db_cleanup.log
    if grep -qE 'ERROR|FATAL' /tmp/dap_db_cleanup.log; then
        log_error "Failed to clean database tables. See /tmp/dap_db_cleanup.log for details."
        cat /tmp/dap_db_cleanup.log
        return 1
    fi
    log_success "Database cleaned"

    log_info "Creating 5 comprehensive products with full attributes..."
    log_info "Loading enhanced sample data from SQL file..."
    
    # Execute the comprehensive sample data SQL file
    if ! docker exec -i $DB_CONTAINER psql -U postgres -d dap < "$PROJECT_DIR/create-enhanced-sample-data.sql" >/dev/null 2>&1; then
        log_error "Failed to create enhanced sample data."
        return 1
    fi
    
    log_success "Enhanced sample data created successfully!"

    # Verify
    local products=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Product\";" 2>/dev/null | tr -d ' ')
    local tasks=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Task\";" 2>/dev/null | tr -d ' ')
    local licenses=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"License\";" 2>/dev/null | tr -d ' ')
    local outcomes=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Outcome\";" 2>/dev/null | tr -d ' ')
    local customers=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Customer\";" 2>/dev/null | tr -d ' ')
    
    log_info "Created comprehensive sample data:"
    log_info "  📦 $products Products (E-Commerce, FinTech, Healthcare, Logistics, EdTech)"
    log_info "  📋 $tasks Tasks (5-10 tasks per product with full attributes)"
    log_info "  🏷️ $licenses Licenses (Essential, Advantage, Signature tiers)"
    log_info "  🎯 $outcomes Outcomes (Success metrics and KPIs)"
    log_info "  🏢 $customers Customers (Enterprise clients)"
}

# Start all services
start_all() {
    log_header "STARTING $APP_NAME"
    
    manage_docker start || exit 1
    start_backend || exit 1
    start_frontend || exit 1
    
    echo ""
    log_success "All services started successfully!"
    log_info "Database: PostgreSQL running in container"
    log_info "Backend API: http://localhost:$BACKEND_PORT/graphql"
    log_info "Frontend App: http://localhost:$FRONTEND_PORT"
}

# Stop all services
stop_all() {
    log_header "STOPPING $APP_NAME"
    
    kill_node_processes
    manage_docker stop
    docker stop $(docker ps -q --filter "name=dap_") 2>/dev/null || true
    
    log_success "All services stopped"
}

# Restart all services
restart_all() {
    log_header "RESTARTING $APP_NAME"
    
    stop_all
    echo ""
    sleep 2
    start_all
    
    echo ""
    log_header "BROWSER CACHE CLEARING"
    log_warning "If GUI still shows old data, clear your browser cache:"
    log_info "1. Press Ctrl+Shift+R (hard refresh)"
    log_info "2. Or open Private/Incognito window: Ctrl+Shift+N"
    log_info "3. Visit: http://localhost:$FRONTEND_PORT"
}

# Helper function to check if backend is running
check_backend_running() {
    lsof -ti:$BACKEND_PORT >/dev/null 2>&1
}

# Helper function to check if frontend is running
check_frontend_running() {
    lsof -ti:$FRONTEND_PORT >/dev/null 2>&1
}

# Run comprehensive user test
run_comprehensive_test() {
    log_header "COMPREHENSIVE USER TEST"
    
    # Check if comprehensive test script exists
    if [ ! -f "$PROJECT_DIR/comprehensive-user-test.js" ]; then
        log_error "Comprehensive test script not found at $PROJECT_DIR/comprehensive-user-test.js"
        echo ""
        log_info "Please ensure the comprehensive-user-test.js file exists in the project directory."
        return 1
    fi
    
    # Check if Node.js is available
    if ! command -v node >/dev/null 2>&1; then
        log_error "Node.js is not installed or not in PATH. Please install Node.js to run the comprehensive test."
        return 1
    fi
    
    # Check if the application is running
    log_info "Checking application status..."
    if ! check_backend_running && ! check_frontend_running; then
        log_warning "Application is not running. Starting it now..."
        if ! start_all; then
            log_error "Failed to start application. Cannot run comprehensive test."
            return 1
        fi
        echo ""
        log_info "Waiting for services to be fully ready..."
        sleep 5
    fi
    
    # Verify backend is responding
    log_info "Verifying backend API is responding..."
    local max_attempts=10
    local attempt=1
    while [ $attempt -le $max_attempts ]; do
        if curl -s "http://localhost:$BACKEND_PORT/graphql" -H "Content-Type: application/json" -d '{"query":"query{__typename}"}' >/dev/null 2>&1; then
            log_success "Backend API is responding"
            break
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            log_error "Backend API is not responding after $max_attempts attempts"
            return 1
        fi
        
        echo -n "."
        sleep 2
        ((attempt++))
    done
    
    echo ""
    log_info "Running comprehensive end-user test..."
    log_info "This will test complete functionality: Frontend → Backend → Database"
    echo ""
    
    # Change to project directory and run the test
    cd "$PROJECT_DIR"
    
    # Run the comprehensive test and capture its exit code
    if node comprehensive-user-test.js; then
        echo ""
        log_success "🎉 COMPREHENSIVE TEST PASSED! 🎉"
        log_info "All application functionality is working correctly"
        log_info "✅ Product creation and editing with mandatory attributes"
        log_info "✅ Task management with all attributes (howToDoc, howToVideo)"
        log_info "✅ Database persistence and relationship integrity"
        log_info "✅ Complete end-user workflow validation"
        echo ""
        log_info "The application is ready for production use!"
        return 0
    else
        echo ""
        log_error "❌ COMPREHENSIVE TEST FAILED!"
        log_warning "Some functionality may not be working correctly"
        log_info "Check the test output above for specific errors"
        log_info "Fix any issues and run './dap test' again"
        echo ""
        log_info "For help debugging, check:"
        log_info "• Backend logs: Check terminal where backend is running"
        log_info "• Frontend logs: Check browser console at http://localhost:$FRONTEND_PORT"
        log_info "• Database: Ensure PostgreSQL container is running"
        return 1
    fi
}

# Clean restart with database reset
clean_restart() {
    log_header "CLEAN RESTART WITH SAMPLE DATA"
    
    stop_all
    echo ""
    sleep 2
    
    # Clean database first
    log_info "Setting up clean database..."
    if ! manage_docker start; then
        log_error "Failed to start database"
        exit 1
    fi
    
    # Wait a moment for DB to be ready
    sleep 3
    clean_database
    
    # Start services
    echo ""
    start_backend || exit 1
    start_frontend || exit 1
    
    echo ""
    log_success "Clean restart completed!"
    log_info "✅ Database: Clean with 5 products and 40 tasks (comprehensive attributes)"
    log_info "✅ Backend API: http://localhost:$BACKEND_PORT/graphql"
    log_info "✅ Frontend App: http://localhost:$FRONTEND_PORT"
    echo ""
    log_info "🔄 Press Ctrl+Shift+R in your browser to see the enhanced sample data!"
}

# Add sample data without affecting user-created data
add_sample_data() {
    log_header "ADDING COMPREHENSIVE SAMPLE DATA"
    log_info "This will add sample data WITHOUT removing existing user data"
    
    # Check if database container is running
    if [ -z "$DB_CONTAINER" ]; then
        log_error "No database container found. Run '$0 start' first."
        exit 1
    fi
    
    if ! docker ps --format "{{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
        log_error "Database container '$DB_CONTAINER' is not running. Run '$0 start' first."
        exit 1
    fi
    
    # Check if backend directory exists
    if [ ! -d "$BACKEND_DIR" ]; then
        log_error "Backend directory not found at $BACKEND_DIR"
        exit 1
    fi
    
    # Navigate to backend directory
    cd "$BACKEND_DIR"
    
    # Check if node_modules exists
    if [ ! -d "node_modules" ]; then
        log_info "Installing backend dependencies..."
        npm install
    fi
    
    # Run the seed script (non-destructive)
    log_info "📝 Adding comprehensive sample data via TypeScript seed script..."
    log_info "   This uses upsert logic to preserve existing data"
    
    if npm run seed 2>&1 | tee /tmp/dap_seed.log; then
        echo ""
        log_success "✅ Sample data added successfully!"
        
        # Count what was created
        local products=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Product\";" 2>/dev/null | tr -d ' ')
        local tasks=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Task\";" 2>/dev/null | tr -d ' ')
        local licenses=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"License\";" 2>/dev/null | tr -d ' ')
        local outcomes=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Outcome\";" 2>/dev/null | tr -d ' ')
        
        echo ""
        log_info "📊 Current database contains:"
        log_info "  📦 $products Products"
        log_info "  📋 $tasks Tasks"
        log_info "  🏷️ $licenses Licenses"
        log_info "  🎯 $outcomes Outcomes"
        echo ""
        log_info "Sample products added (if not already present):"
        log_info "  • Retail Management App (15 tasks)"
        log_info "  • Financial Services App (14 tasks)"
        log_info "  • IT Operations App (expanding to 12+ tasks)"
        log_info "  • AI-Powered Analytics App (expanding to 12+ tasks)"
        log_info "  • Network Management App (expanding to 12+ tasks)"
        echo ""
        log_info "Each product includes:"
        log_info "  ✓ 3 license tiers (Essential, Advantage, Signature)"
        log_info "  ✓ 5 outcomes with success metrics"
        log_info "  ✓ 5 progressive releases"
        log_info "  ✓ Comprehensive tasks with multiple documentation links"
        log_info "  ✓ All fields populated (howToDoc, howToVideo arrays)"
    else
        echo ""
        log_error "❌ Failed to add sample data"
        log_info "Check /tmp/dap_seed.log for error details"
        exit 1
    fi
    
    echo ""
    log_info "🔄 Refresh your browser (Ctrl+Shift+R) to see the sample data!"
}

# Remove sample data while preserving user-created data
reset_sample_data() {
    log_info "Removing sample data while preserving user-created data..."
    
    # Check if database container is running
    if [ -z "$DB_CONTAINER" ]; then
        log_error "No database container found. Run '$0 start' first."
        exit 1
    fi
    
    if ! docker ps --format "{{.Names}}" | grep -q "^${DB_CONTAINER}$"; then
        log_error "Database container '$DB_CONTAINER' is not running. Run '$0 start' first."
        exit 1
    fi
    
    # Check if remove-sample-data.sql exists
    if [ ! -f "$PROJECT_DIR/remove-sample-data.sql" ]; then
        log_error "❌ remove-sample-data.sql not found. This script is required for selective sample data removal."
        exit 1
    fi
    
    # Execute the sample data removal script
    log_info "🗑️ Removing sample data (preserving user data)..."
    if docker exec -i "$DB_CONTAINER" psql -U postgres -d dap < "$PROJECT_DIR/remove-sample-data.sql"; then
        echo ""
        log_success "✅ Sample data removed successfully!"
        
        # Show remaining data
        local products=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Product\" WHERE \"deletedAt\" IS NULL;" 2>/dev/null | tr -d ' ')
        local tasks=$(docker exec $DB_CONTAINER psql -U postgres -d dap -t -c "SELECT COUNT(*) FROM \"Task\" WHERE \"deletedAt\" IS NULL;" 2>/dev/null | tr -d ' ')
        
        echo ""
        log_info "📊 Removed sample products:"
        log_info "  • retail-app-001 (Retail Management App)"
        log_info "  • financial-app-001 (Financial Services App)"
        log_info "  • it-app-001 (IT Operations App)"
        log_info "  • ai-app-001 (AI-Powered Analytics App)"
        log_info "  • networking-app-001 (Network Management App)"
        log_info "  • test-product-1 (Test E-Commerce Platform)"
        echo ""
        log_info "📊 Removed ALL customer adoption data:"
        log_info "  • All customer product assignments"
        log_info "  • All adoption plans"
        log_info "  • All customer tasks and telemetry"
        log_info "  • Customer solutions for sample products"
        echo ""
        log_info "📊 Remaining database contains:"
        log_info "  📦 $products Products (user-created)"
        log_info "  📋 $tasks Tasks (user-created)"
        log_info "  👥 Customers (preserved, but unassigned)"
        echo ""
        log_info "✅ Ready for fresh customer assignments!"
    else
        log_error "❌ Failed to remove sample data"
        exit 1
    fi
    
    log_info "🔄 Refresh your browser to see the updated data!"
}

# Show help
show_help() {
    echo -e "${PURPLE}DAP Application Manager${NC}"
    echo ""
    echo "All-in-one script to manage the DAP application lifecycle."
    echo ""
    echo "Usage: $0 [command]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}start${NC}         - Start all application services"
    echo -e "  ${RED}stop${NC}          - Stop all application services" 
    echo -e "  ${YELLOW}restart${NC}       - Restart all services (keeps existing data)"
    echo -e "  ${CYAN}clean-restart${NC} - Stop, clean database, add sample data, restart"
    echo -e "  ${BLUE}add-sample${NC}    - Add sample data to existing database (preserves user data)"
    echo -e "  ${PURPLE}reset-sample${NC}  - Remove sample data only (preserves user data)"
    echo -e "  ${PURPLE}test${NC}          - Run comprehensive end-user test suite"
    echo -e "  ${BLUE}status${NC}        - Show status of all services and data"
    echo -e "  ${PURPLE}help${NC}          - Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 start           # Start for daily development"
    echo "  $0 clean-restart   # Fresh start with clean sample data"
    echo "  $0 add-sample      # Add sample data to existing database"
    echo "  $0 reset-sample    # Remove sample data, keep user data"
    echo "  $0 test            # Validate all functionality with comprehensive test"
    echo "  $0 status          # Check what's running"
    echo "  $0 stop            # End development session"
    echo ""
    echo "Components managed:"
    echo "  • PostgreSQL Database (Docker container)"
    echo "  • Backend GraphQL API (Node.js on port $BACKEND_PORT)"
    echo "  • Frontend React App (Vite on port $FRONTEND_PORT)"
    echo ""
    echo "The clean-restart command provides:"
    echo "  • 5 comprehensive products with mandatory attributes"
    echo "  • Tasks with howToDoc and howToVideo fields"
    echo "  • Complete data relationships and constraints"
    echo "  • Essential licenses, outcomes, and releases for each product"
    echo ""
    echo "Sample data management:"
    echo "  • add-sample: Adds sample data without affecting existing user data"
    echo "  • reset-sample: Removes only sample data, preserves user-created data"
    echo "  • clean-restart: Completely resets database and adds fresh sample data"
    echo ""
    echo "The test command runs comprehensive validation:"
    echo "  • Simulates complete end-user workflows"
    echo "  • Tests all CRUD operations and business logic"
    echo "  • Verifies database persistence and relationships"
    echo "  • Validates mandatory attributes and constraints"
    echo "  • Ensures frontend ↔ backend ↔ database integration"
}

# Main script logic
main() {
    # Change to project directory
    cd "$PROJECT_DIR"
    
    case "${1:-}" in
        start)
            start_all
            ;;
        stop)
            stop_all
            ;;
        restart)
            restart_all
            ;;
        clean-restart)
            clean_restart
            ;;
        add-sample)
            add_sample_data
            ;;
        reset-sample)
            reset_sample_data
            ;;
        test)
            run_comprehensive_test
            ;;
        status)
            show_status
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            if [ -n "${1:-}" ]; then
                log_error "Unknown command: $1"
                echo ""
            fi
            show_help
            ;;
    esac
}

# Check if script is run with sudo (not recommended)
if [ "$EUID" -eq 0 ]; then
    log_warning "Running as root is not recommended. Consider running as a regular user."
fi

# Run main function with all arguments
main "$@"