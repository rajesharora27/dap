#!/bin/bash

#######################################################################################
# DAP Production Manager
# 
# Manages the DAP application on production servers using PM2 process manager.
# This script provides commands to restart, monitor, and manage all DAP services.
#
# Services managed:
#   - Backend API (Node.js/Express/Apollo GraphQL) via PM2 cluster mode
#   - Frontend (static files served by Nginx/Apache)
#   - PostgreSQL Database (systemd service)
#
# Usage: ./dap [command]
# 
# Location: /data/dap/dap (production server)
#######################################################################################

set -e

# =============================================================================
# CONFIGURATION - Modify these variables for your environment
# =============================================================================

# Root directory for the DAP application
DAP_ROOT="/data/dap"

# Application directory (where backend/frontend/ecosystem.config.js are located)
APP_DIR="${DAP_ROOT}/app"

# Logs directory
LOGS_DIR="${DAP_ROOT}/logs"

# PM2 ecosystem configuration file
PM2_CONFIG="${APP_DIR}/ecosystem.config.js"

# Backend process name in PM2
PM2_BACKEND_NAME="dap-backend"

# Frontend process name in PM2 (if using PM2 for static serving)
PM2_FRONTEND_NAME="dap-frontend"

# PostgreSQL database name
DB_NAME="dap"

# User that runs the DAP application (PM2 processes run under this user)
DAP_USER="dap"

# =============================================================================
# USER CONTEXT HELPERS - Run commands as correct user
# =============================================================================

# Detect if we need to use sudo -u dap for PM2 commands
# Returns: command prefix to use (empty if already dap, "sudo -u dap" otherwise)
get_dap_prefix() {
    if [ "$(whoami)" = "${DAP_USER}" ]; then
        echo ""
    else
        echo "sudo -u ${DAP_USER}"
    fi
}

# Run a command as the dap user (handles both direct and sudo access)
run_as_dap() {
    local prefix=$(get_dap_prefix)
    if [ -n "$prefix" ]; then
        $prefix "$@"
    else
        "$@"
    fi
}

# =============================================================================
# COLORS AND LOGGING - Output formatting helpers
# =============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Log informational message
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }

# Log success message
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }

# Log warning message
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Log error message
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Log header (section separator)
log_header() { echo -e "${PURPLE}=== $1 ===${NC}"; }

# =============================================================================
# ENVIRONMENT SYNC - Ensure correct .env is applied
# =============================================================================

# Sync environment from .env.prod to backend/.env
# This ensures the backend uses production database credentials
sync_env() {
    log_info "Syncing production environment..."
    
    if [ -f "${APP_DIR}/.env.prod" ]; then
        # Use .env.prod as the source of truth
        run_as_dap cp "${APP_DIR}/.env.prod" "${APP_DIR}/.env"
        run_as_dap cp "${APP_DIR}/.env.prod" "${APP_DIR}/backend/.env"
        log_success "Environment synced from .env.prod"
    elif [ -f "${APP_DIR}/.env" ]; then
        # Fallback: sync .env to backend
        run_as_dap cp "${APP_DIR}/.env" "${APP_DIR}/backend/.env"
        log_success "Environment synced from .env"
    else
        log_warning "No .env file found in ${APP_DIR}"
    fi
}

# =============================================================================
# SERVICE MANAGEMENT - PM2 process control
# =============================================================================

# Restart ALL services: Database + Backend + Frontend
# This is the most comprehensive restart - use after deployments or major issues
restart_all() {
    log_header "RESTARTING ALL SERVICES"
    
    # Step 1: Sync environment before restart
    sync_env
    
    # Step 2: Restart PostgreSQL to clear all database connections
    log_info "Step 1/3: Restarting PostgreSQL database..."
    if command -v systemctl &> /dev/null; then
        if sudo systemctl restart postgresql-16 2>/dev/null || sudo systemctl restart postgresql 2>/dev/null; then
            log_success "PostgreSQL restarted"
            # Wait for PostgreSQL to be ready
            sleep 3
        else
            log_warning "Could not restart PostgreSQL (may need sudo privileges)"
        fi
    fi
    
    # Step 3: Restart all PM2 processes (backend + frontend)
    log_info "Step 2/3: Restarting PM2 processes..."
    cd "${APP_DIR}"
    
    # Use --update-env to pick up any .env changes
    if run_as_dap pm2 restart "${PM2_CONFIG}" --update-env; then
        log_success "PM2 processes restarted"
    else
        log_error "Failed to restart PM2 services"
        return 1
    fi
    
    # Step 4: Verify services are running
    log_info "Step 3/3: Verifying services..."
    sleep 2
    
    echo ""
    log_success "All services restarted successfully!"
    run_as_dap pm2 list
}

# Restart backend service only
# Faster than full restart when only backend code changed
restart_backend() {
    log_header "RESTARTING BACKEND"
    
    # Sync environment before restart
    sync_env
    
    log_info "Restarting ${PM2_BACKEND_NAME} processes..."
    
    # Use --update-env to pick up any .env changes
    if run_as_dap pm2 restart "${PM2_BACKEND_NAME}" --update-env; then
        log_success "Backend restarted successfully"
    else
        log_error "Failed to restart backend"
        return 1
    fi
    
    echo ""
    run_as_dap pm2 list
}

# Restart frontend service only
# Note: On production, frontend is usually served by Apache/Nginx from static files
# This is only needed if using PM2's serve module for frontend
restart_frontend() {
    log_header "RESTARTING FRONTEND"
    
    log_info "Restarting ${PM2_FRONTEND_NAME} process..."
    
    # Check if frontend process exists in PM2
    if run_as_dap pm2 describe "${PM2_FRONTEND_NAME}" &>/dev/null; then
        if run_as_dap pm2 restart "${PM2_FRONTEND_NAME}" --update-env; then
            log_success "Frontend restarted successfully"
        else
            log_error "Failed to restart frontend"
            return 1
        fi
    else
        log_warning "Frontend process '${PM2_FRONTEND_NAME}' not found in PM2"
        log_info "Frontend is likely served by Apache/Nginx from: ${APP_DIR}/frontend/dist"
        log_info "To rebuild frontend, redeploy from development machine"
    fi
    
    echo ""
    run_as_dap pm2 list
}

# =============================================================================
# DATABASE MANAGEMENT - PostgreSQL control
# =============================================================================

# Restart PostgreSQL database
# This clears ALL active database connections - use when hitting connection limits
restart_db() {
    log_header "RESTARTING DATABASE"
    
    log_info "Restarting PostgreSQL to clear all connections..."
    log_warning "This will temporarily disconnect all database clients!"
    
    # Try systemctl with different PostgreSQL service names
    if command -v systemctl &> /dev/null; then
        # Try versioned service first (e.g., postgresql-16), then generic
        if sudo systemctl restart postgresql-16 2>/dev/null; then
            log_success "PostgreSQL restarted via postgresql-16"
        elif sudo systemctl restart postgresql 2>/dev/null; then
            log_success "PostgreSQL restarted via postgresql"
        else
            log_error "Failed to restart PostgreSQL service"
            log_info "Try: sudo systemctl list-units | grep postgres"
            return 1
        fi
    # Fallback to service command (older systems)
    elif command -v service &> /dev/null; then
        sudo service postgresql restart
        log_success "PostgreSQL restarted via service"
    else
        log_error "Cannot restart PostgreSQL - no systemctl or service command found"
        return 1
    fi
    
    # Wait for PostgreSQL to be ready again
    log_info "Waiting for PostgreSQL to accept connections..."
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        # Try pg_isready as current user or postgres user
        if pg_isready -q 2>/dev/null || sudo -u postgres pg_isready -q 2>/dev/null; then
            log_success "PostgreSQL is ready and accepting connections"
            break
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            log_error "PostgreSQL failed to become ready within ${max_attempts} seconds"
            return 1
        fi
        
        echo -n "."
        sleep 1
        ((attempt++))
    done
    echo ""
    
    # Restart backend to establish fresh database connections
    log_info "Restarting backend to establish fresh connections..."
    run_as_dap pm2 restart "${PM2_BACKEND_NAME}" --update-env
    log_success "Backend restarted with fresh database connections"
}

# =============================================================================
# STATUS AND MONITORING - View service state
# =============================================================================

# Show status of all services
show_status() {
    log_header "PRODUCTION STATUS"
    
    # PM2 process status
    echo -e "${CYAN}PM2 Processes:${NC}"
    run_as_dap pm2 list
    
    echo ""
    
    # PostgreSQL status - try multiple methods
    echo -e "${CYAN}PostgreSQL Status:${NC}"
    
    # Method 1: Try pg_isready with localhost
    if pg_isready -h localhost -p 5432 -q 2>/dev/null; then
        log_success "PostgreSQL is accepting connections"
        
        # Try to get connection info from backend's perspective
        if [ -f "${APP_DIR}/backend/.env" ]; then
            # Extract database URL and test connection
            local db_url=$(grep "^DATABASE_URL=" "${APP_DIR}/backend/.env" | cut -d= -f2-)
            if [ -n "$db_url" ]; then
                # Use psql to count connections (this works if dap user can connect)
                local conn_count=$(PGPASSWORD="$(echo $db_url | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')" psql -h localhost -U "${DB_NAME}" -d "${DB_NAME}" -t -c "SELECT count(*) FROM pg_stat_activity WHERE datname='${DB_NAME}';" 2>/dev/null | tr -d ' ' || echo "?")
                log_info "Active connections to '${DB_NAME}': ${conn_count}"
            fi
        fi
    else
        # Method 2: Check if port is listening
        if netstat -tuln 2>/dev/null | grep -q ":5432 " || ss -tuln 2>/dev/null | grep -q ":5432 "; then
            log_warning "PostgreSQL port 5432 is listening but not responding to pg_isready"
        else
            log_error "PostgreSQL is not running (port 5432 not listening)"
        fi
    fi
    
    echo ""
    
    # Disk usage
    echo -e "${CYAN}Disk Usage (${DAP_ROOT}):${NC}"
    df -h "${DAP_ROOT}" 2>/dev/null || df -h .
    
    echo ""
    
    # Memory usage
    echo -e "${CYAN}Memory Usage:${NC}"
    free -h
}

# Show logs from PM2
# Usage: show_logs [service]
#   service: 'backend', 'frontend', 'all' (default)
show_logs() {
    local service=${1:-all}
    
    log_header "VIEWING LOGS"
    log_info "Press Ctrl+C to exit log viewer"
    
    case $service in
        backend)
            log_info "Showing ${PM2_BACKEND_NAME} logs..."
            run_as_dap pm2 logs "${PM2_BACKEND_NAME}" --lines 50
            ;;
        frontend)
            log_info "Showing ${PM2_FRONTEND_NAME} logs..."
            run_as_dap pm2 logs "${PM2_FRONTEND_NAME}" --lines 50
            ;;
        all|*)
            log_info "Showing all PM2 logs..."
            run_as_dap pm2 logs --lines 50
            ;;
    esac
}

# =============================================================================
# START/STOP SERVICES - Full lifecycle control
# =============================================================================

# Stop all PM2 services
stop_all() {
    log_header "STOPPING ALL SERVICES"
    
    log_info "Stopping all PM2 processes..."
    run_as_dap pm2 stop all
    
    log_success "All PM2 processes stopped"
    run_as_dap pm2 list
}

# Helper function to check if PostgreSQL is ready (handles PATH issues on CentOS)
pg_is_running() {
    # Try pg_isready with various paths
    if pg_isready -h localhost -p 5432 -q 2>/dev/null; then
        return 0
    elif /usr/pgsql-16/bin/pg_isready -h localhost -p 5432 -q 2>/dev/null; then
        return 0
    elif sudo -u postgres /usr/pgsql-16/bin/pg_isready -q 2>/dev/null; then
        return 0
    elif sudo -u postgres pg_isready -q 2>/dev/null; then
        return 0
    # Fallback: check if port 5432 is listening
    elif netstat -tuln 2>/dev/null | grep -q ":5432 "; then
        return 0
    elif ss -tuln 2>/dev/null | grep -q ":5432 "; then
        return 0
    fi
    return 1
}

# Start all services from ecosystem.config.js
start_all() {
    log_header "STARTING ALL SERVICES"
    
    # Sync environment before start
    sync_env
    
    # Step 1: Ensure PostgreSQL is running
    log_info "Step 1/3: Ensuring PostgreSQL is running..."
    
    # Check if PostgreSQL is already running
    if pg_is_running; then
        log_success "PostgreSQL is already running"
    else
        log_info "PostgreSQL not running, starting it..."
        
        # Try systemctl with different PostgreSQL service names
        if command -v systemctl &> /dev/null; then
            # Try versioned service first (e.g., postgresql-16), then generic
            if sudo systemctl start postgresql-16 2>/dev/null; then
                log_success "PostgreSQL started via postgresql-16"
            elif sudo systemctl start postgresql 2>/dev/null; then
                log_success "PostgreSQL started via postgresql"
            else
                log_error "Failed to start PostgreSQL service"
                log_info "Try: sudo systemctl list-units | grep postgres"
                return 1
            fi
        # Fallback to service command (older systems)
        elif command -v service &> /dev/null; then
            sudo service postgresql start
            log_success "PostgreSQL started via service"
        else
            log_error "Cannot start PostgreSQL - no systemctl or service command found"
            return 1
        fi
        
        # Wait for PostgreSQL to be ready
        log_info "Waiting for PostgreSQL to accept connections..."
        local max_attempts=30
        local attempt=1
        
        while [ $attempt -le $max_attempts ]; do
            if pg_is_running; then
                log_success "PostgreSQL is ready and accepting connections"
                break
            fi
            
            if [ $attempt -eq $max_attempts ]; then
                log_error "PostgreSQL failed to become ready within ${max_attempts} seconds"
                return 1
            fi
            
            echo -n "."
            sleep 1
            ((attempt++))
        done
        echo ""
    fi
    
    # Step 2: Start PM2 processes
    log_info "Step 2/3: Starting PM2 processes from ${PM2_CONFIG}..."
    cd "${APP_DIR}"
    
    if run_as_dap pm2 start "${PM2_CONFIG}" --update-env; then
        log_success "PM2 processes started"
    else
        log_error "Failed to start PM2 services"
        return 1
    fi
    
    # Step 3: Verify services
    log_info "Step 3/3: Verifying services..."
    sleep 2
    
    log_success "All services started successfully!"
    echo ""
    run_as_dap pm2 list
}

# =============================================================================
# HELP - Usage documentation
# =============================================================================

show_help() {
    echo -e "${PURPLE}DAP Production Manager${NC}"
    echo ""
    echo "Manages the DAP application on production servers using PM2."
    echo ""
    echo "Usage: $0 [command]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}restart${NC}           - Restart all services (syncs env, restarts PM2)"
    echo -e "  ${GREEN}restart-backend${NC}   - Restart backend only (quick restart)"
    echo -e "  ${GREEN}restart-frontend${NC}  - Restart frontend only (if using PM2 serve)"
    echo -e "  ${YELLOW}restart-db${NC}        - Restart PostgreSQL (clears ALL connections)"
    echo -e "  ${GREEN}start${NC}             - Start all services"
    echo -e "  ${RED}stop${NC}              - Stop all services"
    echo -e "  ${BLUE}status${NC}            - Show status of all services"
    echo -e "  ${CYAN}logs${NC}              - Show live logs (all services)"
    echo -e "  ${CYAN}logs backend${NC}      - Show backend logs only"
    echo -e "  ${CYAN}logs frontend${NC}     - Show frontend logs only"
    echo -e "  ${PURPLE}help${NC}              - Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 restart           # Restart everything after deployment"
    echo "  $0 restart-backend   # Quick restart after config change"
    echo "  $0 restart-frontend  # Restart static file server"
    echo "  $0 restart-db        # Fix 'too many connections' errors"
    echo "  $0 status            # Check what's running"
    echo "  $0 logs backend      # Debug backend issues"
    echo ""
    echo "Configuration (edit variables at top of script):"
    echo "  DAP_ROOT:    ${DAP_ROOT}"
    echo "  APP_DIR:     ${APP_DIR}"
    echo "  LOGS_DIR:    ${LOGS_DIR}"
    echo "  PM2_CONFIG:  ${PM2_CONFIG}"
    echo "  DB_NAME:     ${DB_NAME}"
}

# =============================================================================
# MAIN - Command dispatcher
# =============================================================================

main() {
    case "${1:-help}" in
        restart)
            restart_all
            ;;
        restart-backend|backend)
            restart_backend
            ;;
        restart-frontend|frontend)
            restart_frontend
            ;;
        restart-db|db)
            restart_db
            ;;
        start)
            start_all
            ;;
        stop)
            stop_all
            ;;
        status)
            show_status
            ;;
        logs)
            show_logs "${2:-all}"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all command-line arguments
main "$@"
