import * as React from 'react';
import { useState } from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Grid
} from '@mui/material';
import {
  ArrowBack,
  Add,
  Edit,
  Delete
} from '@mui/icons-material';
import { gql, useQuery, useMutation } from '@apollo/client';
import { useAuth } from './AuthContext';

const OUTCOMES_FOR_PRODUCT = gql`
  query OutcomesForProduct($productId: ID!) {
    outcomes(productId: $productId) {
      id
      name
      description
      product {
        id
        name
      }
    }
  }
`;

const CREATE_OUTCOME = gql`
  mutation CreateOutcome($input: OutcomeInput!) {
    createOutcome(input: $input) {
      id
      name
      description
      product {
        id
        name
      }
    }
  }
`;

const UPDATE_OUTCOME = gql`
  mutation UpdateOutcome($id: ID!, $input: OutcomeInput!) {
    updateOutcome(id: $id, input: $input) {
      id
      name
      description
      product {
        id
        name
      }
    }
  }
`;

const DELETE_OUTCOME = gql`
  mutation DeleteOutcome($id: ID!) {
    deleteOutcome(id: $id)
  }
`;

interface ProductDetailPageProps {
  product: any;
  onBack: () => void;
}

export function ProductDetailPage({ product, onBack }: ProductDetailPageProps) {
  const { token } = useAuth();
  const [addOutcomeDialog, setAddOutcomeDialog] = useState(false);
  const [editOutcomeDialog, setEditOutcomeDialog] = useState(false);
  const [newOutcome, setNewOutcome] = useState({ name: '', description: '' });
  const [editingOutcome, setEditingOutcome] = useState<any>(null);

  console.log('ProductDetailPage authentication:', { 
    token: token ? 'Token present' : 'No token',
    tokenLength: token?.length || 0,
    tokenPreview: token ? token.substring(0, 30) + '...' : 'none'
  });

  // Add Apollo Client debugging
  const client = useApolloClient();
  console.log('Apollo Client link config:', {
    link: client.link,
    cache: client.cache
  });

  // Queries and mutations
  const { data: outcomesData, loading: outcomesLoading, refetch: refetchOutcomes } = useQuery(OUTCOMES_FOR_PRODUCT, {
    variables: { productId: product.id },
    errorPolicy: 'all'
  });

  const [createOutcome] = useMutation(CREATE_OUTCOME, {
    errorPolicy: 'all',
    onError: (error) => {
      console.error('=== CREATE_OUTCOME mutation onError ===', error);
    },
    onCompleted: (data) => {
      console.log('=== CREATE_OUTCOME mutation onCompleted ===', data);
    }
  });
  const [updateOutcome] = useMutation(UPDATE_OUTCOME);
  const [deleteOutcome] = useMutation(DELETE_OUTCOME);

  const outcomes = outcomesData?.outcomes || [];

  const handleCreateOutcome = async () => {
    console.log('=== Starting outcome creation ===');
    console.log('Form data:', { name: newOutcome.name, description: newOutcome.description });
    console.log('Product ID:', product.id);
    console.log('Current token from context:', token ? token.substring(0, 30) + '...' : 'none');
    console.log('Token from localStorage:', localStorage.getItem('token') ? localStorage.getItem('token')!.substring(0, 30) + '...' : 'none');
    console.log('All localStorage keys:', Object.keys(localStorage));
    
    if (!newOutcome.name.trim()) {
      alert('Please enter an outcome name');
      return;
    }

    // Check if outcome name already exists
    const existingOutcome = outcomes.find((outcome: any) => 
      outcome.name.toLowerCase() === newOutcome.name.trim().toLowerCase()
    );
    
    if (existingOutcome) {
      alert(`An outcome with the name "${newOutcome.name}" already exists. Please choose a different name.`);
      return;
    }

    console.log('Validation passed, calling GraphQL mutation...');

    try {
      console.log('About to call createOutcome mutation...');
      console.log('Variables:', {
        input: {
          name: newOutcome.name.trim(),
          description: newOutcome.description.trim(),
          productId: product.id
        }
      });
      
      const result = await createOutcome({
        variables: {
          input: {
            name: newOutcome.name.trim(),
            description: newOutcome.description.trim(),
            productId: product.id
          }
        },
        refetchQueries: ['OutcomesForProduct'],
        awaitRefetchQueries: true
      });

      console.log('GraphQL mutation successful:', result);
      console.log('Result structure:', {
        hasData: !!result.data,
        data: result.data,
        errors: result.errors,
        fullResult: result
      });
      
      if (result.data?.createOutcome) {
        console.log('Outcome created successfully:', result.data.createOutcome);
        setNewOutcome({ name: '', description: '' });
        setAddOutcomeDialog(false);
        await refetchOutcomes();
      } else {
        console.error('No data in result or no createOutcome field');
        throw new Error('No data returned from mutation');
      }
    } catch (error: any) {
      console.error('=== GraphQL Error ===');
      console.error('Full error object:', error);
      console.error('Error message:', error?.message);
      console.error('GraphQL errors:', error?.graphQLErrors);
      console.error('Network error:', error?.networkError);
      
      // Extract user-friendly error message
      let errorMessage = 'Unknown error occurred';
      if (error?.graphQLErrors?.length > 0) {
        errorMessage = error.graphQLErrors[0].message;
      } else if (error?.message) {
        errorMessage = error.message;
      }
      
      alert('Failed to create outcome: ' + errorMessage);
    }
  };

  const handleUpdateOutcome = async () => {
    if (!editingOutcome?.name?.trim()) {
      alert('Please enter an outcome name');
      return;
    }

    // Check if outcome name already exists (excluding current outcome)
    const existingOutcome = outcomes.find((outcome: any) => 
      outcome.id !== editingOutcome.id && 
      outcome.name.toLowerCase() === editingOutcome.name.trim().toLowerCase()
    );
    
    if (existingOutcome) {
      alert(`An outcome with the name "${editingOutcome.name}" already exists. Please choose a different name.`);
      return;
    }

    try {
      await updateOutcome({
        variables: {
          id: editingOutcome.id,
          input: {
            name: editingOutcome.name.trim(),
            description: editingOutcome.description.trim(),
            productId: product.id
          }
        }
      });

      setEditOutcomeDialog(false);
      setEditingOutcome(null);
      await refetchOutcomes();
    } catch (error: any) {
      console.error('Error updating outcome:', error);
      
      // Extract user-friendly error message
      let errorMessage = 'Unknown error occurred';
      if (error?.graphQLErrors?.length > 0) {
        errorMessage = error.graphQLErrors[0].message;
      } else if (error?.message) {
        errorMessage = error.message;
      }
      
      alert('Failed to update outcome: ' + errorMessage);
    }
  };

  const handleDeleteOutcome = async (outcomeId: string) => {
    if (!confirm('Are you sure you want to delete this outcome?')) return;

    try {
      await deleteOutcome({
        variables: { id: outcomeId }
      });

      await refetchOutcomes();
    } catch (error: any) {
      console.error('Error deleting outcome:', error);
      alert('Failed to delete outcome: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleEditOutcome = (outcome: any) => {
    setEditingOutcome({ ...outcome });
    setEditOutcomeDialog(true);
  };

  return (
    <Box>
      {/* Header */}
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
        <IconButton onClick={onBack} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4">
          {product.name} - Product Details
        </Typography>
      </Box>

      {/* Product Info */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Grid container spacing={3}>
          <Grid item xs={12} md={8}>
            <Typography variant="h6" gutterBottom>
              Product Information
            </Typography>
            <Typography variant="body1" gutterBottom>
              <strong>Name:</strong> {product.name}
            </Typography>
            <Typography variant="body1" gutterBottom>
              <strong>Description:</strong> {product.description || 'No description available'}
            </Typography>
          </Grid>
        </Grid>
      </Paper>

      {/* Outcomes Section */}
      <Paper sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6">
            Product Outcomes
          </Typography>
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={() => setAddOutcomeDialog(true)}
          >
            Add Outcome
          </Button>
          <Button
            variant="outlined"
            onClick={async () => {
              console.log('=== Testing direct fetch ===');
              const localToken = localStorage.getItem('token');
              console.log('Direct fetch token:', localToken ? localToken.substring(0, 30) + '...' : 'none');
              
              const headers = {
                'Content-Type': 'application/json',
                'Authorization': 'admin' // Try the exact format that worked with curl
              };
              
              const requestBody = {
                query: `mutation CreateOutcome($input: OutcomeInput!) {
                  createOutcome(input: $input) {
                    id
                    name
                    description
                  }
                }`,
                variables: {
                  input: {
                    name: `Direct Test ${Date.now()}`,
                    description: "Testing direct fetch",
                    productId: product.id
                  }
                }
              };
              
              console.log('Direct fetch request details:', {
                url: '/graphql',
                method: 'POST',
                headers,
                body: JSON.stringify(requestBody, null, 2)
              });
              
              try {
                const response = await fetch('/graphql', {
                  method: 'POST',
                  headers,
                  body: JSON.stringify(requestBody)
                });
                
                console.log('Direct fetch response status:', response.status);
                console.log('Direct fetch response ok:', response.ok);
                console.log('Direct fetch response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                  const errorText = await response.text();
                  const errorHeaders = Object.fromEntries(response.headers.entries());
                  console.error('Direct fetch error details:', {
                    status: response.status,
                    statusText: response.statusText,
                    headers: errorHeaders,
                    body: errorText
                  });
                  alert(`Direct fetch FAILED: ${response.status} ${response.statusText} - ${errorText}`);
                  return;
                }
                
                const data = await response.json();
                console.log('Direct fetch result:', data);
                
                if (data.data?.createOutcome) {
                  alert('Direct fetch SUCCESS!');
                  await refetchOutcomes();
                } else if (data.errors) {
                  console.error('Direct fetch GraphQL errors:', data.errors);
                  alert('Direct fetch FAILED: ' + JSON.stringify(data.errors));
                } else {
                  console.error('Direct fetch unexpected response:', data);
                  alert('Direct fetch FAILED: Unexpected response structure');
                }
              } catch (error: any) {
                console.error('=== Direct fetch error ===');
                console.error('Error type:', typeof error);
                console.error('Error name:', error?.name);
                console.error('Error message:', error?.message);
                console.error('Full error:', error);
                alert('Direct fetch ERROR: ' + error?.message || error);
              }
            }}
            sx={{ ml: 1 }}
          >
            Test Direct
          </Button>
          <Button
            variant="outlined"
            onClick={async () => {
              console.log('=== Testing DIRECT backend (bypass proxy) ===');
              
              // Bypass Vite proxy and go directly to backend
              const directBackendBody = {
                "query": "mutation CreateOutcome($input: OutcomeInput!) { createOutcome(input: $input) { id name description } }",
                "variables": {
                  "input": {
                    "name": `Direct Backend ${Date.now()}`,
                    "description": "Testing direct backend",
                    "productId": product.id
                  }
                }
              };
              
              console.log('Direct backend request (port 4000):', {
                url: 'http://localhost:4000/graphql',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'admin'
                },
                body: JSON.stringify(directBackendBody, null, 2)
              });
              
              try {
                const response = await fetch('http://localhost:4000/graphql', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'admin'
                  },
                  body: JSON.stringify(directBackendBody)
                });
                
                console.log('Direct backend response status:', response.status);
                console.log('Direct backend response ok:', response.ok);
                
                if (!response.ok) {
                  const errorText = await response.text();
                  const errorHeaders = Object.fromEntries(response.headers.entries());
                  console.error('Direct backend error details:', {
                    status: response.status,
                    statusText: response.statusText,
                    headers: errorHeaders,
                    body: errorText
                  });
                  alert(`Direct backend FAILED: ${response.status} ${response.statusText} - ${errorText}`);
                  return;
                }
                
                const data = await response.json();
                console.log('Direct backend result:', data);
                
                if (data.data?.createOutcome) {
                  alert('Direct backend SUCCESS!');
                  await refetchOutcomes();
                } else if (data.errors) {
                  console.error('Direct backend GraphQL errors:', data.errors);
                  alert('Direct backend FAILED: ' + JSON.stringify(data.errors));
                } else {
                  console.error('Direct backend unexpected response:', data);
                  alert('Direct backend FAILED: Unexpected response structure');
                }
              } catch (error: any) {
                console.error('=== Direct backend error ===');
                console.error('Error type:', typeof error);
                console.error('Error name:', error?.name);
                console.error('Error message:', error?.message);
                console.error('Full error:', error);
                alert('Direct backend ERROR: ' + (error?.message || error));
              }
            }}
            sx={{ ml: 1 }}
          >
            Test Direct Backend
          </Button>
          <Button
            variant="outlined"
            onClick={async () => {
              console.log('=== Testing Apollo Client directly ===');
              console.log('Apollo Client config:', {
                uri: client.link,
                cache: client.cache
              });
              
              try {
                const result = await client.mutate({
                  mutation: CREATE_OUTCOME,
                  variables: {
                    input: {
                      name: `Apollo Test ${Date.now()}`,
                      description: 'Testing Apollo Client directly',
                      productId: product.id
                    }
                  },
                  errorPolicy: 'all'
                });
                console.log('Apollo Client direct result:', result);
                
                if (result.data?.createOutcome) {
                  alert('Apollo Client direct SUCCESS!');
                  await refetchOutcomes();
                } else if (result.errors) {
                  console.error('Apollo Client GraphQL errors:', result.errors);
                  alert('Apollo Client direct FAILED: ' + JSON.stringify(result.errors));
                } else {
                  alert('Apollo Client direct FAILED: Unknown error');
                }
              } catch (error: any) {
                console.error('=== Apollo Client direct error ===');
                console.error('Full error:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                console.error('Network error:', error.networkError);
                console.error('GraphQL errors:', error.graphQLErrors);
                if (error.networkError) {
                  console.error('Network error details:', {
                    statusCode: error.networkError.statusCode,
                    bodyText: error.networkError.bodyText,
                    response: error.networkError.response
                  });
                }
                alert('Apollo Client direct ERROR: ' + error.message);
              }
            }}
            sx={{ ml: 1 }}
          >
            Test Apollo
          </Button>
        </Box>

        {outcomesLoading ? (
          <Typography>Loading outcomes...</Typography>
        ) : outcomes.length > 0 ? (
          <List>
            {outcomes.map((outcome: any) => (
              <ListItem
                key={outcome.id}
                sx={{
                  border: '1px solid #e0e0e0',
                  borderRadius: 1,
                  mb: 1,
                  display: 'flex',
                  justifyContent: 'space-between'
                }}
              >
                <ListItemText
                  primary={outcome.name}
                  secondary={outcome.description}
                />
                <Box sx={{ display: 'flex', gap: 1 }}>
                  <IconButton
                    size="small"
                    onClick={() => handleEditOutcome(outcome)}
                  >
                    <Edit fontSize="small" />
                  </IconButton>
                  <IconButton
                    size="small"
                    color="error"
                    onClick={() => handleDeleteOutcome(outcome.id)}
                  >
                    <Delete fontSize="small" />
                  </IconButton>
                </Box>
              </ListItem>
            ))}
          </List>
        ) : (
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', py: 4 }}>
            No outcomes defined for this product. Click "Add Outcome" to create one.
          </Typography>
        )}
      </Paper>

      {/* Add Outcome Dialog */}
      <Dialog open={addOutcomeDialog} onClose={() => setAddOutcomeDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Add New Outcome</DialogTitle>
        <DialogContent>
          <TextField
            label="Outcome Name"
            value={newOutcome.name}
            onChange={(e) => setNewOutcome({ ...newOutcome, name: e.target.value })}
            fullWidth
            margin="normal"
            helperText="Outcome names must be unique within this product"
          />
          <TextField
            label="Description"
            value={newOutcome.description}
            onChange={(e) => setNewOutcome({ ...newOutcome, description: e.target.value })}
            fullWidth
            margin="normal"
            multiline
            rows={3}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setAddOutcomeDialog(false)}>Cancel</Button>
          <Button variant="contained" onClick={handleCreateOutcome}>
            Add Outcome
          </Button>
        </DialogActions>
      </Dialog>

      {/* Edit Outcome Dialog */}
      <Dialog open={editOutcomeDialog} onClose={() => setEditOutcomeDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Edit Outcome</DialogTitle>
        <DialogContent>
          <TextField
            label="Outcome Name"
            value={editingOutcome?.name || ''}
            onChange={(e) => setEditingOutcome({ ...editingOutcome, name: e.target.value })}
            fullWidth
            margin="normal"
          />
          <TextField
            label="Description"
            value={editingOutcome?.description || ''}
            onChange={(e) => setEditingOutcome({ ...editingOutcome, description: e.target.value })}
            fullWidth
            margin="normal"
            multiline
            rows={3}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditOutcomeDialog(false)}>Cancel</Button>
          <Button variant="contained" onClick={handleUpdateOutcome}>
            Update Outcome
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}
