import * as React from 'react';
import { useState } from 'react';
import { 
  Box, 
  CssBaseline, 
  Drawer, 
  Toolbar, 
  Typography, 
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Paper,
  Divider,
  LinearProgress,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Chip
} from '@mui/material';
import { 
  Inventory2 as ProductIcon,
  Lightbulb as SolutionIcon,
  People as CustomerIcon,
  Edit,
  Delete,
  Add,
  DragIndicator
} from '@mui/icons-material';
import Grid from '@mui/material/Grid';

// Lazy load components
const TaskDetail = React.lazy(()=>import('../components/TaskDetail').then(m=>({ default: m.TaskDetail })));
const AuditPanel = React.lazy(()=>import('../components/AuditPanel').then(m=>({ default: m.AuditPanel })));
const ChangeSetsPanel = React.lazy(()=>import('../components/ChangeSetsPanel').then(m=>({ default: m.ChangeSetsPanel })));
const TelemetryPanel = React.lazy(()=>import('../components/TelemetryPanel').then(m=>({ default: m.TelemetryPanel })));
const DependenciesPanel = React.lazy(()=>import('../components/DependenciesPanel').then(m=>({ default: m.DependenciesPanel })));

// Import direct components
import { AuthBar } from '../components/AuthBar';
import { LoginPage } from '../components/LoginPage';
import { ProductManagement } from '../components/ProductManagement';
import { SolutionManagement } from '../components/SolutionManagement';
import { ProductLicensesOutcomes } from '../components/ProductLicensesOutcomes';
import { CustomerManagement } from '../components/CustomerManagement';
import { TaskList } from '../components/TaskList';
import { gql, useQuery, useApolloClient } from '@apollo/client';

// GraphQL queries for fetching data with relationships
const PRODUCTS = gql`
  query Products {
    products {
      edges {
        node {
          id
          name
          description
          statusPercent
          licenses {
            id
            type
            name
            description
          }
          outcomes {
            id
            name
            description
          }
        }
      }
    }
  }
`;

const SOLUTIONS = gql`
  query Solutions {
    solutions {
      edges {
        node {
          id
          name
          description
        }
      }
    }
  }
`;

const CUSTOMERS = gql`
  query Customers {
    customers {
      id
      name
      description
    }
  }
`;

const TASKS_FOR_PRODUCT = gql`
  query TasksForProduct($productId: ID!) {
    tasks(productId: $productId, first: 100) {
      edges {
        node {
          id
          name
          description
          estMinutes
          weight
          sequenceNumber
          status {
            id
            code
            label
          }
          notes
          dependencies
          customAttrs
          telemetry
        }
      }
    }
  }
`;

const TASK_STATUSES = gql`
  query TaskStatuses {
    taskStatuses {
      id
      code
      label
    }
  }
`;

const drawerWidth = 240;

export function App() {
  // Apollo client for mutations
  const client = useApolloClient();

  // State for managing UI and selections
  const isAuthenticated = true; // Always authenticated for demo
  
  // State management
  const [selectedSection, setSelectedSection] = useState<'products' | 'solutions' | 'customers'>('products');
  const [selectedProduct, setSelectedProduct] = useState('');
  const [selectedSolution, setSelectedSolution] = useState('');
  const [selectedCustomer, setSelectedCustomer] = useState('');
  const [selectedCustomerProduct, setSelectedCustomerProduct] = useState('');
  const [selectedCustomerSolution, setSelectedCustomerSolution] = useState('');
  const [selectedTask, setSelectedTask] = useState('');
  const [editingTask, setEditingTask] = useState<any>(null);
  
  // New state for task management
  const [editProductDialog, setEditProductDialog] = useState(false);
  const [editTaskDialog, setEditTaskDialog] = useState(false);
  const [addProductDialog, setAddProductDialog] = useState(false);
  const [addTaskDialog, setAddTaskDialog] = useState(false);
  const [deleteConfirmDialog, setDeleteConfirmDialog] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState<{type: 'product' | 'task', id: string, name: string} | null>(null);
  const [editingProduct, setEditingProduct] = useState<any>(null);
  const [productTasks, setProductTasks] = useState<any[]>([]);
  const [newProduct, setNewProduct] = useState({name: '', description: ''});
  const [newTask, setNewTask] = useState({name: '', description: '', estMinutes: 60, weight: 10, notes: ''});
  
  // CSV and confirmation dialog states
  const [confirmDeleteProduct, setConfirmDeleteProduct] = useState<string | null>(null);
  const [confirmDeleteTask, setConfirmDeleteTask] = useState<string | null>(null);
  const [csvImportDialog, setCsvImportDialog] = useState(false);
  const [csvImportType, setCsvImportType] = useState<'products' | 'tasks'>('products');
  const [csvFile, setCsvFile] = useState<File | null>(null);
  
  // Drag and drop states
  const [draggedTask, setDraggedTask] = useState<string | null>(null);
  const [dragOverTask, setDragOverTask] = useState<string | null>(null);

  // GraphQL queries - remove authentication checks
  const { data: productsData, loading: productsLoading, error: productsError, refetch: refetchProducts } = useQuery(PRODUCTS, {
    errorPolicy: 'all'
  });
  
  const { data: solutionsData, loading: solutionsLoading, error: solutionsError } = useQuery(SOLUTIONS, {
    errorPolicy: 'all'
  });
  
  const { data: customersData, loading: customersLoading, error: customersError } = useQuery(CUSTOMERS, {
    errorPolicy: 'all'
  });

  const { data: tasksData, loading: tasksLoading, error: tasksError, refetch: refetchTasks } = useQuery(TASKS_FOR_PRODUCT, {
    variables: { productId: selectedProduct },
    skip: !selectedProduct,
    errorPolicy: 'all'
  });

  const { data: taskStatusesData } = useQuery(TASK_STATUSES, {
    errorPolicy: 'all'
  });

  // Extract data from GraphQL responses
  const products = productsData?.products?.edges?.map((edge: any) => edge.node) || [];
  const solutions = solutionsData?.solutions?.edges?.map((edge: any) => edge.node) || [];
  const customers = customersData?.customers || [];
  const tasks = (tasksData?.tasks?.edges?.map((edge: any) => edge.node) || [])
    .sort((a: any, b: any) => (a.sequenceNumber || 0) - (b.sequenceNumber || 0));
  const taskStatuses = taskStatusesData?.taskStatuses || [];
  
  // Find selected product data including licenses and outcomes
  const selectedProductData = products.find((p: any) => p.id === selectedProduct);

  // Auto-select first product if none selected
  React.useEffect(() => {
    if (products.length > 0 && !selectedProduct) {
      setSelectedProduct(products[0].id);
    }
  }, [products, selectedProduct]);

  // Debug logging
  console.log('Sample Data Debug:', { 
    productsCount: products.length, 
    solutionsCount: solutions.length, 
    customersCount: customers.length,
    tasksCount: tasks.length,
    selectedProduct,
    tasksData,
    tasksLoading,
    tasksError: tasksError?.message,
    products: products.slice(0, 2),
    loading: {
      products: !productsData,
      solutions: !solutionsData,
      customers: !customersData,
      tasks: !tasksData
    }
  });

  // Get current entities
  const currentProduct = products.find((p: any) => p.id === selectedProduct);
  const currentSolution = solutions.find((s: any) => s.id === selectedSolution);
  const currentCustomer = customers.find((c: any) => c.id === selectedCustomer);

  // Get current tasks based on selection - simplified for demo
  const getCurrentTasks = () => {
    // For now, return empty array since complex relationships are simplified
    // Tasks will be shown through the ProductsPanel and TasksPanel components
    return [];
  };

  const currentTasks = getCurrentTasks();
  const currentTask = null; // Simplified for demo

  // Navigation handlers
  const handleSectionChange = (section: 'products' | 'solutions' | 'customers') => {
    setSelectedSection(section);
    setSelectedProduct('');
    setSelectedSolution('');
    setSelectedCustomer('');
    setSelectedCustomerProduct('');
    setSelectedCustomerSolution('');
    setSelectedTask('');
    setEditingTask(null);
  };

  const handleProductChange = (productId: string) => {
    setSelectedProduct(productId);
    setSelectedTask('');
    setEditingTask(null);
  };

  const handleSolutionChange = (solutionId: string) => {
    setSelectedSolution(solutionId);
    setSelectedTask('');
    setEditingTask(null);
  };

  const handleCustomerChange = (customerId: string) => {
    setSelectedCustomer(customerId);
    setSelectedTask('');
    setSelectedCustomerProduct('');
    setSelectedCustomerSolution('');
    setEditingTask(null);
  };

  // New handlers for task management
  const handleTaskEdit = (task: any) => {
    setEditingTask(task);
    setEditTaskDialog(true);
  };

  const handleProductEdit = () => {
    const product = products.find((p: any) => p.id === selectedProduct);
    setEditingProduct(product);
    setEditProductDialog(true);
  };

  const handleTaskDoubleClick = (task: any) => {
    handleTaskEdit(task);
  };

  // CSV and CRUD handlers
  const handleExportProducts = async () => {
    try {
      const csvData = products.map((p: any) => ({
        id: p.id,
        name: p.name,
        description: p.description || ''
      }));
      const csvString = 'id,name,description\n' + csvData.map((row: any) => 
        `${row.id},"${row.name}","${row.description}"`
      ).join('\n');
      
      const blob = new Blob([csvString], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('hidden', '');
      a.setAttribute('href', url);
      a.setAttribute('download', 'products.csv');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } catch (error) {
      console.error('Export failed:', error);
    }
  };

  const handleImportProducts = (event: any) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const csvText = e.target?.result as string;
        // TODO: Parse CSV and call GraphQL mutation to import products
        console.log('Products CSV import:', csvText);
        alert('Product import functionality will be implemented with GraphQL mutations');
      } catch (error) {
        console.error('Import failed:', error);
        alert('Failed to import products');
      }
    };
    reader.readAsText(file);
  };

  const handleDownloadProductSample = () => {
    const sampleCsv = 'id,name,description\np-sample,"Sample Product","A sample product for demonstration"';
    const blob = new Blob([sampleCsv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.setAttribute('hidden', '');
    a.setAttribute('href', url);
    a.setAttribute('download', 'product-sample.csv');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  const handleExportTasks = async () => {
    if (!selectedProduct) return;
    
    try {
      const csvData = tasks.map((t: any) => ({
        id: t.id,
        name: t.name,
        description: t.description || '',
        estMinutes: t.estMinutes,
        weight: t.weight,
        statusId: t.status?.id || 1,
        notes: t.notes || '',
        dependencies: Array.isArray(t.dependencies) ? t.dependencies.join(';') : ''
      }));
      
      const csvString = 'id,name,description,estMinutes,weight,statusId,notes,dependencies\n' + 
        csvData.map((row: any) => 
          `${row.id},"${row.name}","${row.description}",${row.estMinutes},${row.weight},${row.statusId},"${row.notes}","${row.dependencies}"`
        ).join('\n');
      
      const blob = new Blob([csvString], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('hidden', '');
      a.setAttribute('href', url);
      a.setAttribute('download', `tasks-${selectedProduct}.csv`);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } catch (error) {
      console.error('Export failed:', error);
    }
  };

  const handleImportTasks = (event: any) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const csvText = e.target?.result as string;
        // TODO: Parse CSV and call GraphQL mutation to import tasks
        console.log('Tasks CSV import:', csvText);
        alert('Task import functionality will be implemented with GraphQL mutations');
      } catch (error) {
        console.error('Import failed:', error);
        alert('Failed to import tasks');
      }
    };
    reader.readAsText(file);
  };

  const handleDownloadTaskSample = () => {
    const sampleCsv = 'id,name,description,estMinutes,weight,statusId,notes,dependencies\nt-sample,"Sample Task","A sample task for demonstration",120,15,1,"This is a sample note","t-dep1;t-dep2"';
    const blob = new Blob([sampleCsv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.setAttribute('hidden', '');
    a.setAttribute('href', url);
    a.setAttribute('download', 'task-sample.csv');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  const handleDeleteConfirm = (type: 'product' | 'task', id: string, name: string) => {
    setDeleteTarget({type, id, name});
    setDeleteConfirmDialog(true);
  };

  const handleDeleteExecute = async () => {
    if (!deleteTarget) return;
    
    try {
      if (deleteTarget.type === 'product') {
        // TODO: Call GraphQL mutation to delete product
        console.log('Delete product:', deleteTarget.id);
        alert('Product deletion will be implemented with GraphQL mutations');
      } else {
        // TODO: Call GraphQL mutation to delete task
        console.log('Delete task:', deleteTarget.id);
        alert('Task deletion will be implemented with GraphQL mutations');
      }
      setDeleteConfirmDialog(false);
      setDeleteTarget(null);
    } catch (error) {
      console.error('Delete failed:', error);
      alert('Failed to delete item');
    }
  };

  // Auto-adjust task weights to total 100%
  const autoAdjustWeights = (newTasks: any[]) => {
    const totalWeight = newTasks.reduce((sum, task) => sum + (task.weight || 0), 0);
    if (totalWeight === 0) return newTasks;
    
    const factor = 100 / totalWeight;
    return newTasks.map(task => ({
      ...task,
      weight: Math.round((task.weight || 0) * factor)
    }));
  };

  const handleAddProduct = async () => {
    if (!newProduct.name.trim()) return;
    
    try {
      const result = await client.mutate({
        mutation: gql`
          mutation CreateProduct($input: ProductInput!) {
            createProduct(input: $input) {
              id
              name
              description
              statusPercent
            }
          }
        `,
        variables: {
          input: {
            name: newProduct.name,
            description: newProduct.description,
            customAttrs: {}
          }
        },
        refetchQueries: ['Products'],
        awaitRefetchQueries: true // Ensure refetch completes before continuing
      });
      
      console.log('Product created successfully:', result.data.createProduct);
      setNewProduct({ name: '', description: '' });
      setAddProductDialog(false);
      
      // Force a refetch of the products data
      await refetchProducts();
    } catch (error: any) {
      console.error('Error adding product:', error);
      alert('Failed to add product: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleAddTask = async () => {
    if (!newTask.name.trim() || !selectedProduct) return;
    
    try {
      // Auto-adjust weights to ensure total is 100%
      const currentTotalWeight = tasks.reduce((sum: number, task: any) => sum + task.weight, 0);
      const remainingWeight = 100 - currentTotalWeight;
      const adjustedWeight = Math.min(Math.max(newTask.weight, 1), remainingWeight);
      
      // Get a default status ID
      const taskStatusesResult = await client.query({
        query: gql`
          query GetTaskStatuses {
            taskStatuses {
              id
              code
              label
            }
          }
        `
      });
      
      const defaultStatus = taskStatusesResult.data.taskStatuses.find((s: any) => s.code === 'TODO') || 
                           taskStatusesResult.data.taskStatuses[0];

      await client.mutate({
        mutation: gql`
          mutation CreateTask($input: TaskInput!) {
            createTask(input: $input) {
              id
              name
              description
              estMinutes
              weight
              status {
                id
                code
                label
              }
            }
          }
        `,
        variables: {
          input: {
            productId: selectedProduct,
            name: newTask.name,
            description: newTask.description,
            estMinutes: newTask.estMinutes,
            statusId: defaultStatus.id,
            weight: adjustedWeight,
            notes: '',
            dependencies: [],
            telemetry: {},
            customAttrs: {}
          }
        },
        refetchQueries: ['TasksForProduct'],
        awaitRefetchQueries: true
      });
      
      console.log('Task created successfully');
      setNewTask({ name: '', description: '', estMinutes: 60, weight: 10, notes: '' });
      setAddTaskDialog(false);
    } catch (error: any) {
      console.error('Error adding task:', error);
      alert('Failed to add task: ' + (error?.message || 'Unknown error'));
    }
  };

  // Drag and drop handlers
  const handleDragStart = (e: React.DragEvent, taskId: string) => {
    console.log('ðŸš€ Drag started for task:', taskId);
    console.log('ðŸš€ Event type:', e.type);
    console.log('ðŸš€ Current target:', e.currentTarget);
    console.log('ðŸš€ DataTransfer available:', !!e.dataTransfer);
    
    setDraggedTask(taskId);
    setDragOverTask(null);
    
    // Set up data transfer
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', taskId);
    
    // Create a simple drag image
    const dragImage = document.createElement('div');
    dragImage.textContent = `Task: ${taskId}`;
    dragImage.style.position = 'absolute';
    dragImage.style.top = '-1000px';
    dragImage.style.backgroundColor = '#1976d2';
    dragImage.style.color = 'white';
    dragImage.style.padding = '8px';
    dragImage.style.borderRadius = '4px';
    document.body.appendChild(dragImage);
    e.dataTransfer.setDragImage(dragImage, 0, 0);
    
    // Clean up drag image after a delay
    setTimeout(() => {
      document.body.removeChild(dragImage);
    }, 0);
  };

  const handleDragOver = (e: React.DragEvent, taskId: string) => {
    console.log('ðŸŽ¯ Drag over task:', taskId, 'dragged:', draggedTask);
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    if (draggedTask && taskId !== draggedTask) {
      console.log('ðŸŽ¯ Setting drag over task:', taskId);
      setDragOverTask(taskId);
    }
  };

  const handleDragEnter = (e: React.DragEvent, taskId: string) => {
    e.preventDefault();
    e.stopPropagation();
    if (draggedTask && taskId !== draggedTask) {
      setDragOverTask(taskId);
    }
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    // Only clear dragOverTask if we're really leaving the drop zone
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    const x = e.clientX;
    const y = e.clientY;
    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
      setDragOverTask(null);
    }
  };

  const handleDragEnd = () => {
    console.log('ðŸŸ¢ Drag ended');
    setDraggedTask(null);
    setDragOverTask(null);
  };

  const handleDrop = async (e: React.DragEvent, targetTaskId: string) => {
    console.log('ðŸ’« Drop event:', { draggedTask, targetTaskId });
    e.preventDefault();
    e.stopPropagation();
    
    if (!draggedTask || draggedTask === targetTaskId) {
      console.log('ðŸ’« Invalid drop - same task or no dragged task');
      setDraggedTask(null);
      setDragOverTask(null);
      return;
    }
    
    const taskIds = tasks.map((t: any) => t.id);
    const draggedIndex = taskIds.indexOf(draggedTask);
    const targetIndex = taskIds.indexOf(targetTaskId);
    
    console.log('ðŸ’« Drag indices:', { draggedIndex, targetIndex, taskIds });
    
    if (draggedIndex === -1 || targetIndex === -1) {
      console.log('ðŸ’« Invalid indices');
      setDraggedTask(null);
      setDragOverTask(null);
      return;
    }
    
    // Reorder array
    const newOrder = [...taskIds];
    newOrder.splice(draggedIndex, 1);
    newOrder.splice(targetIndex, 0, draggedTask);
    
    console.log('ðŸ’« Reordering tasks:', { from: draggedIndex, to: targetIndex, newOrder });
    
    try {
      await client.mutate({
        mutation: gql`
          mutation ReorderTasks($productId: ID!, $order: [ID!]!) {
            reorderTasks(productId: $productId, order: $order)
          }
        `,
        variables: { 
          productId: selectedProduct, 
          order: newOrder 
        },
        refetchQueries: ['TasksForProduct']
      });
      
      console.log('ðŸ’« Reorder completed successfully');
    } catch (error) {
      console.error('ðŸ’« Reorder failed:', error);
      alert('Failed to reorder tasks: ' + (error as Error).message);
    }
    
    setDraggedTask(null);
    setDragOverTask(null);
  };

  const handleProductCSVExport = async () => {
    try {
      const result = await client.mutate({
        mutation: gql`
          mutation ExportProductsCsv {
            exportProductsCsv
          }
        `
      });
      
      const csvData = result.data.exportProductsCsv;
      const blob = new Blob([csvData], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'products.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    } catch (error: any) {
      console.error('Error exporting products:', error);
      alert('Failed to export products: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleTaskCSVExport = async () => {
    if (!selectedProduct) return;
    
    try {
      const result = await client.mutate({
        mutation: gql`
          mutation ExportTasksCsv($productId: ID!) {
            exportTasksCsv(productId: $productId)
          }
        `,
        variables: {
          productId: selectedProduct
        }
      });
      
      const csvData = result.data.exportTasksCsv;
      const blob = new Blob([csvData], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tasks-${selectedProduct}.csv`;
      a.click();
      window.URL.revokeObjectURL(url);
    } catch (error: any) {
      console.error('Error exporting tasks:', error);
      alert('Failed to export tasks: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleCsvImport = async () => {
    if (!csvFile) return;
    
    try {
      const csvText = await csvFile.text();
      
      if (csvImportType === 'products') {
        await client.mutate({
          mutation: gql`
            mutation ImportProductsCsv($csv: String!) {
              importProductsCsv(csv: $csv)
            }
          `,
          variables: {
            csv: csvText
          },
          refetchQueries: ['Products']
        });
      } else if (csvImportType === 'tasks' && selectedProduct) {
        await client.mutate({
          mutation: gql`
            mutation ImportTasksCsv($productId: ID!, $csv: String!) {
              importTasksCsv(productId: $productId, csv: $csv)
            }
          `,
          variables: {
            productId: selectedProduct,
            csv: csvText
          },
          refetchQueries: ['TasksForProduct']
        });
      }
      
      setCsvImportDialog(false);
      setCsvFile(null);
    } catch (error: any) {
      console.error('Error importing CSV:', error);
      alert('Failed to import CSV: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleDownloadSample = (type: 'products' | 'tasks') => {
    let csvContent = '';
    
    if (type === 'products') {
      csvContent = 'name,description\n"Sample Product","A sample product description"\n"Another Product","Another product description"';
    } else {
      csvContent = 'name,description,estMinutes,weight,notes\n"Sample Task","A sample task description",60,25,"Task notes"\n"Another Task","Another task description",120,35,"More notes"';
    }
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `sample-${type}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const handleDeleteProduct = async () => {
    if (!confirmDeleteProduct) return;
    
    try {
      await client.mutate({
        mutation: gql`
          mutation DeleteProduct($id: ID!) {
            deleteProduct(id: $id)
          }
        `,
        variables: {
          id: confirmDeleteProduct
        },
        refetchQueries: ['Products']
      });
      
      setConfirmDeleteProduct(null);
      // Reset selected product if it was deleted
      if (selectedProduct === confirmDeleteProduct) {
        setSelectedProduct('');
      }
    } catch (error: any) {
      console.error('Error deleting product:', error);
      alert('Failed to delete product: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleDeleteTask = async () => {
    if (!confirmDeleteTask) return;
    
    try {
      await client.mutate({
        mutation: gql`
          mutation QueueTaskSoftDelete($id: ID!) {
            queueTaskSoftDelete(id: $id)
          }
        `,
        variables: {
          id: confirmDeleteTask
        },
        refetchQueries: ['TasksForProduct']
      });
      
      setConfirmDeleteTask(null);
    } catch (error: any) {
      console.error('Error deleting task:', error);
      alert('Failed to delete task: ' + (error?.message || 'Unknown error'));
    }
  };

  const handleCustomerProductChange = (productId: string) => {
    setSelectedCustomerProduct(productId);
    setSelectedCustomerSolution('');
    setSelectedTask('');
    setEditingTask(null);
  };

  const handleCustomerSolutionChange = (solutionId: string) => {
    setSelectedCustomerSolution(solutionId);
    setSelectedCustomerProduct('');
    setSelectedTask('');
    setEditingTask(null);
  };

  const handleTaskSelect = (taskId: string) => {
    setSelectedTask(taskId);
  };

  // Helper functions
  const getStatusColor = (status: string) => {
    switch (status?.toLowerCase()) {
      case 'active': return 'success';
      case 'pending': return 'warning';
      case 'completed': return 'info';
      case 'paused': return 'default';
      default: return 'default';
    }
  };

  const getProgressLabel = () => {
    if (selectedProduct) {
      const product = products.find((p: any) => p.id === selectedProduct);
      return `Product Progress: ${product?.name || 'Unknown Product'}`;
    }
    if (selectedSolution) {
      const solution = solutions.find((s: any) => s.id === selectedSolution);
      return `Solution Progress: ${solution?.name || 'Unknown Solution'}`;
    }
    if (selectedCustomerProduct) {
      const customer = customers.find((c: any) => c.id === selectedCustomer);
      const product = customer?.products?.edges?.find((edge: any) => edge.node.id === selectedCustomerProduct)?.node;
      return `Customer Product Progress: ${product?.name || 'Unknown Product'}`;
    }
    if (selectedCustomerSolution) {
      const customer = customers.find((c: any) => c.id === selectedCustomer);
      const solution = customer?.solutions?.edges?.find((edge: any) => edge.node.id === selectedCustomerSolution)?.node;
      return `Customer Solution Journey: ${solution?.name || 'Unknown Solution'}`;
    }
    return 'Progress';
  };

  const calculateProgress = (tasks: any[]) => {
    if (!tasks.length) return 0;
    const completed = tasks.filter(t => t.completedAt || t.status?.toLowerCase() === 'completed').length;
    return (completed / tasks.length) * 100;
  };

  return (
    <Box sx={{ display: 'flex' }}>
      <CssBaseline />
      <AuthBar />
      <Toolbar />
      
      {/* Left Sidebar */}
      <Drawer 
        variant="permanent"
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
          },
        }}
      >
        <Toolbar />
        <Box sx={{ overflow: 'auto' }}>
          <List>
            <ListItemButton 
              selected={selectedSection === 'products'}
              onClick={() => handleSectionChange('products')}
            >
              <ListItemIcon>
                <ProductIcon />
              </ListItemIcon>
              <ListItemText primary="Products" />
            </ListItemButton>
            
            <ListItemButton 
              selected={selectedSection === 'solutions'}
              onClick={() => handleSectionChange('solutions')}
            >
              <ListItemIcon>
                <SolutionIcon />
              </ListItemIcon>
              <ListItemText primary="Solutions" />
            </ListItemButton>
            
            <ListItemButton 
              selected={selectedSection === 'customers'}
              onClick={() => handleSectionChange('customers')}
            >
              <ListItemIcon>
                <CustomerIcon />
              </ListItemIcon>
              <ListItemText primary="Customers" />
            </ListItemButton>
          </List>
          <Divider />
        </Box>
      </Drawer>

      {/* Main Content */}
      <Box component="main" sx={{ flexGrow: 1, p: 3, mt: 8 }}>
        {selectedSection === 'products' && (
          <Box>
            <Typography variant="h4" gutterBottom>
              Product Management
            </Typography>
            
            {/* Product Actions */}
            <Paper sx={{ p: 2, mb: 2 }}>
              <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
                <Button
                  variant="contained"
                  startIcon={<Add />}
                  onClick={() => setAddProductDialog(true)}
                >
                  Add Product
                </Button>
                {selectedProduct && (
                  <>
                    <Button
                      variant="outlined"
                      startIcon={<Edit />}
                      onClick={handleProductEdit}
                    >
                      Edit Product
                    </Button>
                    <Button
                      variant="outlined"
                      color="error"
                      startIcon={<Delete />}
                      onClick={() => setConfirmDeleteProduct(selectedProduct)}
                    >
                      Delete Product
                    </Button>
                  </>
                )}
                <Button
                  variant="outlined"
                  onClick={handleProductCSVExport}
                >
                  Export Products CSV
                </Button>
                <Button
                  variant="outlined"
                  component="label"
                >
                  Import Products CSV
                  <input
                    type="file"
                    hidden
                    accept=".csv"
                    onChange={(e) => {
                      setCsvFile(e.target.files?.[0] || null);
                      setCsvImportType('products');
                      setCsvImportDialog(true);
                    }}
                  />
                </Button>
                <Button
                  variant="outlined"
                  onClick={() => handleDownloadSample('products')}
                >
                  Download Sample CSV
                </Button>
              </Box>
              
              {/* Products Dropdown */}
              <FormControl fullWidth sx={{ mb: 2 }}>
                <InputLabel>Select Product</InputLabel>
                <Select
                  value={selectedProduct}
                  onChange={(e) => handleProductChange(e.target.value)}
                  label="Select Product"
                >
                  {products.map((product: any) => (
                    <MenuItem key={product.id} value={product.id}>
                      {product.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Paper>

            {/* Tasks Section */}
            {selectedProduct && (
              <Paper sx={{ p: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6">
                    Tasks for {products.find((p: any) => p.id === selectedProduct)?.name}
                  </Typography>
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <Button
                      variant="contained"
                      startIcon={<Add />}
                      onClick={() => setAddTaskDialog(true)}
                    >
                      Add Task
                    </Button>
                    <Button
                      variant="outlined"
                      size="small"
                      onClick={handleTaskCSVExport}
                    >
                      Export CSV
                    </Button>
                    <Button
                      variant="outlined"
                      size="small"
                      component="label"
                    >
                      Import CSV
                      <input
                        type="file"
                        hidden
                        accept=".csv"
                        onChange={(e) => {
                          setCsvFile(e.target.files?.[0] || null);
                          setCsvImportType('tasks');
                          setCsvImportDialog(true);
                        }}
                      />
                    </Button>
                    <Button
                      variant="outlined"
                      size="small"
                      onClick={() => handleDownloadSample('tasks')}
                    >
                      Sample CSV
                    </Button>
                    <Button
                      variant="outlined"
                      size="small"
                      color="secondary"
                      onClick={async () => {
                        console.log('ðŸ”§ Testing reorder: Moving first task to last position');
                        if (tasks.length >= 2) {
                          const taskIds = tasks.map((t: any) => t.id);
                          const reorderedIds = [...taskIds.slice(1), taskIds[0]]; // Move first to last
                          try {
                            await client.mutate({
                              mutation: gql`
                                mutation ReorderTasks($productId: ID!, $order: [ID!]!) {
                                  reorderTasks(productId: $productId, order: $order)
                                }
                              `,
                              variables: { productId: selectedProduct, order: reorderedIds },
                              refetchQueries: ['TasksForProduct']
                            });
                            console.log('ðŸ”§ Test reorder completed');
                          } catch (error) {
                            console.error('ðŸ”§ Test reorder failed:', error);
                          }
                        }
                      }}
                    >
                      Test Reorder
                    </Button>
                  </Box>
                </Box>
                
                <Box sx={{ mb: 2, p: 1, backgroundColor: 'info.light', borderRadius: 1 }}>
                  <Typography variant="body2" color="info.contrastText" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <DragIndicator fontSize="small" />
                    Drag and drop tasks to reorder them. Sequence numbers will update automatically.
                  </Typography>
                </Box>
                
                {tasksLoading ? (
                  <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                    <LinearProgress sx={{ width: '100%' }} />
                    <Typography variant="body2" color="text.secondary" sx={{ ml: 2 }}>
                      Loading tasks...
                    </Typography>
                  </Box>
                ) : tasksError ? (
                  <Typography variant="body2" color="error" sx={{ textAlign: 'center', py: 4 }}>
                    Error loading tasks: {tasksError.message}
                  </Typography>
                ) : tasks.length > 0 ? (
                  <List>
                    {tasks.map((task: any, index: number) => (
                      <ListItemButton
                        key={task.id}
                        draggable={true}
                        onDragStart={(e) => handleDragStart(e, task.id)}
                        onDragOver={(e) => handleDragOver(e, task.id)}
                        onDragEnter={(e) => handleDragEnter(e, task.id)}
                        onDragLeave={handleDragLeave}
                        onDrop={(e) => handleDrop(e, task.id)}
                        onDragEnd={handleDragEnd}
                        onDoubleClick={(e) => {
                          // Only handle double click if not dragging
                          if (!draggedTask) {
                            handleTaskDoubleClick(task);
                          }
                        }}
                        onMouseDown={(e) => {
                          console.log('ðŸ–±ï¸ Mouse down on task:', task.id);
                          // Only prevent default for text selection, not for drag initiation
                          if (e.detail > 1) { // Multi-click
                            e.preventDefault();
                          }
                        }}
                        onMouseUp={(e) => {
                          console.log('ðŸ–±ï¸ Mouse up on task:', task.id);
                        }}
                        onClick={(e) => {
                          console.log('ðŸ–±ï¸ Click on task:', task.id, 'draggedTask:', draggedTask);
                          // Prevent click if we're in the middle of a drag operation
                          if (draggedTask) {
                            e.preventDefault();
                            e.stopPropagation();
                          }
                        }}
                        sx={{ 
                          border: dragOverTask === task.id ? '2px solid #1976d2' : '1px solid #e0e0e0',
                          borderRadius: 1,
                          mb: 1,
                          opacity: draggedTask === task.id ? 0.5 : 1,
                          backgroundColor: dragOverTask === task.id ? 'action.hover' : 'inherit',
                          cursor: 'grab',
                          userSelect: 'none',
                          WebkitUserSelect: 'none',
                          MozUserSelect: 'none',
                          msUserSelect: 'none',
                          transition: 'all 0.2s ease-in-out',
                          '&:hover': { 
                            backgroundColor: draggedTask && draggedTask !== task.id ? 'action.selected' : '#f5f5f5',
                            cursor: 'grab',
                            transform: 'scale(1.01)'
                          },
                          '&:active': { 
                            cursor: 'grabbing',
                            transform: 'scale(0.99)'
                          },
                          // Ensure draggable styling
                          '&[draggable="true"]': {
                            cursor: 'grab',
                            '&:hover': {
                              cursor: 'grab'
                            },
                            '&:active': {
                              cursor: 'grabbing'
                            }
                          }
                        }}
                      >
                        <ListItemIcon sx={{ minWidth: '32px' }}>
                          <DragIndicator 
                            sx={{ 
                              color: 'text.secondary',
                              cursor: 'grab',
                              '&:hover': {
                                color: 'primary.main'
                              }
                            }}
                          />
                        </ListItemIcon>
                        <ListItemText
                          primary={
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Chip 
                                size="small" 
                                label={`#${task.sequenceNumber || '?'}`}
                                color="secondary"
                                variant="filled"
                                sx={{ 
                                  fontWeight: 'bold',
                                  minWidth: '40px'
                                }}
                              />
                              <Box>
                                <Typography variant="subtitle1" component="div">
                                  {task.name}
                                </Typography>
                                {task.notes && (
                                  <Typography variant="body2" color="text.secondary" sx={{ fontStyle: 'italic', mt: 0.5 }}>
                                    "{task.notes}"
                                  </Typography>
                                )}
                              </Box>
                            </Box>
                          }
                          secondary={
                            <Box sx={{ mt: 1 }}>
                              <Typography variant="body2" color="text.secondary">
                                Weight: {task.weight}% | Status: {task.status?.label || 'Unknown'} | Est: {task.estMinutes}min
                              </Typography>
                              {task.dependencies && task.dependencies.length > 0 && (
                                <Typography variant="caption" color="warning.main">
                                  Dependencies: {task.dependencies.join(', ')}
                                </Typography>
                              )}
                              {task.customAttrs && (
                                <Typography variant="caption" display="block" color="info.main">
                                  Priority: {task.customAttrs.priority} | Team: {task.customAttrs.team} | Complexity: {task.customAttrs.complexity}
                                </Typography>
                              )}
                            </Box>
                          }
                        />
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <IconButton
                            size="small"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleTaskEdit(task);
                            }}
                          >
                            <Edit fontSize="small" />
                          </IconButton>
                          <IconButton
                            size="small"
                            color="error"
                            onClick={(e) => {
                              e.stopPropagation();
                              setConfirmDeleteTask(task.id);
                            }}
                          >
                            <Delete fontSize="small" />
                          </IconButton>
                        </Box>
                      </ListItemButton>
                    ))}
                  </List>
                ) : (
                  <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', py: 4 }}>
                    No tasks found for this product. Click "Add Task" to create one.
                  </Typography>
                )}
              </Paper>
            )}
            
            {/* Licenses and Outcomes Section */}
            {selectedProduct && (
              <ProductLicensesOutcomes
                productId={selectedProduct}
                productLicenses={selectedProductData?.licenses || []}
                productOutcomes={selectedProductData?.outcomes || []}
                onRefetch={() => refetchProducts()}
              />
            )}
          </Box>
        )}

        {/* Task Edit Dialog */}

          {/* Additional Panels */}
          {(selectedProduct || selectedSolution || selectedCustomer) && !selectedTask && (
            <Grid size={{ xs: 12 }}>
              <Paper sx={{ p: 2 }}>
                <Typography variant="h6" gutterBottom>
                  Additional Information
                </Typography>
                <Grid container spacing={2}>
                  <Grid size={{ xs: 12, md: 6 }}>
                    <Typography variant="subtitle2" gutterBottom>Audit Trail</Typography>
                    <React.Suspense fallback={<div>Loading audit...</div>}>
                      <AuditPanel />
                    </React.Suspense>
                  </Grid>
                  <Grid size={{ xs: 12, md: 6 }}>
                    <Typography variant="subtitle2" gutterBottom>Change Sets</Typography>
                    <React.Suspense fallback={<div>Loading changes...</div>}>
                      <ChangeSetsPanel />
                    </React.Suspense>
                  </Grid>
                </Grid>
              </Paper>
            </Grid>
          )}

        {/* Task Edit Dialog */}
        <Dialog
          open={editTaskDialog}
          onClose={() => setEditTaskDialog(false)}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>Edit Task</DialogTitle>
          <DialogContent>
            {editingTask && (
              <Box sx={{ pt: 1 }}>
                <TextField
                  fullWidth
                  label="Task Name"
                  value={editingTask.name}
                  onChange={(e) => setEditingTask({...editingTask, name: e.target.value})}
                  margin="normal"
                />
                <TextField
                  fullWidth
                  label="Description"
                  value={editingTask.description || ''}
                  onChange={(e) => setEditingTask({...editingTask, description: e.target.value})}
                  margin="normal"
                  multiline
                  rows={3}
                />
                <TextField
                  fullWidth
                  label="Notes"
                  value={editingTask.notes || ''}
                  onChange={(e) => setEditingTask({...editingTask, notes: e.target.value})}
                  margin="normal"
                  multiline
                  rows={2}
                  helperText="Internal notes and comments about this task"
                />
                <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
                  <TextField
                    label="Weight (%)"
                    type="number"
                    value={editingTask.weight}
                    onChange={(e) => setEditingTask({...editingTask, weight: parseInt(e.target.value)})}
                    margin="normal"
                    sx={{ width: '50%' }}
                  />
                  <TextField
                    label="Estimated Minutes"
                    type="number"
                    value={editingTask.estMinutes}
                    onChange={(e) => setEditingTask({...editingTask, estMinutes: parseInt(e.target.value)})}
                    margin="normal"
                    sx={{ width: '50%' }}
                  />
                </Box>
                
                {/* Custom Attributes Section */}
                <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>Custom Attributes</Typography>
                <Box sx={{ display: 'flex', gap: 2 }}>
                  <TextField
                    label="Priority"
                    value={editingTask.customAttrs?.priority || ''}
                    onChange={(e) => setEditingTask({
                      ...editingTask, 
                      customAttrs: {...(editingTask.customAttrs || {}), priority: e.target.value}
                    })}
                    margin="normal"
                    sx={{ width: '33%' }}
                  />
                  <TextField
                    label="Team"
                    value={editingTask.customAttrs?.team || ''}
                    onChange={(e) => setEditingTask({
                      ...editingTask, 
                      customAttrs: {...(editingTask.customAttrs || {}), team: e.target.value}
                    })}
                    margin="normal"
                    sx={{ width: '33%' }}
                  />
                  <TextField
                    label="Complexity"
                    value={editingTask.customAttrs?.complexity || ''}
                    onChange={(e) => setEditingTask({
                      ...editingTask, 
                      customAttrs: {...(editingTask.customAttrs || {}), complexity: e.target.value}
                    })}
                    margin="normal"
                    sx={{ width: '33%' }}
                  />
                </Box>
                
                {/* Dependencies Section */}
                <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>Dependencies</Typography>
                <TextField
                  fullWidth
                  label="Task Dependencies (comma-separated task IDs)"
                  value={editingTask.dependencies?.join(', ') || ''}
                  onChange={(e) => setEditingTask({
                    ...editingTask, 
                    dependencies: e.target.value.split(',').map(id => id.trim()).filter(id => id)
                  })}
                  margin="normal"
                  helperText="Enter task IDs that this task depends on"
                />
                
                {/* Telemetry Preview (read-only) */}
                {editingTask.telemetry && (
                  <>
                    <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>Telemetry Data</Typography>
                    <Paper sx={{ p: 2, backgroundColor: '#f5f5f5' }}>
                      <pre style={{ margin: 0, fontSize: '0.8rem' }}>
                        {JSON.stringify(editingTask.telemetry, null, 2)}
                      </pre>
                    </Paper>
                  </>
                )}
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setEditTaskDialog(false)}>Cancel</Button>
            <Button variant="contained" onClick={() => {/* Add save handler */}}>
              Save Changes
            </Button>
          </DialogActions>
        </Dialog>

        {/* Product Edit Dialog */}
        <Dialog
          open={editProductDialog}
          onClose={() => setEditProductDialog(false)}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>Edit Product</DialogTitle>
          <DialogContent>
            {editingProduct && (
              <Box sx={{ pt: 1 }}>
                <TextField
                  fullWidth
                  label="Product Name"
                  value={editingProduct.name}
                  onChange={(e) => setEditingProduct({...editingProduct, name: e.target.value})}
                  margin="normal"
                />
                <TextField
                  fullWidth
                  label="Description"
                  value={editingProduct.description || ''}
                  onChange={(e) => setEditingProduct({...editingProduct, description: e.target.value})}
                  margin="normal"
                  multiline
                  rows={3}
                />
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setEditProductDialog(false)}>Cancel</Button>
            <Button variant="contained" onClick={() => {/* Add save handler */}}>
              Save Changes
            </Button>
          </DialogActions>
        </Dialog>

        {/* Add Product Dialog */}
        <Dialog open={addProductDialog} onClose={() => setAddProductDialog(false)} maxWidth="sm" fullWidth>
          <DialogTitle>Add New Product</DialogTitle>
          <DialogContent>
            <TextField
              label="Product Name"
              value={newProduct.name}
              onChange={(e) => setNewProduct({...newProduct, name: e.target.value})}
              fullWidth
              margin="normal"
            />
            <TextField
              label="Description"
              value={newProduct.description}
              onChange={(e) => setNewProduct({...newProduct, description: e.target.value})}
              fullWidth
              margin="normal"
              multiline
              rows={3}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setAddProductDialog(false)}>Cancel</Button>
            <Button variant="contained" onClick={handleAddProduct}>
              Add Product
            </Button>
          </DialogActions>
        </Dialog>

        {/* Add Task Dialog */}
        <Dialog open={addTaskDialog} onClose={() => setAddTaskDialog(false)} maxWidth="sm" fullWidth>
          <DialogTitle>Add New Task</DialogTitle>
          <DialogContent>
            <TextField
              label="Task Name"
              value={newTask.name}
              onChange={(e) => setNewTask({...newTask, name: e.target.value})}
              fullWidth
              margin="normal"
            />
            <TextField
              label="Description"
              value={newTask.description}
              onChange={(e) => setNewTask({...newTask, description: e.target.value})}
              fullWidth
              margin="normal"
              multiline
              rows={2}
            />
            <TextField
              label="Estimated Minutes"
              type="number"
              value={newTask.estMinutes}
              onChange={(e) => setNewTask({...newTask, estMinutes: parseInt(e.target.value)})}
              fullWidth
              margin="normal"
            />
            <TextField
              label="Weight (%)"
              type="number"
              value={newTask.weight}
              onChange={(e) => setNewTask({...newTask, weight: parseFloat(e.target.value)})}
              fullWidth
              margin="normal"
              helperText="Weight will auto-adjust to ensure total is 100%"
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setAddTaskDialog(false)}>Cancel</Button>
            <Button variant="contained" onClick={handleAddTask}>
              Add Task
            </Button>
          </DialogActions>
        </Dialog>

        {/* Delete Product Confirmation */}
        <Dialog open={confirmDeleteProduct !== null} onClose={() => setConfirmDeleteProduct(null)}>
          <DialogTitle>Confirm Delete</DialogTitle>
          <DialogContent>
            <Typography>
              Are you sure you want to delete this product? This action cannot be undone and will also delete all associated tasks.
            </Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setConfirmDeleteProduct(null)}>Cancel</Button>
            <Button variant="contained" color="error" onClick={handleDeleteProduct}>
              Delete
            </Button>
          </DialogActions>
        </Dialog>

        {/* Delete Task Confirmation */}
        <Dialog open={confirmDeleteTask !== null} onClose={() => setConfirmDeleteTask(null)}>
          <DialogTitle>Confirm Delete</DialogTitle>
          <DialogContent>
            <Typography>
              Are you sure you want to delete this task? This action cannot be undone.
            </Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setConfirmDeleteTask(null)}>Cancel</Button>
            <Button variant="contained" color="error" onClick={handleDeleteTask}>
              Delete
            </Button>
          </DialogActions>
        </Dialog>

        {/* CSV Import Dialog */}
        <Dialog open={csvImportDialog} onClose={() => setCsvImportDialog(false)} maxWidth="sm" fullWidth>
          <DialogTitle>Import {csvImportType === 'products' ? 'Products' : 'Tasks'} from CSV</DialogTitle>
          <DialogContent>
            <Typography variant="body2" sx={{ mb: 2 }}>
              Upload a CSV file to import {csvImportType}. 
              <Button 
                size="small" 
                onClick={() => handleDownloadSample(csvImportType)}
                sx={{ ml: 1 }}
              >
                Download Sample
              </Button>
            </Typography>
            {csvFile && (
              <Typography variant="body2" color="primary" sx={{ mb: 2 }}>
                Selected: {csvFile.name}
              </Typography>
            )}
            <Button
              variant="outlined"
              component="label"
              fullWidth
            >
              Choose CSV File
              <input
                type="file"
                hidden
                accept=".csv"
                onChange={(e) => setCsvFile(e.target.files?.[0] || null)}
              />
            </Button>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setCsvImportDialog(false)}>Cancel</Button>
            <Button 
              variant="contained" 
              onClick={handleCsvImport}
              disabled={!csvFile}
            >
              Import
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
    </Box>
  );
}

export default App;
