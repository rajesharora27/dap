/**
 * Telemetry Service
 * 
 * This service provides high-level operations for managing telemetry attributes and values.
 * It encapsulates business logic, validation, and data access patterns for the telemetry system.
 * 
 * Features:
 * - CRUD operations for telemetry attributes and values
 * - Batch operations for bulk telemetry updates
 * - Task completion calculation based on telemetry
 * - Comprehensive error handling and validation
 * - Audit logging integration
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */

import { prisma } from '../../context';
import { logAudit } from '../../lib/audit';
import { 
  TelemetryAttribute, 
  TelemetryValue, 
  TelemetryCompletionSummary,
  BatchTelemetryInput,
  EvaluationResult,
  TelemetryDataType,
  SuccessCriteria
} from './types';
import { evaluateTelemetryAttribute, evaluateMultipleAttributes } from './evaluationEngine';

/**
 * Main telemetry service class
 */
export class TelemetryService {

  /**
   * Creates a new telemetry attribute for a task
   * 
   * @param taskId - The ID of the task
   * @param attributeData - The attribute data
   * @param userId - The user creating the attribute (for audit logging)
   * @returns Promise<TelemetryAttribute> - The created attribute
   */
  static async createAttribute(
    taskId: string,
    attributeData: {
      name: string;
      description?: string;
      dataType: TelemetryDataType;
      successCriteria?: SuccessCriteria;
      order?: number;
      isRequired?: boolean;
    },
    userId?: string
  ): Promise<any> {
    try {
      // Validate task exists
      const task = await prisma.task.findUnique({ where: { id: taskId } });
      if (!task) {
        throw new Error(`Task with ID ${taskId} not found`);
      }

      // Calculate order if not provided
      let order = attributeData.order;
      if (order === undefined) {
        const maxOrder = await prisma.telemetryAttribute.aggregate({
          where: { taskId },
          _max: { order: true }
        });
        order = (maxOrder._max.order || 0) + 1;
      }

      // Create the attribute
      console.log(`[Service] Creating attribute "${attributeData.name}" with criteria:`, attributeData.successCriteria);
      const criteriaToStore = attributeData.successCriteria ? JSON.stringify(attributeData.successCriteria) : null;
      console.log(`[Service] Stringified for DB:`, criteriaToStore);
      
      const attribute = await prisma.telemetryAttribute.create({
        data: {
          taskId,
          name: attributeData.name,
          description: attributeData.description,
          dataType: attributeData.dataType,
          successCriteria: criteriaToStore,
          order,
          isRequired: attributeData.isRequired ?? false
        },
        include: {
          task: true,
          values: {
            orderBy: { createdAt: 'desc' },
            take: 1
          }
        }
      });
      
      console.log(`[Service] Created attribute with successCriteria:`, attribute.successCriteria);

      // Log audit trail
      if (userId) {
        await logAudit('CREATE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attribute.id, attributeData, userId);
      }

      return attribute;
    } catch (error) {
      throw new Error(`Failed to create telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Updates an existing telemetry attribute
   * 
   * @param attributeId - The ID of the attribute to update
   * @param updateData - The data to update
   * @param userId - The user updating the attribute (for audit logging)
   * @returns Promise<TelemetryAttribute> - The updated attribute
   */
  static async updateAttribute(
    attributeId: string,
    updateData: {
      name?: string;
      description?: string;
      dataType?: TelemetryDataType;
      successCriteria?: SuccessCriteria;
      order?: number;
      isRequired?: boolean;
    },
    userId?: string
  ): Promise<any> {
    try {
      // Check if attribute exists
      const existingAttribute = await prisma.telemetryAttribute.findUnique({
        where: { id: attributeId }
      });
      if (!existingAttribute) {
        throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
      }

      // Prepare update data
      const updatePayload: any = {};
      if (updateData.name !== undefined) updatePayload.name = updateData.name;
      if (updateData.description !== undefined) updatePayload.description = updateData.description;
      if (updateData.dataType !== undefined) updatePayload.dataType = updateData.dataType;
      if (updateData.successCriteria !== undefined) {
        console.log(`[Service] Updating attribute ${attributeId} with criteria:`, updateData.successCriteria);
        const criteriaToStore = updateData.successCriteria ? JSON.stringify(updateData.successCriteria) : null;
        console.log(`[Service] Stringified for DB:`, criteriaToStore);
        updatePayload.successCriteria = criteriaToStore;
      }
      if (updateData.order !== undefined) updatePayload.order = updateData.order;
      if (updateData.isRequired !== undefined) updatePayload.isRequired = updateData.isRequired;

      // Update the attribute
      const updatedAttribute = await prisma.telemetryAttribute.update({
        where: { id: attributeId },
        data: updatePayload,
        include: {
          task: true,
          values: {
            orderBy: { createdAt: 'desc' },
            take: 1
          }
        }
      });
      
      console.log(`[Service] Updated attribute successCriteria in DB:`, updatedAttribute.successCriteria);

      // Log audit trail
      if (userId) {
        await logAudit('UPDATE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attributeId, updateData, userId);
      }

      return updatedAttribute;
    } catch (error) {
      throw new Error(`Failed to update telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Deletes a telemetry attribute and all its values
   * 
   * @param attributeId - The ID of the attribute to delete
   * @param userId - The user deleting the attribute (for audit logging)
   * @returns Promise<boolean> - True if deletion was successful
   */
  static async deleteAttribute(attributeId: string, userId?: string): Promise<boolean> {
    try {
      // Check if attribute exists
      const attribute = await prisma.telemetryAttribute.findUnique({
        where: { id: attributeId }
      });
      if (!attribute) {
        throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
      }

      // Delete the attribute (cascade will handle values)
      await prisma.telemetryAttribute.delete({
        where: { id: attributeId }
      });

      // Log audit trail
      if (userId) {
        await logAudit('DELETE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attributeId, {}, userId);
      }

      return true;
    } catch (error) {
      throw new Error(`Failed to delete telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Adds a telemetry value to an attribute
   * 
   * @param attributeId - The ID of the attribute
   * @param valueData - The value data
   * @param userId - The user adding the value (for audit logging)
   * @returns Promise<TelemetryValue> - The created value
   */
  static async addValue(
    attributeId: string,
    valueData: {
      value: string;
      notes?: string;
      batchId?: string;
    },
    userId?: string
  ): Promise<any> {
    try {
      // Validate attribute exists
      const attribute = await prisma.telemetryAttribute.findUnique({
        where: { id: attributeId }
      });
      if (!attribute) {
        throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
      }

      // Create the value
      const telemetryValue = await prisma.telemetryValue.create({
        data: {
          attributeId,
          value: valueData.value,
          notes: valueData.notes,
          batchId: valueData.batchId
        },
        include: {
          attribute: true
        }
      });

      // Log audit trail
      if (userId) {
        await logAudit('ADD_TELEMETRY_VALUE', 'TelemetryValue', telemetryValue.id, valueData, userId);
      }

      return telemetryValue;
    } catch (error) {
      throw new Error(`Failed to add telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Adds multiple telemetry values in a batch
   * 
   * @param batchData - The batch data
   * @param userId - The user adding the batch (for audit logging)
   * @returns Promise<TelemetryValue[]> - The created values
   */
  static async addBatchValues(batchData: BatchTelemetryInput, userId?: string): Promise<any[]> {
    try {
      const { batchId, values } = batchData;

      // Validate all attributes exist
      const attributeIds = values.map(v => v.attributeId);
      const attributes = await prisma.telemetryAttribute.findMany({
        where: { id: { in: attributeIds } }
      });
      
      if (attributes.length !== attributeIds.length) {
        const foundIds = attributes.map((a: any) => a.id);
        const missingIds = attributeIds.filter(id => !foundIds.includes(id));
        throw new Error(`Telemetry attributes not found: ${missingIds.join(', ')}`);
      }

      // Create all values
      const valuePromises = values.map(valueInput => 
        prisma.telemetryValue.create({
          data: {
            attributeId: valueInput.attributeId,
            value: valueInput.value,
            notes: valueInput.notes,
            batchId
          },
          include: {
            attribute: true
          }
        })
      );

      const createdValues = await Promise.all(valuePromises);

      // Log audit trail
      if (userId) {
        await logAudit('ADD_BATCH_TELEMETRY_VALUES', 'TelemetryValue', batchId, { count: values.length }, userId);
      }

      return createdValues;
    } catch (error) {
      throw new Error(`Failed to add batch telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Gets telemetry completion summary for a task
   * 
   * @param taskId - The ID of the task
   * @returns Promise<TelemetryCompletionSummary> - The completion summary
   */
  static async getTaskCompletionSummary(taskId: string): Promise<TelemetryCompletionSummary> {
    try {
      // Get all telemetry attributes for the task
      const attributes = await prisma.telemetryAttribute.findMany({
        where: { taskId },
        include: {
          values: {
            orderBy: { createdAt: 'desc' },
            take: 1
          }
        },
        orderBy: { order: 'asc' }
      });

      if (attributes.length === 0) {
        return {
          totalAttributes: 0,
          successfulAttributes: 0,
          completionPercentage: 0,
          isComplete: false,
          failedAttributes: []
        };
      }

      // Evaluate each attribute
      const evaluationResults = await evaluateMultipleAttributes(attributes);
      
      // Calculate summary
      const successfulCount = evaluationResults.filter(result => result.success).length;
      const completionPercentage = (successfulCount / attributes.length) * 100;
      
      const failedAttributes = evaluationResults
        .filter(result => !result.success)
        .map((result, index) => ({
          id: attributes[index].id,
          name: attributes[index].name,
          reason: result.details || result.error || 'Unknown failure'
        }));

      return {
        totalAttributes: attributes.length,
        successfulAttributes: successfulCount,
        completionPercentage,
        isComplete: successfulCount === attributes.length,
        failedAttributes
      };
    } catch (error) {
      throw new Error(`Failed to get task completion summary: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Gets all telemetry attributes for a task
   * 
   * @param taskId - The ID of the task
   * @param includeValues - Whether to include values
   * @returns Promise<TelemetryAttribute[]> - The attributes
   */
  static async getAttributesForTask(taskId: string, includeValues: boolean = true): Promise<any[]> {
    try {
      return await prisma.telemetryAttribute.findMany({
        where: { taskId },
        include: {
          values: includeValues ? {
            orderBy: { createdAt: 'desc' },
            take: 50
          } : false
        },
        orderBy: { order: 'asc' }
      });
    } catch (error) {
      throw new Error(`Failed to get telemetry attributes: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Gets a single telemetry attribute by ID
   * 
   * @param attributeId - The ID of the attribute
   * @param includeValues - Whether to include values
   * @returns Promise<TelemetryAttribute | null> - The attribute or null if not found
   */
  static async getAttributeById(attributeId: string, includeValues: boolean = true): Promise<any | null> {
    try {
      return await prisma.telemetryAttribute.findUnique({
        where: { id: attributeId },
        include: {
          task: true,
          values: includeValues ? {
            orderBy: { createdAt: 'desc' },
            take: 50
          } : false
        }
      });
    } catch (error) {
      throw new Error(`Failed to get telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Gets telemetry values for an attribute
   * 
   * @param attributeId - The ID of the attribute
   * @param limit - Maximum number of values to return
   * @returns Promise<TelemetryValue[]> - The values
   */
  static async getValuesForAttribute(attributeId: string, limit: number = 50): Promise<any[]> {
    try {
      return await prisma.telemetryValue.findMany({
        where: { attributeId },
        include: {
          attribute: true
        },
        orderBy: { createdAt: 'desc' },
        take: Math.min(limit, 200)
      });
    } catch (error) {
      throw new Error(`Failed to get telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Updates a telemetry value
   * 
   * @param valueId - The ID of the value to update
   * @param updateData - The data to update
   * @param userId - The user updating the value (for audit logging)
   * @returns Promise<TelemetryValue> - The updated value
   */
  static async updateValue(
    valueId: string,
    updateData: {
      value?: string;
      notes?: string;
    },
    userId?: string
  ): Promise<any> {
    try {
      // Check if value exists
      const existingValue = await prisma.telemetryValue.findUnique({
        where: { id: valueId }
      });
      if (!existingValue) {
        throw new Error(`Telemetry value with ID ${valueId} not found`);
      }

      // Update the value
      const updatedValue = await prisma.telemetryValue.update({
        where: { id: valueId },
        data: updateData,
        include: {
          attribute: true
        }
      });

      // Log audit trail
      if (userId) {
        await logAudit('UPDATE_TELEMETRY_VALUE', 'TelemetryValue', valueId, updateData, userId);
      }

      return updatedValue;
    } catch (error) {
      throw new Error(`Failed to update telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Deletes a telemetry value
   * 
   * @param valueId - The ID of the value to delete
   * @param userId - The user deleting the value (for audit logging)
   * @returns Promise<boolean> - True if deletion was successful
   */
  static async deleteValue(valueId: string, userId?: string): Promise<boolean> {
    try {
      // Check if value exists
      const value = await prisma.telemetryValue.findUnique({
        where: { id: valueId }
      });
      if (!value) {
        throw new Error(`Telemetry value with ID ${valueId} not found`);
      }

      // Delete the value
      await prisma.telemetryValue.delete({
        where: { id: valueId }
      });

      // Log audit trail
      if (userId) {
        await logAudit('DELETE_TELEMETRY_VALUE', 'TelemetryValue', valueId, {}, userId);
      }

      return true;
    } catch (error) {
      throw new Error(`Failed to delete telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}