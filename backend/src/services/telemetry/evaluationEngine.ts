/**
 * Telemetry Evaluation Engine
 * 
 * This module provides the core evaluation logic for telemetry success criteria.
 * It supports complex AND/OR logic with multiple data types and comparison modes.
 * 
 * Features:
 * - Recursive evaluation of composite criteria (AND/OR)
 * - Type-safe evaluation for boolean, number, string, and timestamp data
 * - Comprehensive error handling and validation
 * - Detailed evaluation results with failure reasons
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */

import {
  SuccessCriteria,
  SuccessCriteriaType,
  BooleanFlagCriteria,
  NumberThresholdCriteria,
  StringMatchCriteria,
  TimestampComparisonCriteria,
  CompositeAndCriteria,
  CompositeOrCriteria,
  NumberOperator,
  StringMatchMode,
  TimestampMode,
  EvaluationResult,
  TelemetryDataType,
  TelemetryValue
} from './types';

/**
 * Main evaluation engine class for telemetry success criteria
 */
export class TelemetryEvaluationEngine {
  
  /**
   * Evaluates a telemetry attribute against its success criteria
   * 
   * @param attribute - The telemetry attribute with success criteria
   * @returns Promise<EvaluationResult> - The evaluation result
   */
  static async evaluateAttribute(attribute: any): Promise<EvaluationResult> {
    try {
      // Check if attribute has values
      if (!attribute.values || attribute.values.length === 0) {
        return {
          success: false,
          details: 'No telemetry values found for evaluation'
        };
      }

      // Check if success criteria is defined
      if (!attribute.successCriteria) {
        return {
          success: true,
          details: 'No success criteria defined - considered successful'
        };
      }

      // Get the latest value for evaluation
      const latestValue = attribute.values[0]; // Assuming values are ordered by createdAt desc
      
      // Parse success criteria from JSON if needed
      let criteria: SuccessCriteria;
      if (typeof attribute.successCriteria === 'string') {
        criteria = JSON.parse(attribute.successCriteria);
      } else {
        criteria = attribute.successCriteria;
      }

      // Evaluate the criteria
      return await this.evaluateCriteria(criteria, latestValue, attribute.dataType);
      
    } catch (error) {
      return {
        success: false,
        error: `Evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates success criteria against a telemetry value
   * 
   * @param criteria - The success criteria to evaluate
   * @param value - The telemetry value to evaluate against
   * @param dataType - The data type of the telemetry attribute
   * @returns Promise<EvaluationResult> - The evaluation result
   */
  private static async evaluateCriteria(
    criteria: SuccessCriteria, 
    value: TelemetryValue, 
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {
    
    switch (criteria.type) {
      case SuccessCriteriaType.BOOLEAN_FLAG:
        return this.evaluateBooleanFlag(criteria as BooleanFlagCriteria, value);
        
      case SuccessCriteriaType.NUMBER_THRESHOLD:
        return this.evaluateNumberThreshold(criteria as NumberThresholdCriteria, value);
        
      case SuccessCriteriaType.STRING_MATCH:
        return this.evaluateStringMatch(criteria as StringMatchCriteria, value);
        
      case SuccessCriteriaType.TIMESTAMP_COMPARISON:
        return this.evaluateTimestampComparison(criteria as TimestampComparisonCriteria, value);
        
      case SuccessCriteriaType.COMPOSITE_AND:
        return this.evaluateCompositeAnd(criteria as CompositeAndCriteria, value, dataType);
        
      case SuccessCriteriaType.COMPOSITE_OR:
        return this.evaluateCompositeOr(criteria as CompositeOrCriteria, value, dataType);
        
      default:
        return {
          success: false,
          error: `Unknown criteria type: ${(criteria as any).type}`
        };
    }
  }

  /**
   * Evaluates boolean flag criteria
   */
  private static evaluateBooleanFlag(criteria: BooleanFlagCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const boolValue = this.parseBoolean(value.value);
      const success = boolValue === criteria.expectedValue;
      
      return {
        success,
        details: success 
          ? `Boolean value ${boolValue} matches expected ${criteria.expectedValue}`
          : `Boolean value ${boolValue} does not match expected ${criteria.expectedValue}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to parse boolean value: ${value.value}`
      };
    }
  }

  /**
   * Evaluates number threshold criteria
   */
  private static evaluateNumberThreshold(criteria: NumberThresholdCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const numValue = parseFloat(value.value);
      if (isNaN(numValue)) {
        return {
          success: false,
          error: `Invalid number value: ${value.value}`
        };
      }

      let success = false;
      let comparison = '';

      switch (criteria.operator) {
        case NumberOperator.GREATER_THAN:
          success = numValue > criteria.threshold;
          comparison = `${numValue} > ${criteria.threshold}`;
          break;
        case NumberOperator.LESS_THAN:
          success = numValue < criteria.threshold;
          comparison = `${numValue} < ${criteria.threshold}`;
          break;
        case NumberOperator.EQUALS:
          success = numValue === criteria.threshold;
          comparison = `${numValue} = ${criteria.threshold}`;
          break;
        case NumberOperator.GREATER_THAN_OR_EQUAL:
          success = numValue >= criteria.threshold;
          comparison = `${numValue} >= ${criteria.threshold}`;
          break;
        case NumberOperator.LESS_THAN_OR_EQUAL:
          success = numValue <= criteria.threshold;
          comparison = `${numValue} <= ${criteria.threshold}`;
          break;
      }

      return {
        success,
        details: `Number comparison: ${comparison} = ${success}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Number threshold evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates string match criteria
   */
  private static evaluateStringMatch(criteria: StringMatchCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const stringValue = value.value;
      let pattern = criteria.pattern;
      
      // Handle case sensitivity
      if (!criteria.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      
      const testValue = criteria.caseSensitive ? stringValue : stringValue.toLowerCase();
      let success = false;
      let method = '';

      switch (criteria.mode) {
        case StringMatchMode.EXACT:
          success = testValue === pattern;
          method = 'exact match';
          break;
        case StringMatchMode.CONTAINS:
          success = testValue.includes(pattern);
          method = 'contains';
          break;
        case StringMatchMode.REGEX:
          const regex = new RegExp(criteria.pattern, criteria.caseSensitive ? 'g' : 'gi');
          success = regex.test(stringValue);
          method = 'regex match';
          break;
      }

      return {
        success,
        details: `String ${method}: "${stringValue}" ${success ? 'matches' : 'does not match'} pattern "${criteria.pattern}"`
      };
    } catch (error) {
      return {
        success: false,
        error: `String match evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates timestamp comparison criteria
   */
  private static evaluateTimestampComparison(criteria: TimestampComparisonCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const timestamp = new Date(value.value);
      if (isNaN(timestamp.getTime())) {
        return {
          success: false,
          error: `Invalid timestamp value: ${value.value}`
        };
      }

      const now = new Date();
      let referenceTime: Date;
      
      if (criteria.referenceTime === 'now' || !criteria.referenceTime) {
        referenceTime = now;
      } else {
        referenceTime = new Date(criteria.referenceTime);
        if (isNaN(referenceTime.getTime())) {
          return {
            success: false,
            error: `Invalid reference time: ${criteria.referenceTime}`
          };
        }
      }

      let success = false;
      let comparison = '';

      switch (criteria.mode) {
        case TimestampMode.BEFORE:
          success = timestamp < referenceTime;
          comparison = `${timestamp.toISOString()} before ${referenceTime.toISOString()}`;
          break;
        case TimestampMode.AFTER:
          success = timestamp > referenceTime;
          comparison = `${timestamp.toISOString()} after ${referenceTime.toISOString()}`;
          break;
        case TimestampMode.WITHIN_DAYS:
          if (!criteria.withinDays) {
            return {
              success: false,
              error: 'withinDays parameter required for within_days mode'
            };
          }
          const daysDiff = Math.abs((timestamp.getTime() - referenceTime.getTime()) / (1000 * 60 * 60 * 24));
          success = daysDiff <= criteria.withinDays;
          comparison = `${daysDiff.toFixed(1)} days difference, within ${criteria.withinDays} days`;
          break;
      }

      return {
        success,
        details: `Timestamp comparison: ${comparison} = ${success}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Timestamp comparison evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates composite AND criteria (all must be true)
   */
  private static async evaluateCompositeAnd(
    criteria: CompositeAndCriteria, 
    value: TelemetryValue, 
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {
    try {
      const results: EvaluationResult[] = [];
      
      for (const subCriteria of criteria.criteria) {
        const result = await this.evaluateCriteria(subCriteria, value, dataType);
        results.push(result);
        
        // Early exit if any criteria fails
        if (!result.success) {
          return {
            success: false,
            details: `AND criteria failed at: ${result.details || result.error}`
          };
        }
      }

      return {
        success: true,
        details: `All ${criteria.criteria.length} AND criteria passed`
      };
    } catch (error) {
      return {
        success: false,
        error: `Composite AND evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates composite OR criteria (at least one must be true)
   */
  private static async evaluateCompositeOr(
    criteria: CompositeOrCriteria, 
    value: TelemetryValue, 
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {
    try {
      const results: EvaluationResult[] = [];
      const failures: string[] = [];
      
      for (const subCriteria of criteria.criteria) {
        const result = await this.evaluateCriteria(subCriteria, value, dataType);
        results.push(result);
        
        // Early exit if any criteria succeeds
        if (result.success) {
          return {
            success: true,
            details: `OR criteria passed: ${result.details}`
          };
        }
        
        failures.push(result.details || result.error || 'Unknown failure');
      }

      return {
        success: false,
        details: `All ${criteria.criteria.length} OR criteria failed: ${failures.join('; ')}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Composite OR evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Parses a string value to boolean
   */
  private static parseBoolean(value: string): boolean {
    const lowercaseValue = value.toLowerCase();
    if (['true', '1', 'yes', 'on'].includes(lowercaseValue)) {
      return true;
    }
    if (['false', '0', 'no', 'off'].includes(lowercaseValue)) {
      return false;
    }
    throw new Error(`Cannot parse "${value}" as boolean`);
  }
}

/**
 * Convenience function for evaluating a single telemetry attribute
 * 
 * @param attribute - The telemetry attribute to evaluate
 * @returns Promise<EvaluationResult> - The evaluation result
 */
export async function evaluateTelemetryAttribute(attribute: any): Promise<EvaluationResult> {
  return TelemetryEvaluationEngine.evaluateAttribute(attribute);
}

/**
 * Convenience function for batch evaluation of multiple attributes
 * 
 * @param attributes - Array of telemetry attributes to evaluate
 * @returns Promise<Array<EvaluationResult & { attributeId: string }>> - Array of evaluation results
 */
export async function evaluateMultipleAttributes(
  attributes: any[]
): Promise<Array<EvaluationResult & { attributeId: string }>> {
  const evaluationPromises = attributes.map(async (attribute) => {
    const result = await TelemetryEvaluationEngine.evaluateAttribute(attribute);
    return {
      ...result,
      attributeId: attribute.id
    };
  });
  
  return Promise.all(evaluationPromises);
}