/**
 * Telemetry Evaluation Engine
 * 
 * This module provides the core evaluation logic for telemetry success criteria.
 * It supports complex AND/OR logic with multiple data types and comparison modes.
 * 
 * Features:
 * - Recursive evaluation of composite criteria (AND/OR)
 * - Type-safe evaluation for boolean, number, string, and timestamp data
 * - Comprehensive error handling and validation
 * - Detailed evaluation results with failure reasons
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */

import {
  SuccessCriteria,
  SuccessCriteriaType,
  BooleanFlagCriteria,
  NumberThresholdCriteria,
  StringMatchCriteria,
  TimestampComparisonCriteria,
  CompositeAndCriteria,
  CompositeOrCriteria,
  NumberOperator,
  StringMatchMode,
  TimestampMode,
  EvaluationResult,
  TelemetryDataType,
  TelemetryValue
} from './types';

/**
 * Main evaluation engine class for telemetry success criteria
 */
export class TelemetryEvaluationEngine {

  /**
   * Evaluates a telemetry attribute against its success criteria
   * 
   * @param attribute - The telemetry attribute with success criteria
   * @returns Promise<EvaluationResult> - The evaluation result
   */
  static async evaluateAttribute(attribute: any): Promise<EvaluationResult> {
    try {
      // Check if attribute has values
      if (!attribute.values || attribute.values.length === 0) {
        return {
          success: false,
          details: 'No telemetry values found for evaluation'
        };
      }

      // Check if success criteria is defined
      if (!attribute.successCriteria) {
        return {
          success: true,
          details: 'No success criteria defined - considered successful'
        };
      }

      // Get the latest value for evaluation
      const latestValue = attribute.values[0]; // Assuming values are ordered by createdAt desc

      // Parse success criteria from JSON if needed
      let criteria: SuccessCriteria;
      if (typeof attribute.successCriteria === 'string') {
        criteria = JSON.parse(attribute.successCriteria);
      } else {
        criteria = attribute.successCriteria;
      }

      // Evaluate the criteria
      return await this.evaluateCriteria(criteria, latestValue, attribute.dataType);

    } catch (error) {
      return {
        success: false,
        error: `Evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates success criteria against a telemetry value
   * 
   * @param criteria - The success criteria to evaluate
   * @param value - The telemetry value to evaluate against
   * @param dataType - The data type of the telemetry attribute
   * @returns Promise<EvaluationResult> - The evaluation result
   */
  private static async evaluateCriteria(
    criteria: SuccessCriteria,
    value: TelemetryValue,
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {

    let type = criteria.type?.toLowerCase();

    // Handle legacy/malformed criteria where type is missing
    if (!type) {
      const c = criteria as any;
      if (typeof c.value === 'boolean') {
        type = SuccessCriteriaType.BOOLEAN_FLAG;
        // Backfill expectedValue from value if missing
        if (c.expectedValue === undefined) c.expectedValue = c.value;
      } else if (typeof c.value === 'number' && c.operator) {
        type = SuccessCriteriaType.NUMBER_THRESHOLD;
        // Backfill threshold from value if missing
        if (c.threshold === undefined) c.threshold = c.value;

        // Map legacy operators
        const opMap: Record<string, string> = {
          '>=': 'greater_than_or_equal',
          '<=': 'less_than_or_equal',
          '>': 'greater_than',
          '<': 'less_than',
          '==': 'equals',
          '=': 'equals'
        };

        if (opMap[c.operator]) {
          c.operator = opMap[c.operator];
        }
      } else if (dataType) {
        // Use the dataType parameter to infer criteria type for STRING/TIMESTAMP
        const dt = dataType.toString().toUpperCase();
        if (dt === 'STRING') {
          // For STRING without explicit type, default to string_not_null
          // This means: if there's a value, criteria is met
          type = SuccessCriteriaType.STRING_NOT_NULL;
        } else if (dt === 'TIMESTAMP' || dt === 'DATE') {
          // For TIMESTAMP without explicit type, default to timestamp_not_null
          type = SuccessCriteriaType.TIMESTAMP_NOT_NULL;
        } else if (dt === 'BOOLEAN') {
          // Fallback for BOOLEAN with string 'true'/'false' value
          type = SuccessCriteriaType.BOOLEAN_FLAG;
          if (c.expectedValue === undefined) {
            c.expectedValue = c.value === 'true' || c.value === true;
          }
        } else if (dt === 'NUMBER' || dt === 'PERCENTAGE') {
          // Fallback for NUMBER without operator - treat as equals
          type = SuccessCriteriaType.NUMBER_THRESHOLD;
          if (c.threshold === undefined) c.threshold = c.value;
          if (!c.operator) c.operator = 'equals';
        }
      }
    }

    switch (type) {
      case SuccessCriteriaType.BOOLEAN_FLAG:
        return this.evaluateBooleanFlag(criteria as BooleanFlagCriteria, value);

      case SuccessCriteriaType.NUMBER_THRESHOLD:
        return this.evaluateNumberThreshold(criteria as NumberThresholdCriteria, value);

      case SuccessCriteriaType.STRING_MATCH:
        return this.evaluateStringMatch(criteria as StringMatchCriteria, value);

      case SuccessCriteriaType.STRING_NOT_NULL:
        return this.evaluateStringNotNull(value);

      case SuccessCriteriaType.TIMESTAMP_COMPARISON:
        return this.evaluateTimestampComparison(criteria as TimestampComparisonCriteria, value);

      case SuccessCriteriaType.TIMESTAMP_NOT_NULL:
        return this.evaluateTimestampNotNull(value);

      case SuccessCriteriaType.COMPOSITE_AND:
        return this.evaluateCompositeAnd(criteria as CompositeAndCriteria, value, dataType);

      case SuccessCriteriaType.COMPOSITE_OR:
        return this.evaluateCompositeOr(criteria as CompositeOrCriteria, value, dataType);

      default:
        return {
          success: false,
          error: `Unknown criteria type: ${(criteria as any).type}`
        };
    }
  }

  /**
   * Evaluates boolean flag criteria
   */
  private static evaluateBooleanFlag(criteria: BooleanFlagCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const boolValue = this.parseBoolean(value.value);
      // Normalize expectedValue using the same parser to handle "true", 1, etc.
      const expectedBool = this.parseBoolean(criteria.expectedValue);

      const success = boolValue === expectedBool;

      return {
        success,
        details: success
          ? `Boolean value ${boolValue} matches expected ${expectedBool}`
          : `Boolean value ${boolValue} does not match expected ${expectedBool}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to parse boolean value: ${value.value}`
      };
    }
  }

  /**
   * Evaluates number threshold criteria
   */
  private static evaluateNumberThreshold(criteria: NumberThresholdCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const numValue = parseFloat(value.value);
      if (isNaN(numValue)) {
        return {
          success: false,
          error: `Invalid number value: ${value.value}`
        };
      }

      // Normalize threshold
      const threshold = typeof criteria.threshold === 'number'
        ? criteria.threshold
        : parseFloat(String(criteria.threshold));

      if (isNaN(threshold)) {
        return {
          success: false,
          error: `Invalid threshold value: ${criteria.threshold}`
        };
      }

      let success = false;
      let comparison = '';

      switch (criteria.operator) {
        case NumberOperator.GREATER_THAN:
          success = numValue > threshold;
          comparison = `${numValue} > ${threshold}`;
          break;
        case NumberOperator.LESS_THAN:
          success = numValue < threshold;
          comparison = `${numValue} < ${threshold}`;
          break;
        case NumberOperator.EQUALS:
          success = numValue === threshold;
          comparison = `${numValue} = ${threshold}`;
          break;
        case NumberOperator.GREATER_THAN_OR_EQUAL:
          success = numValue >= threshold;
          comparison = `${numValue} >= ${threshold}`;
          break;
        case NumberOperator.LESS_THAN_OR_EQUAL:
          success = numValue <= threshold;
          comparison = `${numValue} <= ${threshold}`;
          break;
      }

      return {
        success,
        details: `Number comparison: ${comparison} = ${success}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Number threshold evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates string match criteria
   */
  private static evaluateStringMatch(criteria: StringMatchCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const stringValue = value.value;
      let pattern = criteria.pattern;

      // Handle case sensitivity
      if (!criteria.caseSensitive) {
        pattern = pattern.toLowerCase();
      }

      const testValue = criteria.caseSensitive ? stringValue : stringValue.toLowerCase();
      let success = false;
      let method = '';

      switch (criteria.mode) {
        case StringMatchMode.EXACT:
          success = testValue === pattern;
          method = 'exact match';
          break;
        case StringMatchMode.CONTAINS:
          success = testValue.includes(pattern);
          method = 'contains';
          break;
        case StringMatchMode.REGEX:
          const regex = new RegExp(criteria.pattern, criteria.caseSensitive ? 'g' : 'gi');
          success = regex.test(stringValue);
          method = 'regex match';
          break;
      }

      return {
        success,
        details: `String ${method}: "${stringValue}" ${success ? 'matches' : 'does not match'} pattern "${criteria.pattern}"`
      };
    } catch (error) {
      return {
        success: false,
        error: `String match evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates string not-null criteria
   */
  private static evaluateStringNotNull(value: TelemetryValue): EvaluationResult {
    try {
      const stringValue = value.value;

      // Handle different value types
      if (stringValue === null || stringValue === undefined) {
        return {
          success: false,
          details: 'String value is null or undefined'
        };
      }

      // Convert to string if needed
      const strVal = typeof stringValue === 'string' ? stringValue : String(stringValue);
      const success = strVal.trim() !== '';

      return {
        success,
        details: success
          ? `String value is not null/empty: "${strVal}"`
          : 'String value is empty'
      };
    } catch (error) {
      return {
        success: false,
        error: `String not-null evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates timestamp comparison criteria
   */
  private static evaluateTimestampComparison(criteria: TimestampComparisonCriteria, value: TelemetryValue): EvaluationResult {
    try {
      const timestamp = new Date(value.value);
      if (isNaN(timestamp.getTime())) {
        return {
          success: false,
          error: `Invalid timestamp value: ${value.value}`
        };
      }

      const now = new Date();
      let referenceTime: Date;

      if (criteria.referenceTime === 'now' || !criteria.referenceTime) {
        referenceTime = now;
      } else {
        referenceTime = new Date(criteria.referenceTime);
        if (isNaN(referenceTime.getTime())) {
          return {
            success: false,
            error: `Invalid reference time: ${criteria.referenceTime}`
          };
        }
      }

      let success = false;
      let comparison = '';

      switch (criteria.mode) {
        case TimestampMode.BEFORE:
          success = timestamp < referenceTime;
          comparison = `${timestamp.toISOString()} before ${referenceTime.toISOString()}`;
          break;
        case TimestampMode.AFTER:
          success = timestamp > referenceTime;
          comparison = `${timestamp.toISOString()} after ${referenceTime.toISOString()}`;
          break;
        case TimestampMode.WITHIN_DAYS:
          if (!criteria.withinDays) {
            return {
              success: false,
              error: 'withinDays parameter required for within_days mode'
            };
          }
          const daysDiff = Math.abs((timestamp.getTime() - referenceTime.getTime()) / (1000 * 60 * 60 * 24));
          success = daysDiff <= criteria.withinDays;
          comparison = `${daysDiff.toFixed(1)} days difference, within ${criteria.withinDays} days`;
          break;
      }

      return {
        success,
        details: `Timestamp comparison: ${comparison} = ${success}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Timestamp comparison evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates timestamp not-null criteria
   */
  private static evaluateTimestampNotNull(value: TelemetryValue): EvaluationResult {
    try {
      if (!value.value || value.value === null || value.value === undefined) {
        return {
          success: false,
          details: 'Timestamp value is null or undefined'
        };
      }

      const timestamp = new Date(value.value);
      const success = !isNaN(timestamp.getTime());

      return {
        success,
        details: success
          ? `Timestamp is valid: ${timestamp.toISOString()}`
          : `Timestamp is invalid: ${value.value}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Timestamp not-null evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates composite AND criteria (all must be true)
   */
  private static async evaluateCompositeAnd(
    criteria: CompositeAndCriteria,
    value: TelemetryValue,
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {
    try {
      const results: EvaluationResult[] = [];

      for (const subCriteria of criteria.criteria) {
        const result = await this.evaluateCriteria(subCriteria, value, dataType);
        results.push(result);

        // Early exit if any criteria fails
        if (!result.success) {
          return {
            success: false,
            details: `AND criteria failed at: ${result.details || result.error}`
          };
        }
      }

      return {
        success: true,
        details: `All ${criteria.criteria.length} AND criteria passed`
      };
    } catch (error) {
      return {
        success: false,
        error: `Composite AND evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Evaluates composite OR criteria (at least one must be true)
   */
  private static async evaluateCompositeOr(
    criteria: CompositeOrCriteria,
    value: TelemetryValue,
    dataType: TelemetryDataType
  ): Promise<EvaluationResult> {
    try {
      const results: EvaluationResult[] = [];
      const failures: string[] = [];

      for (const subCriteria of criteria.criteria) {
        const result = await this.evaluateCriteria(subCriteria, value, dataType);
        results.push(result);

        // Early exit if any criteria succeeds
        if (result.success) {
          return {
            success: true,
            details: `OR criteria passed: ${result.details}`
          };
        }

        failures.push(result.details || result.error || 'Unknown failure');
      }

      return {
        success: false,
        details: `All ${criteria.criteria.length} OR criteria failed: ${failures.join('; ')}`
      };
    } catch (error) {
      return {
        success: false,
        error: `Composite OR evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Parses a value to boolean (handles boolean, string, and number inputs)
   */
  private static parseBoolean(value: any): boolean {
    // Already a boolean
    if (typeof value === 'boolean') {
      return value;
    }

    // Number (1 = true, 0 = false)
    if (typeof value === 'number') {
      return value !== 0;
    }

    // String
    if (typeof value === 'string') {
      const lowercaseValue = value.toLowerCase().trim();
      if (['true', '1', 'yes', 'on', 't', 'y'].includes(lowercaseValue)) {
        return true;
      }
      if (['false', '0', 'no', 'off', 'f', 'n'].includes(lowercaseValue)) {
        return false;
      }
    }

    throw new Error(`Cannot parse "${value}" as boolean`);
  }
}

/**
 * Convenience function for evaluating a single telemetry attribute
 * 
 * @param attribute - The telemetry attribute to evaluate
 * @returns Promise<EvaluationResult> - The evaluation result
 */
export async function evaluateTelemetryAttribute(attribute: any): Promise<EvaluationResult> {
  return TelemetryEvaluationEngine.evaluateAttribute(attribute);
}

/**
 * Convenience function for batch evaluation of multiple attributes
 * 
 * @param attributes - Array of telemetry attributes to evaluate
 * @returns Promise<Array<EvaluationResult & { attributeId: string }>> - Array of evaluation results
 */
export async function evaluateMultipleAttributes(
  attributes: any[]
): Promise<Array<EvaluationResult & { attributeId: string }>> {
  const evaluationPromises = attributes.map(async (attribute) => {
    const result = await TelemetryEvaluationEngine.evaluateAttribute(attribute);
    return {
      ...result,
      attributeId: attribute.id
    };
  });

  return Promise.all(evaluationPromises);
}

/**
 * SHARED: Determine task status based on telemetry evaluation
 * Used by BOTH product tasks (CustomerTask) and solution tasks (CustomerSolutionTask)
 * 
 * @param task - The task with current status and statusUpdateSource
 * @param telemetryAttributes - Array of telemetry attributes with values
 * @returns Promise<{ newStatus: string, shouldUpdate: boolean, evaluationDetails: any }>
 */
export async function evaluateTaskStatusFromTelemetry(
  task: { status: string; statusUpdateSource?: string | null },
  telemetryAttributes: any[],
  options?: { currentBatchId?: string }
): Promise<{ newStatus: string; shouldUpdate: boolean; evaluationDetails: any }> {
  const attributes = telemetryAttributes.filter((a: any) => a.isActive);
  const requiredAttributes = attributes.filter((a: any) => a.isRequired);

  let metCount = 0;
  let metRequiredCount = 0;
  let hasAnyTelemetryData = false;
  let requiredWithDataCount = 0;

  // Evaluate each attribute
  for (const attr of attributes) {
    const latestValue = attr.values && attr.values[0];

    // Check if data is present and fresh (if batch ID provided)
    let isFresh = false;
    if (latestValue) {
      if (options?.currentBatchId) {
        isFresh = latestValue.batchId === options.currentBatchId;
      } else {
        isFresh = true;
      }
    }

    if (isFresh) {
      hasAnyTelemetryData = true;
      if (attr.isRequired) requiredWithDataCount++;
    }

    if (!latestValue || !isFresh) continue;

    // Evaluate criteria
    let isMet = false;
    if (attr.successCriteria) {
      try {
        const evaluationResult = await TelemetryEvaluationEngine.evaluateAttribute(attr);
        isMet = evaluationResult.success;
      } catch (evalError) {
        console.error(`Failed to evaluate criteria for ${attr.name}:`, evalError);
        isMet = false;
      }
    }

    if (isMet) {
      metCount++;
      if (attr.isRequired) metRequiredCount++;
    }
  }

  // Determine new status using consistent logic
  // Status values: NOT_STARTED, IN_PROGRESS, DONE, NO_LONGER_USING, NOT_APPLICABLE
  const wasPreviouslyDoneByTelemetry =
    (task.status === 'DONE' || task.status === 'COMPLETED') &&
    task.statusUpdateSource?.toUpperCase() === 'TELEMETRY';

  const wasPreviouslyDoneByUser =
    (task.status === 'DONE' || task.status === 'COMPLETED') &&
    task.statusUpdateSource?.toUpperCase() !== 'TELEMETRY';

  const wasPreviouslyDone = wasPreviouslyDoneByTelemetry || wasPreviouslyDoneByUser;

  let newStatus = task.status;

  if (requiredAttributes.length > 0) {
    // Has required attributes - evaluate based on those
    if (metRequiredCount === requiredAttributes.length) {
      // All required telemetry criteria met
      newStatus = 'DONE';
    } else if (wasPreviouslyDoneByTelemetry && !hasAnyTelemetryData) {
      // DONE by Telemetry + No Data -> NO_LONGER_USING
      newStatus = 'NO_LONGER_USING';
    } else if (wasPreviouslyDoneByUser && !hasAnyTelemetryData) {
      // DONE by User + No Data -> Stay DONE
      newStatus = 'DONE';
    } else if (wasPreviouslyDone && hasAnyTelemetryData && metRequiredCount < requiredAttributes.length) {
      // DONE (any source) + Has Data + Criteria Failed -> IN_PROGRESS
      newStatus = 'IN_PROGRESS';
    } else if (hasAnyTelemetryData && requiredWithDataCount > 0) {
      // Has telemetry data but doesn't meet all criteria (and wasn't previously done)
      newStatus = 'IN_PROGRESS';
    } else if (!hasAnyTelemetryData && !wasPreviouslyDone) {
      // No telemetry data at all and not previously done
      newStatus = 'NOT_STARTED';
    }
  } else if (attributes.length > 0) {
    // No required attributes, but has optional telemetry attributes
    if (wasPreviouslyDoneByTelemetry && !hasAnyTelemetryData) {
      newStatus = 'NO_LONGER_USING';
    } else if (wasPreviouslyDoneByUser && !hasAnyTelemetryData) {
      newStatus = 'DONE';
    } else if (wasPreviouslyDone && hasAnyTelemetryData && metCount === 0) {
      // DONE + Has Data + No criteria met -> NO_LONGER_USING? 
      // User said "if criteria fails - it should go to in progress".
      // But for optional attributes, usually 0 met means no usage.
      // Let's stick to IN_PROGRESS for consistency with required logic if that's what user wants,
      // OR keep NO_LONGER_USING if it implies "stopped using".
      // User said: "if criteria fails - it should go to in progress".
      newStatus = 'IN_PROGRESS';
    } else if (hasAnyTelemetryData && metCount > 0) {
      newStatus = 'DONE';
    } else if (hasAnyTelemetryData) {
      newStatus = 'IN_PROGRESS';
    }
  }

  return {
    newStatus,
    shouldUpdate: newStatus !== task.status,
    evaluationDetails: {
      totalAttributes: attributes.length,
      requiredAttributes: requiredAttributes.length,
      metCount,
      metRequiredCount,
      hasAnyTelemetryData,
      requiredWithDataCount,
      wasPreviouslyDoneByTelemetry,
      wasPreviouslyDoneByUser
    }
  };
}