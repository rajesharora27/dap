/**
 * Telemetry GraphQL Resolvers
 * 
 * This module contains all GraphQL resolvers for telemetry-related operations.
 * It uses the TelemetryService for business logic and provides clean error handling.
 * 
 * Features:
 * - Type-safe resolvers with comprehensive error handling
 * - Integration with audit logging and user authentication
 * - Optimized queries with proper includes and ordering
 * - Batch operations support
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */

import { ensureRole } from '../../shared/auth/auth-helpers';
import { TelemetryService } from './telemetry.service';
import { prisma } from '../../shared/graphql/context';
import { evaluateTelemetryAttribute } from './evaluation-engine';

/**
 * Telemetry Attribute type resolvers
 */
export const TelemetryAttributeResolvers = {
    task: async (parent: any) => {
        try {
            return await prisma.task.findUnique({ where: { id: parent.taskId } });
        } catch (error) {
            console.error('Error resolving telemetry attribute task:', error);
            return null;
        }
    },

    values: async (parent: any, { limit = 50 }: any) => {
        try {
            return await TelemetryService.getValuesForAttribute(parent.id, Math.min(limit, 200));
        } catch (error) {
            console.error('Error resolving telemetry attribute values:', error);
            return [];
        }
    },

    currentValue: async (parent: any) => {
        try {
            const values = await TelemetryService.getValuesForAttribute(parent.id, 1);
            return values.length > 0 ? values[0] : null;
        } catch (error) {
            console.error('Error resolving telemetry attribute current value:', error);
            return null;
        }
    },

    isSuccessful: async (parent: any) => {
        try {
            const result = await evaluateTelemetryAttribute(parent);
            return result.success;
        } catch (error) {
            console.error('Error evaluating telemetry attribute success:', error);
            return false;
        }
    }
};

/**
 * Telemetry Value type resolvers
 */
export const TelemetryValueResolvers = {
    attribute: async (parent: any) => {
        try {
            return await TelemetryService.getAttributeById(parent.attributeId, false);
        } catch (error) {
            console.error('Error resolving telemetry value attribute:', error);
            return null;
        }
    }
};

/**
 * Telemetry Query resolvers
 */
export const TelemetryQueryResolvers = {
    telemetryAttribute: async (_: any, { id }: any) => {
        try {
            return await TelemetryService.getAttributeById(id, true);
        } catch (error) {
            console.error('Error fetching telemetry attribute:', error);
            return null;
        }
    },

    telemetryAttributes: async (_: any, { taskId }: any) => {
        try {
            return await TelemetryService.getAttributesForTask(taskId, true);
        } catch (error) {
            console.error('Error fetching telemetry attributes:', error);
            return [];
        }
    },

    telemetryValue: async (_: any, { id }: any) => {
        try {
            return await prisma.telemetryValue.findUnique({
                where: { id },
                include: { attribute: true }
            });
        } catch (error) {
            console.error('Error fetching telemetry value:', error);
            return null;
        }
    },

    telemetryValues: async (_: any, { attributeId, limit = 50 }: any) => {
        try {
            return await TelemetryService.getValuesForAttribute(attributeId, limit);
        } catch (error) {
            console.error('Error fetching telemetry values:', error);
            return [];
        }
    },

    telemetryValuesByBatch: async (_: any, { batchId }: any) => {
        try {
            return await prisma.telemetryValue.findMany({
                where: { batchId },
                orderBy: { createdAt: 'desc' },
                include: { attribute: true }
            });
        } catch (error) {
            console.error('Error fetching telemetry values by batch:', error);
            return [];
        }
    }
};

/**
 * Telemetry Mutation resolvers
 */
export const TelemetryMutationResolvers = {
    createTelemetryAttribute: async (_: any, { input }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            console.log(`[Backend] Creating telemetry attribute "${input.name}"`);
            console.log(`[Backend] Raw successCriteria input:`, input.successCriteria);
            console.log(`[Backend] successCriteria type:`, typeof input.successCriteria);

            let parsedCriteria = undefined;
            if (input.successCriteria) {
                try {
                    parsedCriteria = JSON.parse(input.successCriteria);
                    console.log(`[Backend] Parsed successCriteria:`, JSON.stringify(parsedCriteria, null, 2));
                    console.log(`[Backend] Parsed keys:`, Object.keys(parsedCriteria));
                } catch (e) {
                    console.error(`[Backend] Failed to parse successCriteria:`, e);
                }
            }

            return await TelemetryService.createAttribute(
                input.taskId,
                {
                    name: input.name,
                    description: input.description,
                    dataType: input.dataType,
                    successCriteria: parsedCriteria,
                    order: input.order,
                    isRequired: input.isRequired
                },
                ctx.user?.id
            );
        } catch (error) {
            console.error('Error creating telemetry attribute:', error);
            throw new Error(`Failed to create telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    updateTelemetryAttribute: async (_: any, { id, input }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            console.log(`[Backend] Updating telemetry attribute ID ${id}, name "${input.name}"`);
            console.log(`[Backend] Raw successCriteria input:`, input.successCriteria);
            console.log(`[Backend] successCriteria type:`, typeof input.successCriteria);

            let parsedCriteria = undefined;
            if (input.successCriteria) {
                try {
                    parsedCriteria = JSON.parse(input.successCriteria);
                    console.log(`[Backend] Parsed successCriteria:`, JSON.stringify(parsedCriteria, null, 2));
                    console.log(`[Backend] Parsed keys:`, Object.keys(parsedCriteria));
                } catch (e) {
                    console.error(`[Backend] Failed to parse successCriteria:`, e);
                }
            }

            return await TelemetryService.updateAttribute(
                id,
                {
                    name: input.name,
                    description: input.description,
                    dataType: input.dataType,
                    successCriteria: parsedCriteria,
                    order: input.order,
                    isRequired: input.isRequired
                },
                ctx.user?.id
            );
        } catch (error) {
            console.error('Error updating telemetry attribute:', error);
            throw new Error(`Failed to update telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    deleteTelemetryAttribute: async (_: any, { id }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            const success = await TelemetryService.deleteAttribute(id, ctx.user?.id);
            return success;
        } catch (error) {
            console.error('Error deleting telemetry attribute:', error);
            throw new Error(`Failed to delete telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    addTelemetryValue: async (_: any, { input }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            return await TelemetryService.addValue(
                input.attributeId,
                {
                    value: input.value,
                    notes: input.notes,
                    batchId: input.batchId
                },
                ctx.user?.id
            );
        } catch (error) {
            console.error('Error adding telemetry value:', error);
            throw new Error(`Failed to add telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    addBatchTelemetryValues: async (_: any, { input }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            return await TelemetryService.addBatchValues(input, ctx.user?.id);
        } catch (error) {
            console.error('Error adding batch telemetry values:', error);
            throw new Error(`Failed to add batch telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    updateTelemetryValue: async (_: any, { id, value, notes }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            return await TelemetryService.updateValue(
                id,
                { value, notes },
                ctx.user?.id
            );
        } catch (error) {
            console.error('Error updating telemetry value:', error);
            throw new Error(`Failed to update telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    },

    deleteTelemetryValue: async (_: any, { id }: any, ctx: any) => {
        ensureRole(ctx, ['ADMIN', 'SME']);
        try {
            const success = await TelemetryService.deleteValue(id, ctx.user?.id);
            return success;
        } catch (error) {
            console.error('Error deleting telemetry value:', error);
            throw new Error(`Failed to delete telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
};

/**
 * Task resolver extensions for telemetry
 */
export const TaskTelemetryResolvers = {
    telemetryAttributes: async (parent: any) => {
        try {
            return await TelemetryService.getAttributesForTask(parent.id, true);
        } catch (error) {
            console.error('Error resolving task telemetry attributes:', error);
            return [];
        }
    },

    isCompleteBasedOnTelemetry: async (parent: any) => {
        try {
            const summary = await TelemetryService.getTaskCompletionSummary(parent.id);
            return summary.isComplete;
        } catch (error) {
            console.error('Error resolving task telemetry completion:', error);
            return false;
        }
    },

    telemetryCompletionPercentage: async (parent: any) => {
        try {
            const summary = await TelemetryService.getTaskCompletionSummary(parent.id);
            return summary.completionPercentage;
        } catch (error) {
            console.error('Error resolving task telemetry completion percentage:', error);
            return 0;
        }
    }
};

// Customer Telemetry Resolvers definitions
// These were likely missing in the original file I read (as it didn't seem to include them),
// but we have customer-telemetry services.
// I should check if there were CustomerTelemetry resolvers in index.ts or another file.
// The grep showed:
// "CustomerTelemetryAttributeResolvers": ...
// "CustomerTelemetryValueResolvers": ...
// in backend/src/schema/resolvers/index.ts.
// It seems they were inline in index.ts or imported from somewhere else.
// I should check index.ts to see where they are coming from.
