import { prisma } from '../../shared/graphql/context';
import { logAudit } from '../../shared/utils/audit';

// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';

export class CustomerAdoptionService {
    /**
     * Syncs a customer's adoption plan with the latest product definition.
     * This includes:
     * 1. Syncing entitlements (outcomes/releases)
     * 2. Syncing tags
     * 3. Syncing tasks (adding new, updating existing, removing deletion)
     * 4. Recalculating progress
     */
    static async syncAdoptionPlan(userId: string | undefined, adoptionPlanId: string) {
        console.log(`=== SYNC ADOPTION PLAN START: ${adoptionPlanId} ===`);

        const plan = await prisma.adoptionPlan.findUnique({
            where: { id: adoptionPlanId },
            include: {
                customerProduct: {
                    include: {
                        product: {
                            include: {
                                tasks: {
                                    where: { deletedAt: null },
                                    include: {
                                        telemetryAttributes: true,
                                        outcomes: true,
                                        releases: true,
                                        taskTags: true,
                                    },
                                },
                                outcomes: true,
                                releases: true,
                            },
                        },
                    },
                },
                tasks: {
                    include: {
                        telemetryAttributes: true,
                        outcomes: true,
                        releases: true,
                    },
                },
            },
        });

        if (!plan) {
            throw new Error('Adoption plan not found');
        }

        const { customerProduct } = plan;
        const product = customerProduct.product;

        // ============================================
        // STEP 1: SYNC ENTITLEMENTS (copy ALL from product)
        // ============================================
        const allProductOutcomeIds = product.outcomes.map((o: any) => o.id);
        const allProductReleaseIds = product.releases.map((r: any) => r.id);

        console.log(`STEP 1: Syncing entitlements - ${allProductOutcomeIds.length} outcomes, ${allProductReleaseIds.length} releases`);

        // Update CustomerProduct entitlements
        await prisma.customerProduct.update({
            where: { id: customerProduct.id },
            data: {
                selectedOutcomes: allProductOutcomeIds,
                selectedReleases: allProductReleaseIds,
            },
        });

        // ============================================
        // STEP 1.5: SYNC TAGS
        // ============================================
        console.log(`STEP 1.5: Syncing tags for customerProduct ${customerProduct.id}`);
        await prisma.customerProductTag.deleteMany({ where: { customerProductId: customerProduct.id } });

        const productTags = await prisma.productTag.findMany({ where: { productId: product.id } });
        console.log(`  Found ${productTags.length} product tags to sync`);
        const tagMap = new Map<string, string>();

        for (const tag of productTags) {
            const newTag = await prisma.customerProductTag.create({
                data: {
                    customerProductId: customerProduct.id,
                    sourceTagId: tag.id,
                    name: tag.name,
                    description: tag.description,
                    color: tag.color,
                    displayOrder: tag.displayOrder
                }
            });
            tagMap.set(tag.id, newTag.id);
        }
        console.log(`STEP 1.5 DONE: Tag Map size: ${tagMap.size}`);

        // ============================================
        // STEP 2: SYNC TASKS (match by license level only)
        // ============================================
        // Get ALL product tasks that match the license level (no outcome/release filtering)
        const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];
        const customerLicenseIndex = licenseLevels.indexOf(customerProduct.licenseLevel.toUpperCase());

        const eligibleProductTasks = product.tasks.filter((task: any) => {
            const taskLicenseIndex = licenseLevels.indexOf(task.licenseLevel.toUpperCase());
            return taskLicenseIndex <= customerLicenseIndex; // Task license <= customer license
        });

        console.log(`STEP 2: Product has ${product.tasks.length} tasks, ${eligibleProductTasks.length} eligible for license ${customerProduct.licenseLevel}`);

        const productTaskIds = eligibleProductTasks.map((t: any) => t.id);
        const existingCustomerTasks = plan.tasks as any[];
        const existingTaskMap = new Map<string, any>(existingCustomerTasks.map((t: any) => [t.originalTaskId, t]));

        // Track counts
        let tasksRemoved = 0;
        let tasksAdded = 0;
        let tasksUpdated = 0;

        // Remove tasks that no longer exist in product
        for (const customerTask of existingCustomerTasks) {
            if (!productTaskIds.includes(customerTask.originalTaskId)) {
                console.log(`  Removing task: ${customerTask.name} (originalTaskId: ${customerTask.originalTaskId})`);
                await prisma.customerTask.delete({ where: { id: customerTask.id } });
                tasksRemoved++;
            }
        }

        // Add or update tasks from product
        for (const productTask of eligibleProductTasks) {
            const existingTask = existingTaskMap.get(productTask.id);

            if (existingTask) {
                // UPDATE existing task (preserve status fields)
                // console.log(`  Updating task: ${productTask.name}`);
                const taskData = CustomerAdoptionService.getTaskDataForSync(productTask);
                // Explicitly remove rawTelemetryMapping if it somehow slipped through
                delete (taskData as any).rawTelemetryMapping;

                await prisma.customerTask.update({
                    where: { id: existingTask.id },
                    data: {
                        ...taskData,
                        sequenceNumber: productTask.sequenceNumber, // Explicitly sync sequence
                        // Status fields are NOT updated - they are preserved
                    },
                });

                // Sync telemetry attributes
                const productAttrIds = productTask.telemetryAttributes.map((a: any) => a.id);
                await prisma.customerTelemetryAttribute.deleteMany({
                    where: { customerTaskId: existingTask.id, originalAttributeId: { notIn: productAttrIds } },
                });

                for (const attr of productTask.telemetryAttributes) {
                    const existingAttr = await prisma.customerTelemetryAttribute.findFirst({
                        where: { customerTaskId: existingTask.id, originalAttributeId: attr.id },
                    });
                    if (existingAttr) {
                        await prisma.customerTelemetryAttribute.update({
                            where: { id: existingAttr.id },
                            data: {
                                name: attr.name, description: attr.description, dataType: attr.dataType,
                                isRequired: attr.isRequired, successCriteria: attr.successCriteria,
                                order: attr.order, isActive: attr.isActive,
                            },
                        });
                    } else {
                        await prisma.customerTelemetryAttribute.create({
                            data: {
                                customerTaskId: existingTask.id, originalAttributeId: attr.id,
                                name: attr.name, description: attr.description, dataType: attr.dataType,
                                isRequired: attr.isRequired, successCriteria: attr.successCriteria,
                                order: attr.order, isActive: attr.isActive,
                            },
                        });
                    }
                }

                // Sync outcomes - delete and recreate
                await prisma.customerTaskOutcome.deleteMany({ where: { customerTaskId: existingTask.id } });
                for (const to of productTask.outcomes) {
                    await prisma.customerTaskOutcome.create({ data: { customerTaskId: existingTask.id, outcomeId: to.outcomeId } });
                }

                // Sync releases - delete and recreate
                await prisma.customerTaskRelease.deleteMany({ where: { customerTaskId: existingTask.id } });
                for (const tr of productTask.releases) {
                    await prisma.customerTaskRelease.create({ data: { customerTaskId: existingTask.id, releaseId: tr.releaseId } });
                }

                // Sync Tags
                await prisma.customerTaskTag.deleteMany({ where: { customerTaskId: existingTask.id } });
                if (productTask.taskTags && productTask.taskTags.length > 0) {
                    for (const tt of productTask.taskTags) {
                        const newTagId = tagMap.get(tt.tagId);
                        if (newTagId) {
                            await prisma.customerTaskTag.create({
                                data: { customerTaskId: existingTask.id, tagId: newTagId }
                            });
                        }
                    }
                }

                tasksUpdated++;
            } else {
                // ADD new task
                console.log(`  Adding task: ${productTask.name}`);
                const taskData = CustomerAdoptionService.getTaskDataForSync(productTask);
                const newTask = await prisma.customerTask.create({
                    data: {
                        ...taskData,
                        sequenceNumber: productTask.sequenceNumber, // Explicitly set sequence
                        adoptionPlanId: plan.id,
                        originalTaskId: productTask.id,
                        status: 'NOT_STARTED',
                        statusUpdateSource: 'SYSTEM',
                    },
                });

                // Copy telemetry attributes
                for (const attr of productTask.telemetryAttributes) {
                    await prisma.customerTelemetryAttribute.create({
                        data: {
                            customerTaskId: newTask.id, originalAttributeId: attr.id,
                            name: attr.name, description: attr.description, dataType: attr.dataType,
                            isRequired: attr.isRequired, successCriteria: attr.successCriteria,
                            order: attr.order, isActive: attr.isActive,
                        },
                    });
                }

                // Copy outcomes
                for (const to of productTask.outcomes) {
                    await prisma.customerTaskOutcome.create({ data: { customerTaskId: newTask.id, outcomeId: to.outcomeId } });
                }

                // Copy releases
                for (const tr of productTask.releases) {
                    await prisma.customerTaskRelease.create({ data: { customerTaskId: newTask.id, releaseId: tr.releaseId } });
                }

                // Copy Tags
                if (productTask.taskTags && productTask.taskTags.length > 0) {
                    for (const tt of productTask.taskTags) {
                        const newTagId = tagMap.get(tt.tagId);
                        if (newTagId) {
                            await prisma.customerTaskTag.create({
                                data: { customerTaskId: newTask.id, tagId: newTagId }
                            });
                        }
                    }
                }

                tasksAdded++;
            }
        }

        // ============================================
        // STEP 3: UPDATE ADOPTION PLAN
        // ============================================
        const finalTasks = await prisma.customerTask.findMany({ where: { adoptionPlanId } });
        const progress = CustomerAdoptionService.calculateProgress(finalTasks);

        const updatedPlan = await prisma.adoptionPlan.update({
            where: { id: adoptionPlanId },
            data: {
                ...progress,
                selectedOutcomes: allProductOutcomeIds,
                selectedReleases: allProductReleaseIds,
                productName: product.name,
                licenseLevel: customerProduct.licenseLevel,
                lastSyncedAt: new Date(),
            },
            include: {
                customerProduct: { include: { customer: true, product: true, tags: true } },
                tasks: {
                    include: {
                        telemetryAttributes: true,
                        outcomes: { include: { outcome: true } },
                        releases: { include: { release: true } },
                    },
                    orderBy: { sequenceNumber: 'asc' },
                },
            },
        });

        console.log(`=== SYNC COMPLETE: removed ${tasksRemoved}, added ${tasksAdded}, updated ${tasksUpdated} tasks ===`);

        await logAudit('SYNC_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlanId, {
            tasksRemoved, tasksAdded, tasksUpdated,
            outcomes: allProductOutcomeIds.length,
            releases: allProductReleaseIds.length
        }, userId);

        return updatedPlan;
    }

    // Helper function to calculate progress
    static calculateProgress(tasks: any[]): {
        totalTasks: number;
        completedTasks: number;
        totalWeight: number;
        completedWeight: number;
        progressPercentage: number;
    } {
        // Filter out NOT_APPLICABLE tasks
        const applicableTasks = tasks.filter(t => t.status !== 'NOT_APPLICABLE');

        const totalTasks = applicableTasks.length;
        const completedTasks = applicableTasks.filter(t => t.status === 'COMPLETED' || t.status === 'DONE').length;

        const totalWeight = applicableTasks.reduce((sum, task) => {
            const weight = typeof task.weight === 'object' && 'toNumber' in task.weight
                ? task.weight.toNumber()
                : Number(task.weight || 0);
            return sum + weight;
        }, 0);

        const completedWeight = applicableTasks
            .filter(t => t.status === 'COMPLETED' || t.status === 'DONE')
            .reduce((sum, task) => {
                const weight = typeof task.weight === 'object' && 'toNumber' in task.weight
                    ? task.weight.toNumber()
                    : Number(task.weight || 0);
                return sum + weight;
            }, 0);

        const progressPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;

        return {
            totalTasks,
            completedTasks,
            totalWeight,
            completedWeight,
            progressPercentage: Math.round(progressPercentage * 100) / 100, // Round to 2 decimals
        };
    }

    /**
     * Extracts base task fields from a Product/Solution Task for syncing to a Customer Task.
     */
    static getTaskDataForSync(task: any) {
        const {
            id,
            productId,
            solutionId,
            createdAt,
            updatedAt,
            deletedAt,
            telemetryAttributes,
            outcomes,
            releases,
            taskTags,
            solutionTaskTags,
            status, // From existing customer task if present
            adoptionPlanId,
            originalTaskId,
            rawTelemetryMapping,
            completedReason, // Exclude this
            completedAt,     // Exclude this
            softDeleteQueued,
            ...baseFields
        } = task;

        return baseFields;
    }
}
