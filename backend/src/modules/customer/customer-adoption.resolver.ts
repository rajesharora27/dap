import { prisma } from '../../shared/graphql/context';
import { ensureRole } from '../../shared/auth/auth-helpers';
import { logAudit } from '../../shared/utils/audit';
import { LicenseLevel } from '@prisma/client';

import * as fs from 'fs';
import * as path from 'path';
import { SolutionService } from '../solution/solution.service';
import { CustomerAdoptionService } from './customer-adoption.service';


// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';


function evaluateCriteria(criteria: any, value: any): boolean {
  try {
    if (!criteria || typeof criteria !== 'object') return false;

    const { operator, targetValue, conditions } = criteria;

    // Handle AND/OR logic for multiple conditions
    if (conditions && Array.isArray(conditions)) {
      if (operator === 'AND') {
        return conditions.every((cond: any) => evaluateCriteria(cond, value));
      } else if (operator === 'OR') {
        return conditions.some((cond: any) => evaluateCriteria(cond, value));
      }
    }

    // Handle single condition
    if (!operator || targetValue === undefined) return false;

    switch (operator.toUpperCase()) {
      case 'EQUALS':
      case 'EQ':
        return value === targetValue;
      case 'NOT_EQUALS':
      case 'NE':
        return value !== targetValue;
      case 'GREATER_THAN':
      case 'GT':
        return Number(value) > Number(targetValue);
      case 'GREATER_THAN_OR_EQUAL':
      case 'GTE':
        return Number(value) >= Number(targetValue);
      case 'LESS_THAN':
      case 'LT':
        return Number(value) < Number(targetValue);
      case 'LESS_THAN_OR_EQUAL':
      case 'LTE':
        return Number(value) <= Number(targetValue);
      case 'CONTAINS':
        return String(value).includes(String(targetValue));
      case 'STARTS_WITH':
        return String(value).startsWith(String(targetValue));
      case 'ENDS_WITH':
        return String(value).endsWith(String(targetValue));
      case 'IS_TRUE':
        return value === true;
      case 'IS_FALSE':
        return value === false;
      case 'EXISTS':
        return value !== null && value !== undefined;
      default:
        return false;
    }
  } catch (error) {
    console.error('Error evaluating criteria:', error);
    return false;
  }
}

// Helper function to check if task should be included based on license and outcomes
function shouldIncludeTask(
  task: any,
  customerLicenseLevel: LicenseLevel,
  selectedOutcomeIds: string[],
  selectedReleaseIds?: string[]
): boolean {
  // Check license level (hierarchical comparison using case-insensitive matching)
  // Support both uppercase enum (ESSENTIAL) and capitalized (Essential) formats
  const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];

  const customerLevel = licenseLevels.indexOf(customerLicenseLevel.toUpperCase());
  const taskLevel = licenseLevels.indexOf(task.licenseLevel.toUpperCase());

  // If license level not found in hierarchy, skip this task (safety check)
  if (taskLevel === -1) {
    console.warn(`Unknown task license level: ${task.licenseLevel}`);
    return false;
  }

  if (customerLevel === -1) {
    console.warn(`Unknown customer license level: ${customerLicenseLevel}`);
    return false;
  }

  if (taskLevel > customerLevel) {
    return false; // Task requires higher license
  }

  // Check if task belongs to selected outcomes (if outcomes are specified)
  if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
    // Get task outcomes
    const taskOutcomeIds = task.outcomes?.map((o: any) => o.outcomeId) || [];

    // If task has specific outcomes, it must match one of the selected outcomes
    // If task has NO outcomes (generic task), it is applicable to all outcomes
    if (taskOutcomeIds.length > 0) {
      const hasMatchingOutcome = taskOutcomeIds.some((oid: string) => selectedOutcomeIds.includes(oid));
      if (!hasMatchingOutcome) {
        return false;
      }
    }
  }

  // Check if task belongs to selected releases (if releases are specified)
  if (selectedReleaseIds && selectedReleaseIds.length > 0) {
    // Get task releases
    const taskReleaseIds = task.releases?.map((r: any) => r.releaseId) || [];

    // If task has specific releases, it must match one of the selected releases
    // If task has NO releases (generic task), it is applicable to all releases
    if (taskReleaseIds.length > 0) {
      const hasMatchingRelease = taskReleaseIds.some((rid: string) => selectedReleaseIds.includes(rid));
      if (!hasMatchingRelease) {
        return false;
      }
    }
  }

  return true;
}

export const CustomerAdoptionQueryResolvers = {
  customer: async (_: any, { id }: any, ctx: any) => {
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        products: {
          include: {
            product: true,
            adoptionPlan: {
              include: {
                tasks: true,
              },
            },
          },
        },
        solutions: {
          include: {
            solution: true,
          },
        },
      },
    });
    return customer;
  },

  customerSolution: async (_: any, { id }: any, ctx: any) => {
    const customerSolution = await prisma.customerSolution.findUnique({
      where: { id },
      include: {
        customer: true,
        solution: {
          include: {
            outcomes: true,
            releases: true,
            products: {
              include: {
                product: true
              }
            }
          }
        },
        adoptionPlan: true
      }
    });
    return customerSolution;
  },

  adoptionPlan: async (_: any, { id }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
            tags: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: {
              include: {
                outcome: true,
              },
            },
            releases: {
              include: {
                release: true,
              },
            },
            taskTags: {
              include: {
                tag: true,
              },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    return plan;
  },

  adoptionPlansForCustomer: async (_: any, { customerId }: any, ctx: any) => {
    const customerProducts = await prisma.customerProduct.findMany({
      where: { customerId },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
      },
    });

    return customerProducts
      .filter((cp: any) => cp.adoptionPlan)
      .map((cp: any) => cp.adoptionPlan);
  },

  customerTask: async (_: any, { id }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            customerProduct: {
              include: {
                customer: true,
                product: true,
              },
            },
          },
        },
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
            },
          },
          orderBy: { order: 'asc' },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
    });
    return task;
  },

  customerTasksForPlan: async (_: any, { adoptionPlanId, status }: any, ctx: any) => {
    const where: any = { adoptionPlanId };
    if (status) {
      where.status = status;
    }

    const tasks = await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
    return tasks;
  },

  customerTelemetryDatabase: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    const where: any = {};

    if (customerProductId) {
      where.customerProductId = customerProductId;
    } else if (customerId) {
      where.customerId = customerId;
    }

    const customerProducts = await prisma.customerProduct.findMany({
      where,
      include: {
        customer: true,
        product: true,
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: {
                  where: { isActive: true },
                  include: {
                    values: {
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    const records: any[] = [];

    for (const cp of customerProducts) {
      for (const plan of cp.adoptionPlans) {
        for (const task of plan.tasks) {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            records.push({
              customerId: cp.customer.id,
              customerName: cp.customer.name,
              customerProductId: cp.id,
              productId: cp.product.id,
              productName: cp.product.name,
              licenseLevel: cp.licenseLevel,
              adoptionPlanId: plan.id,
              taskId: task.id,
              taskName: task.name,
              taskSequenceNumber: task.sequenceNumber,
              attributeId: attr.id,
              attributeName: attr.name,
              attributeType: attr.attributeType,
              attributeRequired: attr.isRequired,
              attributeCriteria: attr.successCriteria,
              latestValue: latestValue?.value || null,
              latestValueDate: latestValue?.createdAt || null,
              criteriaMet,
              taskStatus: task.status,
            });
          }
        }
      }
    }

    return records;
  },
};

export const CustomerAdoptionMutationResolvers = {
  assignProductToCustomer: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const { customerId, productId, name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;

    // Note: Removed unique constraint check - customers can now have the same product multiple times
    // Each assignment must be differentiated by a required name

    // Validate product exists
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });

    if (!product) {
      throw new Error('Product not found');
    }

    // Validate outcome IDs if provided
    if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId },
      });

      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }

    // Validate release IDs if provided
    if (selectedReleaseIds && selectedReleaseIds.length > 0) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds }, productId },
      });

      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }

    // Convert GraphQL enum (PascalCase) to Prisma enum (UPPERCASE)
    const prismaLicenseLevel = licenseLevel.toUpperCase() as 'ESSENTIAL' | 'ADVANTAGE' | 'SIGNATURE';

    // Create customer product assignment
    const customerProduct = await prisma.customerProduct.create({
      data: {
        customerId,
        productId,
        name, // Required field
        licenseLevel: prismaLicenseLevel,
        selectedOutcomes: selectedOutcomeIds || [],
        selectedReleases: selectedReleaseIds || [],
      },
      include: {
        customer: true,
        product: true,
        adoptionPlan: true,
      },
    });

    await logAudit('ASSIGN_PRODUCT_TO_CUSTOMER', 'CustomerProduct', customerProduct.id, { input }, ctx.user?.id);

    return customerProduct;
  },

  updateCustomerProduct: async (_: any, { id, input }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const { name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;

    const before = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    if (!before) {
      throw new Error('Customer product assignment not found');
    }

    // Validate outcome IDs if provided
    if (selectedOutcomeIds) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId: before.productId },
      });

      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }

    // Validate release IDs if provided
    if (selectedReleaseIds) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds }, productId: before.productId },
      });

      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name || null;
    if (licenseLevel) updateData.licenseLevel = licenseLevel.toUpperCase();
    if (selectedOutcomeIds !== undefined) updateData.selectedOutcomes = selectedOutcomeIds;
    if (selectedReleaseIds !== undefined) updateData.selectedReleases = selectedReleaseIds;

    // Update customer product first
    const updated = await prisma.customerProduct.update({
      where: { id },
      data: updateData,
      include: {
        customer: true,
        tags: true,
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });

    // If adoption plan exists, update it intelligently to preserve status and telemetry
    // Instead of deleting and recreating, we'll add/remove tasks as needed (like sync does)
    if (before.adoptionPlan) {
      console.log(`Updating adoption plan for customer product ${id} due to entitlement changes`);

      const adoptionPlanId = before.adoptionPlan.id;

      // Get the new license level, outcomes, and releases from the updated product
      const newLicenseLevel = updated.licenseLevel;
      const newSelectedOutcomeIds = updated.selectedOutcomes as string[] || [];
      const newSelectedReleaseIds = updated.selectedReleases as string[] || [];

      // Filter tasks based on NEW license level, outcomes, and releases
      const eligibleProductTasks = updated.product.tasks.filter((task: any) =>
        shouldIncludeTask(task, newLicenseLevel, newSelectedOutcomeIds, newSelectedReleaseIds)
      );

      const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
      const currentCustomerTaskOriginalIds = before.adoptionPlan.tasks.map((t: any) => t.originalTaskId);

      // Find tasks to remove (no longer eligible)
      const tasksToRemove = before.adoptionPlan.tasks.filter(
        (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
      );

      // Find tasks to add (newly eligible)
      const tasksToAdd = eligibleProductTasks.filter(
        (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
      );

      // Remove tasks that are no longer eligible
      for (const task of tasksToRemove) {
        await prisma.customerTask.delete({ where: { id: task.id } });
      }

      // Add new eligible tasks
      for (const task of tasksToAdd) {
        const customerTask = await prisma.customerTask.create({
          data: {
            adoptionPlanId: adoptionPlanId,
            originalTaskId: task.id,
            name: task.name,
            description: task.description,
            estMinutes: task.estMinutes,
            weight: task.weight,
            sequenceNumber: task.sequenceNumber,
            howToDoc: task.howToDoc,
            howToVideo: task.howToVideo,
            notes: task.notes,
            licenseLevel: task.licenseLevel,
            status: 'NOT_STARTED',
            statusUpdateSource: 'SYSTEM',
          },
        });

        // Copy telemetry attributes
        for (const attr of task.telemetryAttributes) {
          await prisma.customerTelemetryAttribute.create({
            data: {
              customerTaskId: customerTask.id,
              originalAttributeId: attr.id,
              name: attr.name,
              description: attr.description,
              dataType: attr.dataType,
              isRequired: attr.isRequired,
              successCriteria: attr.successCriteria,
              order: attr.order,
              isActive: attr.isActive,
            },
          });
        }

        // Copy outcome relationships
        for (const taskOutcome of task.outcomes) {
          await prisma.customerTaskOutcome.create({
            data: {
              customerTaskId: customerTask.id,
              outcomeId: taskOutcome.outcomeId,
            },
          });
        }

        // Copy release relationships
        for (const taskRelease of task.releases) {
          await prisma.customerTaskRelease.create({
            data: {
              customerTaskId: customerTask.id,
              releaseId: taskRelease.releaseId,
            },
          });
        }
      }

      // Recalculate progress based on remaining tasks
      const updatedTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId },
      });

      const progress = CustomerAdoptionService.calculateProgress(updatedTasks);

      // Update adoption plan metadata
      await prisma.adoptionPlan.update({
        where: { id: adoptionPlanId },
        data: {
          licenseLevel: newLicenseLevel,
          selectedOutcomes: newSelectedOutcomeIds,
          selectedReleases: newSelectedReleaseIds,
          ...progress,
          lastSyncedAt: new Date(),
        },
      });

      console.log(`Updated adoption plan: removed ${tasksToRemove.length} tasks, added ${tasksToAdd.length} tasks`);
    }

    await logAudit('UPDATE_CUSTOMER_PRODUCT', 'CustomerProduct', id, { before: { licenseLevel: before.licenseLevel, selectedOutcomes: before.selectedOutcomes }, after: { licenseLevel: updated.licenseLevel, selectedOutcomes: updated.selectedOutcomes } }, ctx.user?.id);

    // Return with fresh adoption plan data
    return await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        customer: true,
        product: true,
        adoptionPlan: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
                outcomes: {
                  include: { outcome: true },
                },
                releases: {
                  include: { release: true },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });
  },

  removeProductFromCustomerEnhanced: async (_: any, { id }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: { include: { tasks: true } },
        customerSolution: true, // Include the linked solution if it exists
        product: { select: { id: true, name: true } },
        customer: { select: { id: true, name: true } }
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }

    // Check if this product was created from a solution assignment
    if (customerProduct.customerSolutionId && customerProduct.customerSolution) {
      return {
        success: false,
        message: `This product cannot be removed independently because it was assigned as part of solution "${customerProduct.customerSolution.name}". Please remove the solution instead.`
      };
    }

    // Delete will cascade to adoption plan and tasks
    await prisma.customerProduct.delete({
      where: { id },
    });

    await logAudit('REMOVE_PRODUCT_FROM_CUSTOMER', 'CustomerProduct', id, {
      productName: customerProduct.product?.name,
      customerName: customerProduct.customer?.name,
      productId: customerProduct.productId,
      customerId: customerProduct.customerId
    }, ctx.user?.id);

    return { success: true, message: 'Product removed from customer successfully' };
  },

  createAdoptionPlan: async (_: any, { customerProductId }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
                taskTags: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }

    if (customerProduct.adoptionPlan) {
      throw new Error('Adoption plan already exists for this customer product');
    }

    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    const selectedReleaseIds = customerProduct.selectedReleases as string[] || [];

    // Filter tasks based on license level, outcomes, and releases
    const eligibleTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds, selectedReleaseIds)
    );

    // Calculate initial progress
    const progress = CustomerAdoptionService.calculateProgress(eligibleTasks.map((t: any) => ({ ...t, status: 'NOT_STARTED' })));

    // Create adoption plan
    const adoptionPlan = await prisma.adoptionPlan.create({
      data: {
        customerProductId,
        productId: customerProduct.productId,
        productName: customerProduct.product.name,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        selectedReleases: selectedReleaseIds,
        totalTasks: progress.totalTasks,
        completedTasks: 0,
        totalWeight: progress.totalWeight,
        completedWeight: 0,
        progressPercentage: 0,
        lastSyncedAt: new Date(),
      },
    });

    // Create Customer Product Tags
    const productTags = await prisma.productTag.findMany({ where: { productId: customerProduct.productId } });
    const tagMap = new Map<string, string>(); // sourceTagId -> newTagId

    for (const tag of productTags) {
      const newTag = await prisma.customerProductTag.create({
        data: {
          customerProductId,
          sourceTagId: tag.id,
          name: tag.name,
          description: tag.description,
          color: tag.color,
          displayOrder: tag.displayOrder
        }
      });
      tagMap.set(tag.id, newTag.id);
    }

    // Create customer tasks (snapshots of product tasks)
    for (const task of eligibleTasks) {
      const taskData = CustomerAdoptionService.getTaskDataForSync(task);
      const customerTask = await prisma.customerTask.create({
        data: {
          ...taskData,
          adoptionPlanId: adoptionPlan.id,
          originalTaskId: task.id,
          status: 'NOT_STARTED',
          statusUpdateSource: 'SYSTEM',
        },
      });

      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }

      // Copy outcome relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: {
            customerTaskId: customerTask.id,
            outcomeId: taskOutcome.outcomeId,
          },
        });
      }

      // Copy release relationships
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: {
            customerTaskId: customerTask.id,
            releaseId: taskRelease.releaseId,
          },
        });
      }

      // Copy tags
      if (task.taskTags) {
        for (const tt of task.taskTags) {
          const newTagId = tagMap.get(tt.tagId);
          if (newTagId) {
            await prisma.customerTaskTag.create({
              data: { customerTaskId: customerTask.id, tagId: newTagId }
            });
          }
        }
      }
    }

    await logAudit('CREATE_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlan.id, { customerProductId }, ctx.user?.id);

    // Fetch complete plan with relations
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlan.id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: {
              include: { outcome: true },
            },
            releases: {
              include: { release: true },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  syncAdoptionPlan: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);
    return CustomerAdoptionService.syncAdoptionPlan(ctx.user?.id, adoptionPlanId);
  },

  updateCustomerTaskStatus: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const { customerTaskId, status, notes, updateSource } = input;

    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: { adoptionPlan: true },
    });

    if (!task) {
      throw new Error('Customer task not found');
    }

    // Append new notes to existing notes with timestamp and status change
    let updatedNotes = task.statusNotes || '';
    if (notes && notes.trim()) {
      const timestamp = new Date().toISOString();
      const user = ctx.user?.id || 'unknown';
      const source = updateSource || 'MANUAL';
      const statusChange = `[${timestamp}] Status changed to ${status} by ${user} (via ${source}):\n${notes.trim()}\n\n`;
      updatedNotes = updatedNotes ? `${updatedNotes}${statusChange}` : statusChange;
    }

    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusUpdateSource: updateSource || 'MANUAL',
      statusNotes: updatedNotes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };

    const updated = await prisma.customerTask.update({
      where: { id: customerTaskId },
      data: updateData,
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });

    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: task.adoptionPlanId },
    });

    const progress = CustomerAdoptionService.calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: task.adoptionPlanId },
      data: progress,
    });

    // Check if this product is part of a solution and trigger solution sync
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { id: task.adoptionPlanId },
      include: {
        customerProduct: true
      }
    });

    if (adoptionPlan?.customerProduct) {
      // Check if this product name indicates it's part of a solution (format: "{SolutionName} - {ProductName}")
      const productName = adoptionPlan.customerProduct.name;
      if (productName.includes(' - ')) {
        // This product is part of a solution, find the solution adoption plan
        const solutionName = productName.split(' - ')[0];

        // Find the customer solution with this name
        const customerSolution = await prisma.customerSolution.findFirst({
          where: {
            customerId: adoptionPlan.customerProduct.customerId,
            name: solutionName
          },
          include: {
            adoptionPlan: true
          }
        });

        // If solution adoption plan exists, trigger lightweight sync
        if (customerSolution?.adoptionPlan) {
          await SolutionService.recalculateSolutionAdoptionPlanProgress(
            ctx.user?.id,
            customerSolution.adoptionPlan.id
          );
        }
      }
    }

    await logAudit('UPDATE_CUSTOMER_TASK_STATUS', 'CustomerTask', customerTaskId, { status, notes }, ctx.user?.id);

    return updated;
  },

  bulkUpdateCustomerTaskStatus: async (_: any, { adoptionPlanId, taskIds, status, notes }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    // Fetch existing tasks to preserve their notes
    const existingTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
        adoptionPlanId,
      },
    });

    // Update each task individually to append notes
    const timestamp = new Date().toISOString();
    const user = ctx.user?.id || 'unknown';
    const statusChange = notes && notes.trim()
      ? `[${timestamp}] Status changed to ${status} by ${user}:\n${notes.trim()}\n\n`
      : '';

    const updatePromises = existingTasks.map((task: any) => {
      const updatedNotes = statusChange
        ? (task.statusNotes || '') + statusChange
        : task.statusNotes;

      return prisma.customerTask.update({
        where: { id: task.id },
        data: {
          status,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: user,
          statusUpdateSource: 'MANUAL',
          statusNotes: updatedNotes,
          isComplete: status === 'DONE',
          completedAt: status === 'DONE' ? new Date() : null,
          completedBy: status === 'DONE' ? user : null,
        },
      });
    });

    await Promise.all(updatePromises);

    // Fetch updated tasks
    const updatedTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
      },
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });

    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });

    const progress = CustomerAdoptionService.calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: progress,
    });

    // Check if this product is part of a solution and trigger solution sync
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: true
      }
    });

    if (adoptionPlan?.customerProduct) {
      // Check if this product name indicates it's part of a solution (format: "{SolutionName} - {ProductName}")
      const productName = adoptionPlan.customerProduct.name;
      if (productName.includes(' - ')) {
        // This product is part of a solution, find the solution adoption plan
        const solutionName = productName.split(' - ')[0];

        // Find the customer solution with this name
        const customerSolution = await prisma.customerSolution.findFirst({
          where: {
            customerId: adoptionPlan.customerProduct.customerId,
            name: solutionName
          },
          include: {
            adoptionPlan: true
          }
        });

        // If solution adoption plan exists, trigger lightweight sync
        if (customerSolution?.adoptionPlan) {
          await SolutionService.recalculateSolutionAdoptionPlanProgress(
            ctx.user?.id,
            customerSolution.adoptionPlan.id
          );
        }
      }
    }

    await logAudit('BULK_UPDATE_CUSTOMER_TASK_STATUS', 'AdoptionPlan', adoptionPlanId, { taskIds, status, notes }, ctx.user?.id);

    return updatedTasks;
  },





  updateAdoptionPlanFilterPreference: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS', 'USER']);

    const { adoptionPlanId, filterReleases, filterOutcomes, filterTags } = input;

    // Verify the adoption plan exists
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
    });

    if (!adoptionPlan) {
      throw new Error('Adoption plan not found');
    }

    // Upsert the filter preference
    const filterPreference = await prisma.adoptionPlanFilterPreference.upsert({
      where: { adoptionPlanId },
      update: {
        filterReleases,
        filterOutcomes,
        filterTags,
      },
      create: {
        adoptionPlanId,
        filterReleases,
        filterOutcomes,
        filterTags,
      },
    });

    return filterPreference;
  },

  exportCustomerAdoptionToExcel: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const ExcelJS = await import('exceljs');

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        customer: true,
        product: true,
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product not found');
    }

    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { customerProductId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Customer Adoption Data');

    // Headers
    worksheet.columns = [
      { header: 'Customer ID', key: 'customerId', width: 20 },
      { header: 'Customer Name', key: 'customerName', width: 30 },
      { header: 'Product ID', key: 'productId', width: 20 },
      { header: 'Product Name', key: 'productName', width: 30 },
      { header: 'License Level', key: 'licenseLevel', width: 15 },
      { header: 'Task Sequence', key: 'taskSequence', width: 12 },
      { header: 'Task Name', key: 'taskName', width: 40 },
      { header: 'Task Status', key: 'taskStatus', width: 15 },
      { header: 'Telemetry Attribute', key: 'telemetryAttribute', width: 30 },
      { header: 'Attribute Type', key: 'attributeType', width: 15 },
      { header: 'Required', key: 'required', width: 10 },
      { header: 'Current Value', key: 'currentValue', width: 30 },
      { header: 'Last Updated', key: 'lastUpdated', width: 20 },
      { header: 'Criteria Met', key: 'criteriaMet', width: 12 },
    ];

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    };

    if (adoptionPlan.tasks && adoptionPlan.tasks.length > 0) {
      for (const task of adoptionPlan.tasks) {
        if (task.telemetryAttributes.length === 0) {
          // Task with no telemetry
          worksheet.addRow({
            customerId: customerProduct.customer.id,
            customerName: customerProduct.customer.name,
            productId: customerProduct.product.id,
            productName: customerProduct.product.name,
            licenseLevel: customerProduct.licenseLevel,
            taskSequence: task.sequenceNumber,
            taskName: task.name,
            taskStatus: task.status,
            telemetryAttribute: '',
            attributeType: '',
            required: '',
            currentValue: '',
            lastUpdated: '',
            criteriaMet: '',
          });
        } else {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            worksheet.addRow({
              customerId: customerProduct.customer.id,
              customerName: customerProduct.customer.name,
              productId: customerProduct.product.id,
              productName: customerProduct.product.name,
              licenseLevel: customerProduct.licenseLevel,
              taskSequence: task.sequenceNumber,
              taskName: task.name,
              taskStatus: task.status,
              telemetryAttribute: attr.name,
              attributeType: attr.attributeType,
              required: attr.isRequired ? 'Yes' : 'No',
              currentValue: latestValue ? JSON.stringify(latestValue.value) : '',
              lastUpdated: latestValue ? latestValue.createdAt.toISOString() : '',
              criteriaMet: criteriaMet === null ? '' : criteriaMet ? 'Yes' : 'No',
            });
          }
        }
      }
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const content = Buffer.from(buffer).toString('base64');
    const filename = `${customerProduct.customer.name}_${customerProduct.product.name}_adoption.xlsx`;

    await logAudit('EXPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { filename }, ctx.user?.id);

    return {
      filename,
      content,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      size: buffer.byteLength,
      stats: {
        tasksExported: adoptionPlan?.tasks.length || 0,
        customAttributesExported: 0,
        licensesExported: 0,
        outcomesExported: 0,
        releasesExported: 0,
        telemetryAttributesExported: adoptionPlan?.tasks.reduce((sum: number, t: any) => sum + t.telemetryAttributes.length, 0) || 0,
      },
    };
  },

  importCustomerAdoptionFromExcel: async (_: any, { content }: any, ctx: any) => {
    ensureRole(ctx, ['ADMIN', 'CSS']);

    const ExcelJS = await import('exceljs');
    const workbook = new ExcelJS.Workbook();
    const buffer = Buffer.from(content, 'base64');
    await workbook.xlsx.load(buffer.buffer as ArrayBuffer);

    const worksheet = workbook.getWorksheet('Customer Adoption Data');
    if (!worksheet) {
      throw new Error('Worksheet "Customer Adoption Data" not found');
    }

    const errors: any[] = [];
    const warnings: any[] = [];
    let telemetryValuesImported = 0;
    let taskStatusesUpdated = 0;
    let attributesCreated = 0;

    let customerId = '';
    let customerName = '';
    let customerProductId = '';
    let productName = '';

    const rows: any[] = [];
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header
      rows.push({
        rowNumber,
        customerId: row.getCell(1).value,
        customerName: row.getCell(2).value,
        productId: row.getCell(3).value,
        productName: row.getCell(4).value,
        licenseLevel: row.getCell(5).value,
        taskSequence: row.getCell(6).value,
        taskName: row.getCell(7).value,
        taskStatus: row.getCell(8).value,
        telemetryAttribute: row.getCell(9).value,
        attributeType: row.getCell(10).value,
        required: row.getCell(11).value,
        currentValue: row.getCell(12).value,
        lastUpdated: row.getCell(13).value,
        criteriaMet: row.getCell(14).value,
      });
    });

    if (rows.length === 0) {
      throw new Error('No data rows found in worksheet');
    }

    // Get customer and product from first row
    const firstRow = rows[0];
    customerId = firstRow.customerId;
    customerName = firstRow.customerName;
    productName = firstRow.productName;

    // Find customer product
    const customerProduct = await prisma.customerProduct.findFirst({
      where: {
        customerId: customerId,
        productId: firstRow.productId,
      },
      include: {
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
              },
            },
          },
        },
      },
    });

    if (!customerProduct) {
      throw new Error(`Customer product assignment not found for customer ${customerName} and product ${productName}`);
    }

    customerProductId = customerProduct.id;
    const adoptionPlan = customerProduct.adoptionPlans[0];

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    // Process each row
    for (const row of rows) {
      try {
        // Find task by sequence number
        const task = adoptionPlan.tasks.find((t: any) => t.sequenceNumber === Number(row.taskSequence));

        if (!task) {
          warnings.push({
            row: row.rowNumber,
            field: 'taskSequence',
            message: `Task with sequence ${row.taskSequence} not found`,
          });
          continue;
        }

        // Update task status if changed
        if (row.taskStatus && row.taskStatus !== task.status) {
          await prisma.customerTask.update({
            where: { id: task.id },
            data: {
              status: row.taskStatus as any,
              statusUpdatedBy: 'import',
              statusUpdateSource: 'IMPORT',
              statusUpdatedAt: new Date(),
            },
          });
          taskStatusesUpdated++;
        }

        // Process telemetry if present
        if (row.telemetryAttribute && row.currentValue) {
          // Find or create telemetry attribute
          let attribute = task.telemetryAttributes.find((a: any) => a.name === row.telemetryAttribute);

          if (!attribute) {
            attribute = await prisma.customerTelemetryAttribute.create({
              data: {
                customerTaskId: task.id,
                name: row.telemetryAttribute,
                attributeType: row.attributeType || 'TEXT',
                isRequired: row.required === 'Yes',
                isActive: true,
              },
            });
            attributesCreated++;
          }

          // Parse value
          let parsedValue: any;
          try {
            parsedValue = JSON.parse(row.currentValue);
          } catch {
            parsedValue = row.currentValue;
          }

          // Create telemetry value
          await prisma.customerTelemetryValue.create({
            data: {
              customerAttributeId: attribute.id,
              value: parsedValue,
              batchId: `import_${Date.now()}`,
            },
          });
          telemetryValuesImported++;
        }
      } catch (error: any) {
        errors.push({
          row: row.rowNumber,
          field: 'general',
          message: error.message,
        });
      }
    }

    // Recalculate progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: adoptionPlan.id },
    });

    const progress = CustomerAdoptionService.calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: adoptionPlan.id },
      data: progress,
    });

    await logAudit('IMPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { telemetryValuesImported, taskStatusesUpdated }, ctx.user?.id);

    return {
      success: errors.length === 0,
      customerId,
      customerName,
      customerProductId,
      productName,
      stats: {
        telemetryValuesImported,
        taskStatusesUpdated,
        attributesCreated,
      },
      errors,
      warnings,
    };
  },

  // Export telemetry template

};

// Field resolvers
export const CustomerProductWithPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  customerSolution: async (parent: any) => {
    if (!parent.customerSolutionId) return null;

    return await prisma.customerSolution.findUnique({
      where: { id: parent.customerSolutionId },
      include: {
        customer: true,
        solution: {
          include: {
            outcomes: true,
            releases: true,
            products: {
              include: {
                product: true
              }
            }
          }
        },
        adoptionPlan: true
      }
    });
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) {
      // If none selected (meaning ALL), fetch all for the product
      return await prisma.outcome.findMany({
        where: { productId: parent.productId },
        orderBy: { name: 'asc' },
      });
    }

    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) {
      // If none selected (meaning ALL), fetch all for the product
      return await prisma.release.findMany({
        where: { productId: parent.productId },
        orderBy: { name: 'asc' },
      });
    }

    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },
  adoptionPlan: async (parent: any) => {
    // Find the adoption plan for this customer product
    return await prisma.adoptionPlan.findUnique({
      where: { customerProductId: parent.id },
    });
  },
};

export const AdoptionPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) {
      // If none selected (meaning ALL), fetch all for the product
      return await prisma.outcome.findMany({
        where: { productId: parent.productId },
        orderBy: { name: 'asc' },
      });
    }

    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) {
      // If none selected (meaning ALL), fetch all for the product
      return await prisma.release.findMany({
        where: { productId: parent.productId },
        orderBy: { name: 'asc' },
      });
    }

    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },

  tasks: async (parent: any) => {
    // Return all tasks for this adoption plan
    return await prisma.customerTask.findMany({
      where: { adoptionPlanId: parent.id },
      orderBy: { sequenceNumber: 'asc' },
    });
  },

  tasksByStatus: async (parent: any, { status }: any) => {
    const where: any = { adoptionPlanId: parent.id };
    if (status) where.status = status;

    return await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
  },

  needsSync: async (parent: any) => {
    if (!parent.lastSyncedAt) return true;

    // Check if product has been updated since last sync
    const product = await prisma.product.findUnique({
      where: { id: parent.productId },
    });

    if (!product) return false;

    return product.updatedAt > parent.lastSyncedAt;
  },

  filterPreference: async (parent: any) => {
    // Return filter preference for this adoption plan, or null if none exists
    return await prisma.adoptionPlanFilterPreference.findUnique({
      where: { adoptionPlanId: parent.id },
    });
  },
};

export const CustomerTaskResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  telemetryAttributes: async (parent: any) => {
    // Return all telemetry attributes for this customer task
    return await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
      orderBy: { order: 'asc' },
    });
  },
  outcomes: async (parent: any) => {
    const taskOutcomes = await prisma.customerTaskOutcome.findMany({
      where: { customerTaskId: parent.id },
      include: { outcome: true },
    });

    return taskOutcomes.map((to: any) => to.outcome);
  },

  releases: async (parent: any) => {
    const taskReleases = await prisma.customerTaskRelease.findMany({
      where: { customerTaskId: parent.id },
      include: { release: true },
    });

    return taskReleases.map((tr: any) => tr.release);
  },

  telemetryProgress: async (parent: any) => {
    const attributes = await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
    });

    const totalAttributes = attributes.filter((a: any) => a.isActive).length;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive).length;
    const metAttributes = attributes.filter((a: any) => a.isMet && a.isActive).length;
    const metRequiredAttributes = attributes.filter((a: any) => a.isMet && a.isRequired && a.isActive).length;

    const completionPercentage = totalAttributes > 0 ? (metAttributes / totalAttributes) * 100 : 0;
    const allRequiredMet = requiredAttributes > 0 && metRequiredAttributes === requiredAttributes;

    return {
      totalAttributes,
      requiredAttributes,
      metAttributes,
      metRequiredAttributes,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
      allRequiredMet,
    };
  },

  tags: async (parent: any) => {
    try {
      // Optimization: If taskTags are already included in the parent (from findMany include), use them
      if (parent.taskTags) {
        // console.log('[DEBUG] Using pre-fetched tags for task:', parent.id);
        return parent.taskTags
          .map((tt: any) => tt.tag)
          .filter((t: any) => t != null); // Allow empty array but filter out nulls
      }

      // console.log('[DEBUG] CustomerTask.tags resolver fetching from DB for task:', parent.id);
      const taskTags = await prisma.customerTaskTag.findMany({
        where: { customerTaskId: parent.id },
        include: { tag: true },
        orderBy: { tag: { displayOrder: 'asc' } }
      });
      return taskTags
        .map((tt: any) => tt.tag)
        .filter((t: any) => t != null) || [];
    } catch (error) {
      console.log('[CustomerTask.tags] Error, returning empty array:', (error as any).message);
      return [];
    }
  },
};


