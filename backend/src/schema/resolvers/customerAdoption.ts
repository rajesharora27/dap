import { prisma } from '../../context';
import { ensureRole } from '../../lib/auth';
import { logAudit } from '../../lib/audit';
import { LicenseLevel } from '@prisma/client';
import { CustomerTelemetryExportService } from '../../services/telemetry/CustomerTelemetryExportService';
import { CustomerTelemetryImportService } from '../../services/telemetry/CustomerTelemetryImportService';
import { evaluateTelemetryAttribute } from '../../services/telemetry/evaluationEngine';
import * as fs from 'fs';
import * as path from 'path';

// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';

// Helper function to calculate progress
function calculateProgress(tasks: any[]): {
  totalTasks: number;
  completedTasks: number;
  totalWeight: number;
  completedWeight: number;
  progressPercentage: number;
} {
  // Filter out NOT_APPLICABLE tasks - they should not count towards progress
  const applicableTasks = tasks.filter(t => t.status !== 'NOT_APPLICABLE');

  const totalTasks = applicableTasks.length;
  const completedTasks = applicableTasks.filter(t => t.status === 'COMPLETED' || t.status === 'DONE').length;

  const totalWeight = applicableTasks.reduce((sum, task) => {
    const weight = typeof task.weight === 'object' && 'toNumber' in task.weight
      ? task.weight.toNumber()
      : Number(task.weight || 0);
    return sum + weight;
  }, 0);

  const completedWeight = applicableTasks
    .filter(t => t.status === 'COMPLETED' || t.status === 'DONE')
    .reduce((sum, task) => {
      const weight = typeof task.weight === 'object' && 'toNumber' in task.weight
        ? task.weight.toNumber()
        : Number(task.weight || 0);
      return sum + weight;
    }, 0);

  const progressPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;

  return {
    totalTasks,
    completedTasks,
    totalWeight,
    completedWeight,
    progressPercentage: Math.round(progressPercentage * 100) / 100, // Round to 2 decimals
  };
}

// Helper function to evaluate telemetry criteria
function evaluateCriteria(criteria: any, value: any): boolean {
  try {
    if (!criteria || typeof criteria !== 'object') return false;

    const { operator, targetValue, conditions } = criteria;

    // Handle AND/OR logic for multiple conditions
    if (conditions && Array.isArray(conditions)) {
      if (operator === 'AND') {
        return conditions.every((cond: any) => evaluateCriteria(cond, value));
      } else if (operator === 'OR') {
        return conditions.some((cond: any) => evaluateCriteria(cond, value));
      }
    }

    // Handle single condition
    if (!operator || targetValue === undefined) return false;

    switch (operator.toUpperCase()) {
      case 'EQUALS':
      case 'EQ':
        return value === targetValue;
      case 'NOT_EQUALS':
      case 'NE':
        return value !== targetValue;
      case 'GREATER_THAN':
      case 'GT':
        return Number(value) > Number(targetValue);
      case 'GREATER_THAN_OR_EQUAL':
      case 'GTE':
        return Number(value) >= Number(targetValue);
      case 'LESS_THAN':
      case 'LT':
        return Number(value) < Number(targetValue);
      case 'LESS_THAN_OR_EQUAL':
      case 'LTE':
        return Number(value) <= Number(targetValue);
      case 'CONTAINS':
        return String(value).includes(String(targetValue));
      case 'STARTS_WITH':
        return String(value).startsWith(String(targetValue));
      case 'ENDS_WITH':
        return String(value).endsWith(String(targetValue));
      case 'IS_TRUE':
        return value === true;
      case 'IS_FALSE':
        return value === false;
      case 'EXISTS':
        return value !== null && value !== undefined;
      default:
        return false;
    }
  } catch (error) {
    console.error('Error evaluating criteria:', error);
    return false;
  }
}

// Helper function to check if task should be included based on license and outcomes
function shouldIncludeTask(
  task: any,
  customerLicenseLevel: LicenseLevel,
  selectedOutcomeIds: string[],
  selectedReleaseIds?: string[]
): boolean {
  // Check license level (hierarchical comparison using case-insensitive matching)
  // Support both uppercase enum (ESSENTIAL) and capitalized (Essential) formats
  const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];

  const customerLevel = licenseLevels.indexOf(customerLicenseLevel.toUpperCase());
  const taskLevel = licenseLevels.indexOf(task.licenseLevel.toUpperCase());

  // If license level not found in hierarchy, skip this task (safety check)
  if (taskLevel === -1) {
    console.warn(`Unknown task license level: ${task.licenseLevel}`);
    return false;
  }

  if (customerLevel === -1) {
    console.warn(`Unknown customer license level: ${customerLicenseLevel}`);
    return false;
  }

  if (taskLevel > customerLevel) {
    return false; // Task requires higher license
  }

  // Check if task belongs to selected outcomes (if outcomes are specified)
  if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
    // Get task outcomes
    const taskOutcomeIds = task.outcomes?.map((o: any) => o.outcomeId) || [];
    // Task must have at least one matching outcome
    const hasMatchingOutcome = taskOutcomeIds.some((oid: string) => selectedOutcomeIds.includes(oid));
    if (!hasMatchingOutcome) {
      return false;
    }
  }

  // Check if task belongs to selected releases (if releases are specified)
  if (selectedReleaseIds && selectedReleaseIds.length > 0) {
    // Get task releases
    const taskReleaseIds = task.releases?.map((r: any) => r.releaseId) || [];
    // Task must have at least one matching release
    const hasMatchingRelease = taskReleaseIds.some((rid: string) => selectedReleaseIds.includes(rid));
    if (!hasMatchingRelease) {
      return false;
    }
  }

  return true;
}

export const CustomerAdoptionQueryResolvers = {
  customer: async (_: any, { id }: any, ctx: any) => {
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        products: {
          include: {
            product: true,
            adoptionPlan: {
              include: {
                tasks: true,
              },
            },
          },
        },
        solutions: {
          include: {
            solution: true,
          },
        },
      },
    });
    return customer;
  },

  customerSolution: async (_: any, { id }: any, ctx: any) => {
    const customerSolution = await prisma.customerSolution.findUnique({
      where: { id },
      include: {
        customer: true,
        solution: {
          include: {
            outcomes: true,
            releases: true,
            products: {
              include: {
                product: true
              }
            }
          }
        },
        adoptionPlan: true
      }
    });
    return customerSolution;
  },

  adoptionPlan: async (_: any, { id }: any, ctx: any) => {
    // First, auto-evaluate all task telemetry to ensure statuses are current
    // This handles cases where telemetry was removed/changed since last view
    try {
      await CustomerAdoptionMutationResolvers.evaluateAllTasksTelemetry(
        _,
        { adoptionPlanId: id },
        ctx
      );
    } catch (evalError) {
      // Log but don't fail the query if evaluation fails
      console.error('Auto-evaluation failed:', evalError);
    }

    const plan = await prisma.adoptionPlan.findUnique({
      where: { id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: {
              include: {
                outcome: true,
              },
            },
            releases: {
              include: {
                release: true,
              },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    return plan;
  },

  adoptionPlansForCustomer: async (_: any, { customerId }: any, ctx: any) => {
    const customerProducts = await prisma.customerProduct.findMany({
      where: { customerId },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
      },
    });

    return customerProducts
      .filter((cp: any) => cp.adoptionPlan)
      .map((cp: any) => cp.adoptionPlan);
  },

  customerTask: async (_: any, { id }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            customerProduct: {
              include: {
                customer: true,
                product: true,
              },
            },
          },
        },
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
            },
          },
          orderBy: { order: 'asc' },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
    });
    return task;
  },

  customerTasksForPlan: async (_: any, { adoptionPlanId, status }: any, ctx: any) => {
    const where: any = { adoptionPlanId };
    if (status) {
      where.status = status;
    }

    const tasks = await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
    return tasks;
  },

  customerTelemetryDatabase: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    const where: any = {};

    if (customerProductId) {
      where.customerProductId = customerProductId;
    } else if (customerId) {
      where.customerId = customerId;
    }

    const customerProducts = await prisma.customerProduct.findMany({
      where,
      include: {
        customer: true,
        product: true,
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: {
                  where: { isActive: true },
                  include: {
                    values: {
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    const records: any[] = [];

    for (const cp of customerProducts) {
      for (const plan of cp.adoptionPlans) {
        for (const task of plan.tasks) {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            records.push({
              customerId: cp.customer.id,
              customerName: cp.customer.name,
              customerProductId: cp.id,
              productId: cp.product.id,
              productName: cp.product.name,
              licenseLevel: cp.licenseLevel,
              adoptionPlanId: plan.id,
              taskId: task.id,
              taskName: task.name,
              taskSequenceNumber: task.sequenceNumber,
              attributeId: attr.id,
              attributeName: attr.name,
              attributeType: attr.attributeType,
              attributeRequired: attr.isRequired,
              attributeCriteria: attr.successCriteria,
              latestValue: latestValue?.value || null,
              latestValueDate: latestValue?.createdAt || null,
              criteriaMet,
              taskStatus: task.status,
            });
          }
        }
      }
    }

    return records;
  },
};

export const CustomerAdoptionMutationResolvers = {
  assignProductToCustomer: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const { customerId, productId, name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;

    // Note: Removed unique constraint check - customers can now have the same product multiple times
    // Each assignment must be differentiated by a required name

    // Validate product exists
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });

    if (!product) {
      throw new Error('Product not found');
    }

    // Validate outcome IDs if provided
    if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId },
      });

      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }

    // Validate release IDs if provided
    if (selectedReleaseIds && selectedReleaseIds.length > 0) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds }, productId },
      });

      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }

    // Convert GraphQL enum (PascalCase) to Prisma enum (UPPERCASE)
    const prismaLicenseLevel = licenseLevel.toUpperCase() as 'ESSENTIAL' | 'ADVANTAGE' | 'SIGNATURE';

    // Create customer product assignment
    const customerProduct = await prisma.customerProduct.create({
      data: {
        customerId,
        productId,
        name, // Required field
        licenseLevel: prismaLicenseLevel,
        selectedOutcomes: selectedOutcomeIds || [],
        selectedReleases: selectedReleaseIds || [],
      },
      include: {
        customer: true,
        product: true,
        adoptionPlan: true,
      },
    });

    await logAudit('ASSIGN_PRODUCT_TO_CUSTOMER', 'CustomerProduct', customerProduct.id, { input }, ctx.user?.id);

    return customerProduct;
  },

  updateCustomerProduct: async (_: any, { id, input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const { name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;

    const before = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    if (!before) {
      throw new Error('Customer product assignment not found');
    }

    // Validate outcome IDs if provided
    if (selectedOutcomeIds) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId: before.productId },
      });

      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }

    // Validate release IDs if provided
    if (selectedReleaseIds) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds }, productId: before.productId },
      });

      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name || null;
    if (licenseLevel) updateData.licenseLevel = licenseLevel.toUpperCase();
    if (selectedOutcomeIds !== undefined) updateData.selectedOutcomes = selectedOutcomeIds;
    if (selectedReleaseIds !== undefined) updateData.selectedReleases = selectedReleaseIds;

    // Update customer product first
    const updated = await prisma.customerProduct.update({
      where: { id },
      data: updateData,
      include: {
        customer: true,
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });

    // If adoption plan exists, update it intelligently to preserve status and telemetry
    // Instead of deleting and recreating, we'll add/remove tasks as needed (like sync does)
    if (before.adoptionPlan) {
      console.log(`Updating adoption plan for customer product ${id} due to entitlement changes`);

      const adoptionPlanId = before.adoptionPlan.id;

      // Get the new license level, outcomes, and releases from the updated product
      const newLicenseLevel = updated.licenseLevel;
      const newSelectedOutcomeIds = updated.selectedOutcomes as string[] || [];
      const newSelectedReleaseIds = updated.selectedReleases as string[] || [];

      // Filter tasks based on NEW license level, outcomes, and releases
      const eligibleProductTasks = updated.product.tasks.filter((task: any) =>
        shouldIncludeTask(task, newLicenseLevel, newSelectedOutcomeIds, newSelectedReleaseIds)
      );

      const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
      const currentCustomerTaskOriginalIds = before.adoptionPlan.tasks.map((t: any) => t.originalTaskId);

      // Find tasks to remove (no longer eligible)
      const tasksToRemove = before.adoptionPlan.tasks.filter(
        (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
      );

      // Find tasks to add (newly eligible)
      const tasksToAdd = eligibleProductTasks.filter(
        (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
      );

      // Remove tasks that are no longer eligible
      for (const task of tasksToRemove) {
        await prisma.customerTask.delete({ where: { id: task.id } });
      }

      // Add new eligible tasks
      for (const task of tasksToAdd) {
        const customerTask = await prisma.customerTask.create({
          data: {
            adoptionPlanId: adoptionPlanId,
            originalTaskId: task.id,
            name: task.name,
            description: task.description,
            estMinutes: task.estMinutes,
            weight: task.weight,
            sequenceNumber: task.sequenceNumber,
            howToDoc: task.howToDoc,
            howToVideo: task.howToVideo,
            notes: task.notes,
            licenseLevel: task.licenseLevel,
            status: 'NOT_STARTED',
            statusUpdateSource: 'SYSTEM',
          },
        });

        // Copy telemetry attributes
        for (const attr of task.telemetryAttributes) {
          await prisma.customerTelemetryAttribute.create({
            data: {
              customerTaskId: customerTask.id,
              originalAttributeId: attr.id,
              name: attr.name,
              description: attr.description,
              dataType: attr.dataType,
              isRequired: attr.isRequired,
              successCriteria: attr.successCriteria,
              order: attr.order,
              isActive: attr.isActive,
            },
          });
        }

        // Copy outcome relationships
        for (const taskOutcome of task.outcomes) {
          await prisma.customerTaskOutcome.create({
            data: {
              customerTaskId: customerTask.id,
              outcomeId: taskOutcome.outcomeId,
            },
          });
        }

        // Copy release relationships
        for (const taskRelease of task.releases) {
          await prisma.customerTaskRelease.create({
            data: {
              customerTaskId: customerTask.id,
              releaseId: taskRelease.releaseId,
            },
          });
        }
      }

      // Recalculate progress based on remaining tasks
      const updatedTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId },
      });

      const progress = calculateProgress(updatedTasks);

      // Update adoption plan metadata
      await prisma.adoptionPlan.update({
        where: { id: adoptionPlanId },
        data: {
          licenseLevel: newLicenseLevel,
          selectedOutcomes: newSelectedOutcomeIds,
          selectedReleases: newSelectedReleaseIds,
          ...progress,
          lastSyncedAt: new Date(),
        },
      });

      console.log(`Updated adoption plan: removed ${tasksToRemove.length} tasks, added ${tasksToAdd.length} tasks`);
    }

    await logAudit('UPDATE_CUSTOMER_PRODUCT', 'CustomerProduct', id, { before: { licenseLevel: before.licenseLevel, selectedOutcomes: before.selectedOutcomes }, after: { licenseLevel: updated.licenseLevel, selectedOutcomes: updated.selectedOutcomes } }, ctx.user?.id);

    // Return with fresh adoption plan data
    return await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        customer: true,
        product: true,
        adoptionPlan: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
                outcomes: {
                  include: { outcome: true },
                },
                releases: {
                  include: { release: true },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });
  },

  removeProductFromCustomerEnhanced: async (_: any, { id }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: { include: { tasks: true } },
        customerSolution: true // Include the linked solution if it exists
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }

    // Check if this product was created from a solution assignment
    if (customerProduct.customerSolutionId && customerProduct.customerSolution) {
      return {
        success: false,
        message: `This product cannot be removed independently because it was assigned as part of solution "${customerProduct.customerSolution.name}". Please remove the solution instead.`
      };
    }

    // Delete will cascade to adoption plan and tasks
    await prisma.customerProduct.delete({
      where: { id },
    });

    await logAudit('REMOVE_PRODUCT_FROM_CUSTOMER', 'CustomerProduct', id, {}, ctx.user?.id);

    return { success: true, message: 'Product removed from customer successfully' };
  },

  createAdoptionPlan: async (_: any, { customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }

    if (customerProduct.adoptionPlan) {
      throw new Error('Adoption plan already exists for this customer product');
    }

    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    const selectedReleaseIds = customerProduct.selectedReleases as string[] || [];

    // Filter tasks based on license level, outcomes, and releases
    const eligibleTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds, selectedReleaseIds)
    );

    // Calculate initial progress
    const progress = calculateProgress(eligibleTasks.map((t: any) => ({ ...t, status: 'NOT_STARTED' })));

    // Create adoption plan
    const adoptionPlan = await prisma.adoptionPlan.create({
      data: {
        customerProductId,
        productId: customerProduct.productId,
        productName: customerProduct.product.name,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        selectedReleases: selectedReleaseIds,
        totalTasks: progress.totalTasks,
        completedTasks: 0,
        totalWeight: progress.totalWeight,
        completedWeight: 0,
        progressPercentage: 0,
        lastSyncedAt: new Date(),
      },
    });

    // Create customer tasks (snapshots of product tasks)
    for (const task of eligibleTasks) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: adoptionPlan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
          statusUpdateSource: 'SYSTEM',
        },
      });

      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }

      // Copy outcome relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: {
            customerTaskId: customerTask.id,
            outcomeId: taskOutcome.outcomeId,
          },
        });
      }

      // Copy release relationships
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: {
            customerTaskId: customerTask.id,
            releaseId: taskRelease.releaseId,
          },
        });
      }
    }

    await logAudit('CREATE_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlan.id, { customerProductId }, ctx.user?.id);

    // Fetch complete plan with relations
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlan.id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: {
              include: { outcome: true },
            },
            releases: {
              include: { release: true },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  syncAdoptionPlan: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    console.log(`=== SYNC ADOPTION PLAN START: ${adoptionPlanId} ===`);

    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            product: {
              include: {
                tasks: {
                  where: { deletedAt: null },
                  include: {
                    telemetryAttributes: true,
                    outcomes: true,
                    releases: true,
                  },
                },
                outcomes: true,
                releases: true,
              },
            },
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: true,
            releases: true,
          },
        },
      },
    });

    if (!plan) {
      throw new Error('Adoption plan not found');
    }

    const { customerProduct } = plan;
    const product = customerProduct.product;

    // ============================================
    // STEP 1: SYNC ENTITLEMENTS (copy ALL from product)
    // ============================================
    const allProductOutcomeIds = product.outcomes.map((o: any) => o.id);
    const allProductReleaseIds = product.releases.map((r: any) => r.id);

    console.log(`STEP 1: Syncing entitlements - ${allProductOutcomeIds.length} outcomes, ${allProductReleaseIds.length} releases`);

    // Update CustomerProduct entitlements
    await prisma.customerProduct.update({
      where: { id: customerProduct.id },
      data: {
        selectedOutcomes: allProductOutcomeIds,
        selectedReleases: allProductReleaseIds,
      },
    });

    // ============================================
    // STEP 2: SYNC TASKS (match by license level only)
    // ============================================
    // Get ALL product tasks that match the license level (no outcome/release filtering)
    const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];
    const customerLicenseIndex = licenseLevels.indexOf(customerProduct.licenseLevel.toUpperCase());
    
    const eligibleProductTasks = product.tasks.filter((task: any) => {
      const taskLicenseIndex = licenseLevels.indexOf(task.licenseLevel.toUpperCase());
      return taskLicenseIndex <= customerLicenseIndex; // Task license <= customer license
    });

    console.log(`STEP 2: Product has ${product.tasks.length} tasks, ${eligibleProductTasks.length} eligible for license ${customerProduct.licenseLevel}`);

    const productTaskIds = eligibleProductTasks.map((t: any) => t.id);
    const existingCustomerTasks = plan.tasks as any[];
    const existingTaskMap = new Map<string, any>(existingCustomerTasks.map((t: any) => [t.originalTaskId, t]));

    // Track counts
    let tasksRemoved = 0;
    let tasksAdded = 0;
    let tasksUpdated = 0;

    // Remove tasks that no longer exist in product
    for (const customerTask of existingCustomerTasks) {
      if (!productTaskIds.includes(customerTask.originalTaskId)) {
        console.log(`  Removing task: ${customerTask.name} (originalTaskId: ${customerTask.originalTaskId})`);
        await prisma.customerTask.delete({ where: { id: customerTask.id } });
        tasksRemoved++;
      }
    }

    // Add or update tasks from product
    for (const productTask of eligibleProductTasks) {
      const existingTask = existingTaskMap.get(productTask.id);

      if (existingTask) {
        // UPDATE existing task (preserve status fields)
        console.log(`  Updating task: ${productTask.name}`);
        await prisma.customerTask.update({
          where: { id: existingTask.id },
          data: {
            name: productTask.name,
            description: productTask.description,
            estMinutes: productTask.estMinutes,
            weight: productTask.weight,
            sequenceNumber: productTask.sequenceNumber,
            howToDoc: productTask.howToDoc,
            howToVideo: productTask.howToVideo,
            notes: productTask.notes,
            licenseLevel: productTask.licenseLevel,
            // Status fields are NOT updated - they are preserved
          },
        });

        // Sync telemetry attributes
        const productAttrIds = productTask.telemetryAttributes.map((a: any) => a.id);
        await prisma.customerTelemetryAttribute.deleteMany({
          where: { customerTaskId: existingTask.id, originalAttributeId: { notIn: productAttrIds } },
        });

        for (const attr of productTask.telemetryAttributes) {
          const existingAttr = await prisma.customerTelemetryAttribute.findFirst({
            where: { customerTaskId: existingTask.id, originalAttributeId: attr.id },
          });
          if (existingAttr) {
            await prisma.customerTelemetryAttribute.update({
              where: { id: existingAttr.id },
              data: {
                name: attr.name, description: attr.description, dataType: attr.dataType,
                isRequired: attr.isRequired, successCriteria: attr.successCriteria,
                order: attr.order, isActive: attr.isActive,
              },
            });
          } else {
            await prisma.customerTelemetryAttribute.create({
              data: {
                customerTaskId: existingTask.id, originalAttributeId: attr.id,
                name: attr.name, description: attr.description, dataType: attr.dataType,
                isRequired: attr.isRequired, successCriteria: attr.successCriteria,
                order: attr.order, isActive: attr.isActive,
              },
            });
          }
        }

        // Sync outcomes - delete and recreate
        await prisma.customerTaskOutcome.deleteMany({ where: { customerTaskId: existingTask.id } });
        for (const to of productTask.outcomes) {
          await prisma.customerTaskOutcome.create({ data: { customerTaskId: existingTask.id, outcomeId: to.outcomeId } });
        }

        // Sync releases - delete and recreate
        await prisma.customerTaskRelease.deleteMany({ where: { customerTaskId: existingTask.id } });
        for (const tr of productTask.releases) {
          await prisma.customerTaskRelease.create({ data: { customerTaskId: existingTask.id, releaseId: tr.releaseId } });
        }

        tasksUpdated++;
      } else {
        // ADD new task
        console.log(`  Adding task: ${productTask.name}`);
        const newTask = await prisma.customerTask.create({
          data: {
            adoptionPlanId: plan.id,
            originalTaskId: productTask.id,
            name: productTask.name,
            description: productTask.description,
            estMinutes: productTask.estMinutes,
            weight: productTask.weight,
            sequenceNumber: productTask.sequenceNumber,
            howToDoc: productTask.howToDoc,
            howToVideo: productTask.howToVideo,
            notes: productTask.notes,
            licenseLevel: productTask.licenseLevel,
            status: 'NOT_STARTED',
            statusUpdateSource: 'SYSTEM',
          },
        });

        // Copy telemetry attributes
        for (const attr of productTask.telemetryAttributes) {
          await prisma.customerTelemetryAttribute.create({
            data: {
              customerTaskId: newTask.id, originalAttributeId: attr.id,
              name: attr.name, description: attr.description, dataType: attr.dataType,
              isRequired: attr.isRequired, successCriteria: attr.successCriteria,
              order: attr.order, isActive: attr.isActive,
            },
          });
        }

        // Copy outcomes
        for (const to of productTask.outcomes) {
          await prisma.customerTaskOutcome.create({ data: { customerTaskId: newTask.id, outcomeId: to.outcomeId } });
        }

        // Copy releases
        for (const tr of productTask.releases) {
          await prisma.customerTaskRelease.create({ data: { customerTaskId: newTask.id, releaseId: tr.releaseId } });
        }

        tasksAdded++;
      }
    }

    // ============================================
    // STEP 3: UPDATE ADOPTION PLAN
    // ============================================
    const finalTasks = await prisma.customerTask.findMany({ where: { adoptionPlanId } });
    const progress = calculateProgress(finalTasks);

    const updatedPlan = await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: {
        ...progress,
        selectedOutcomes: allProductOutcomeIds,
        selectedReleases: allProductReleaseIds,
        lastSyncedAt: new Date(),
      },
      include: {
        customerProduct: { include: { customer: true, product: true } },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });

    console.log(`=== SYNC COMPLETE: removed ${tasksRemoved}, added ${tasksAdded}, updated ${tasksUpdated} tasks ===`);

    await logAudit('SYNC_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlanId, {
      tasksRemoved, tasksAdded, tasksUpdated,
      outcomes: allProductOutcomeIds.length,
      releases: allProductReleaseIds.length
    }, ctx.user?.id);

    return updatedPlan;
  },

  updateCustomerTaskStatus: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const { customerTaskId, status, notes, updateSource } = input;

    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: { adoptionPlan: true },
    });

    if (!task) {
      throw new Error('Customer task not found');
    }

    // Append new notes to existing notes with timestamp and status change
    let updatedNotes = task.statusNotes || '';
    if (notes && notes.trim()) {
      const timestamp = new Date().toISOString();
      const user = ctx.user?.id || 'unknown';
      const source = updateSource || 'MANUAL';
      const statusChange = `[${timestamp}] Status changed to ${status} by ${user} (via ${source}):\n${notes.trim()}\n\n`;
      updatedNotes = updatedNotes ? `${updatedNotes}${statusChange}` : statusChange;
    }

    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusUpdateSource: updateSource || 'MANUAL',
      statusNotes: updatedNotes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };

    const updated = await prisma.customerTask.update({
      where: { id: customerTaskId },
      data: updateData,
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });

    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: task.adoptionPlanId },
    });

    const progress = calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: task.adoptionPlanId },
      data: progress,
    });

    // Check if this product is part of a solution and trigger solution sync
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { id: task.adoptionPlanId },
      include: {
        customerProduct: true
      }
    });

    if (adoptionPlan?.customerProduct) {
      // Check if this product name indicates it's part of a solution (format: "{SolutionName} - {ProductName}")
      const productName = adoptionPlan.customerProduct.name;
      if (productName.includes(' - ')) {
        // This product is part of a solution, find the solution adoption plan
        const solutionName = productName.split(' - ')[0];

        // Find the customer solution with this name
        const customerSolution = await prisma.customerSolution.findFirst({
          where: {
            customerId: adoptionPlan.customerProduct.customerId,
            name: solutionName
          },
          include: {
            adoptionPlan: true
          }
        });

        // If solution adoption plan exists, trigger sync
        if (customerSolution?.adoptionPlan) {
          // Import the sync function
          const { SolutionAdoptionMutationResolvers } = require('./solutionAdoption');
          await SolutionAdoptionMutationResolvers.syncSolutionAdoptionPlan(
            _,
            { solutionAdoptionPlanId: customerSolution.adoptionPlan.id },
            ctx
          );
        }
      }
    }

    await logAudit('UPDATE_CUSTOMER_TASK_STATUS', 'CustomerTask', customerTaskId, { status, notes }, ctx.user?.id);

    return updated;
  },

  bulkUpdateCustomerTaskStatus: async (_: any, { adoptionPlanId, taskIds, status, notes }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    // Fetch existing tasks to preserve their notes
    const existingTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
        adoptionPlanId,
      },
    });

    // Update each task individually to append notes
    const timestamp = new Date().toISOString();
    const user = ctx.user?.id || 'unknown';
    const statusChange = notes && notes.trim()
      ? `[${timestamp}] Status changed to ${status} by ${user}:\n${notes.trim()}\n\n`
      : '';

    const updatePromises = existingTasks.map((task: any) => {
      const updatedNotes = statusChange
        ? (task.statusNotes || '') + statusChange
        : task.statusNotes;

      return prisma.customerTask.update({
        where: { id: task.id },
        data: {
          status,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: user,
          statusUpdateSource: 'MANUAL',
          statusNotes: updatedNotes,
          isComplete: status === 'DONE',
          completedAt: status === 'DONE' ? new Date() : null,
          completedBy: status === 'DONE' ? user : null,
        },
      });
    });

    await Promise.all(updatePromises);

    // Fetch updated tasks
    const updatedTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
      },
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });

    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });

    const progress = calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: progress,
    });

    // Check if this product is part of a solution and trigger solution sync
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: true
      }
    });

    if (adoptionPlan?.customerProduct) {
      // Check if this product name indicates it's part of a solution (format: "{SolutionName} - {ProductName}")
      const productName = adoptionPlan.customerProduct.name;
      if (productName.includes(' - ')) {
        // This product is part of a solution, find the solution adoption plan
        const solutionName = productName.split(' - ')[0];

        // Find the customer solution with this name
        const customerSolution = await prisma.customerSolution.findFirst({
          where: {
            customerId: adoptionPlan.customerProduct.customerId,
            name: solutionName
          },
          include: {
            adoptionPlan: true
          }
        });

        // If solution adoption plan exists, trigger sync
        if (customerSolution?.adoptionPlan) {
          // Import the sync function
          const { SolutionAdoptionMutationResolvers } = require('./solutionAdoption');
          await SolutionAdoptionMutationResolvers.syncSolutionAdoptionPlan(
            _,
            { solutionAdoptionPlanId: customerSolution.adoptionPlan.id },
            ctx
          );
        }
      }
    }

    await logAudit('BULK_UPDATE_CUSTOMER_TASK_STATUS', 'AdoptionPlan', adoptionPlanId, { taskIds, status, notes }, ctx.user?.id);

    return updatedTasks;
  },

  addCustomerTelemetryValue: async (_: any, { input }: any, ctx: any) => {
    const { customerAttributeId, value, source, batchId, notes } = input;

    const attribute = await prisma.customerTelemetryAttribute.findUnique({
      where: { id: customerAttributeId },
      include: { customerTask: { include: { adoptionPlan: true } } },
    });

    if (!attribute) {
      throw new Error('Customer telemetry attribute not found');
    }

    const telemetryValue = await prisma.customerTelemetryValue.create({
      data: {
        customerAttributeId,
        value,
        source: source || 'manual',
        batchId,
        notes,
      },
      include: {
        customerAttribute: true,
      },
    });

    await logAudit('ADD_CUSTOMER_TELEMETRY_VALUE', 'CustomerTelemetryValue', telemetryValue.id, { input }, ctx.user?.id);

    return telemetryValue;
  },

  bulkAddCustomerTelemetryValues: async (_: any, { inputs }: any, ctx: any) => {
    const createdValues = [];

    for (const input of inputs) {
      const { customerAttributeId, value, source, batchId, notes } = input;

      const telemetryValue = await prisma.customerTelemetryValue.create({
        data: {
          customerAttributeId,
          value,
          source: source || 'api',
          batchId,
          notes,
        },
        include: {
          customerAttribute: true,
        },
      });

      createdValues.push(telemetryValue);
    }

    await logAudit('BULK_ADD_CUSTOMER_TELEMETRY_VALUES', 'CustomerTelemetryValue', 'bulk', { count: inputs.length }, ctx.user?.id);

    return createdValues;
  },

  evaluateTaskTelemetry: async (_: any, { customerTaskId }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],
              take: 1,
            },
          },
        },
      },
    });

    if (!task) {
      throw new Error('Customer task not found');
    }

    const attributes = task.telemetryAttributes;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive);

    // Manual status takes precedence over telemetry (except for NOT_STARTED)
    // If user manually set status to IN_PROGRESS, DONE, or NOT_APPLICABLE, respect that
    const hasManualStatus = task.statusUpdatedBy &&
      task.statusUpdatedBy !== 'telemetry' &&
      task.status !== 'NOT_STARTED';

    // Evaluate each attribute (always evaluate to update isMet status for display)
    let metCount = 0;
    let metRequiredCount = 0;
    let hasAnyTelemetryData = false;  // Track if any telemetry values exist
    let requiredWithDataCount = 0;     // Track required attributes that have telemetry data

    for (const attr of attributes) {
      if (!attr.isActive) continue;

      const latestValue = attr.values[0];
      if (latestValue) {
        hasAnyTelemetryData = true;
        if (attr.isRequired) requiredWithDataCount++;
      }

      if (!latestValue) continue;

      // Use the proper evaluation engine that handles the criteria structure from SimpleCriteriaBuilder
      let isMet = false;
      if (attr.successCriteria) {
        try {
          const evaluationResult = await evaluateTelemetryAttribute(attr);
          isMet = evaluationResult.success;
        } catch (evalError) {
          console.error(`Failed to evaluate criteria for ${attr.name}:`, evalError);
          isMet = false;
        }
      }

      // Update attribute isMet status
      await prisma.customerTelemetryAttribute.update({
        where: { id: attr.id },
        data: {
          isMet,
          lastCheckedAt: new Date(),
        },
      });

      if (isMet) {
        metCount++;
        if (attr.isRequired) metRequiredCount++;
      }
    }

    // Determine new status based on telemetry
    // Logic:
    // 1. All required telemetry met → DONE
    // 2. Telemetry available but doesn't meet all criteria → IN_PROGRESS
    // 3. No telemetry data at all → NOT_STARTED (unless manually set)
    // 4. Was DONE (via telemetry) and now telemetry unavailable or doesn't meet → NO_LONGER_USING
    let newStatus: CustomerTaskStatus = task.status;
    const wasPreviouslyDoneByTelemetry = (task.status === 'DONE' || task.status === 'COMPLETED') && 
                                          task.statusUpdateSource === 'TELEMETRY';

    if (requiredAttributes.length > 0) {
      // Has required attributes - evaluate based on those
      if (metRequiredCount === requiredAttributes.length) {
        // All required telemetry criteria met
        newStatus = 'DONE';
      } else if (wasPreviouslyDoneByTelemetry && (metRequiredCount < requiredAttributes.length || !hasAnyTelemetryData)) {
        // Was previously DONE by telemetry, but now either:
        // - Telemetry doesn't meet criteria anymore, OR
        // - Telemetry data is no longer available
        newStatus = 'NO_LONGER_USING' as CustomerTaskStatus;
      } else if (hasAnyTelemetryData && requiredWithDataCount > 0) {
        // Has telemetry data but doesn't meet all criteria - task is in progress
        newStatus = 'IN_PROGRESS';
      } else if (!hasAnyTelemetryData) {
        // No telemetry data at all - not started (unless manually set otherwise)
        newStatus = 'NOT_STARTED';
      }
    } else if (attributes.length > 0) {
      // No required attributes, but has optional telemetry attributes
      if (wasPreviouslyDoneByTelemetry && !hasAnyTelemetryData) {
        // Was DONE by telemetry but telemetry data is no longer available
        newStatus = 'NO_LONGER_USING' as CustomerTaskStatus;
      } else if (wasPreviouslyDoneByTelemetry && metCount === 0) {
        // Was DONE by telemetry but none of the criteria are met anymore
        newStatus = 'NO_LONGER_USING' as CustomerTaskStatus;
      } else if (hasAnyTelemetryData && metCount > 0) {
        // Has telemetry data and some criteria are met
        newStatus = 'DONE';
      } else if (hasAnyTelemetryData) {
        // Has telemetry data but criteria not met
        newStatus = 'IN_PROGRESS';
      }
    }

    // Special case: NO_LONGER_USING overrides manual status because it indicates regression from a telemetry-verified DONE state
    const shouldOverrideManual = newStatus === ('NO_LONGER_USING' as CustomerTaskStatus) && wasPreviouslyDoneByTelemetry;

    // Only update task status if:
    // 1. Status has changed, AND
    // 2. Either no manual status was set, OR current status is NOT_STARTED, OR it's NO_LONGER_USING override
    if (newStatus !== task.status && (!hasManualStatus || shouldOverrideManual)) {
      const updated = await prisma.customerTask.update({
        where: { id: customerTaskId },
        data: {
          status: newStatus,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: 'telemetry',
          statusUpdateSource: 'TELEMETRY',
          statusNotes: 'Automatically updated based on telemetry criteria',
          isComplete: newStatus === 'DONE',
          completedAt: newStatus === 'DONE' ? new Date() : null,
          completedBy: newStatus === 'DONE' ? 'telemetry' : null,
        },
        include: {
          adoptionPlan: true,
          telemetryAttributes: {
            include: {
              values: {
                orderBy: { createdAt: 'desc' },
                take: 1,
              },
            },
          },
          outcomes: { include: { outcome: true } },
          releases: { include: { release: true } },
        },
      });

      // Recalculate adoption plan progress
      const allTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId: task.adoptionPlanId },
      });

      const progress = calculateProgress(allTasks);

      await prisma.adoptionPlan.update({
        where: { id: task.adoptionPlanId },
        data: progress,
      });

      await logAudit('EVALUATE_TASK_TELEMETRY', 'CustomerTask', customerTaskId, { oldStatus: task.status, newStatus }, ctx.user?.id);

      return updated;
    }

    // Status not updated - either no change or manual status takes precedence
    return task;
  },

  evaluateAllTasksTelemetry: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
          },
        },
      },
    });

    if (!plan) {
      throw new Error('Adoption plan not found');
    }

    // Evaluate each task
    // Note: evaluateTaskTelemetry handles manual vs telemetry status precedence internally
    for (const task of plan.tasks) {
      await CustomerAdoptionMutationResolvers.evaluateTaskTelemetry(
        _,
        { customerTaskId: task.id },
        ctx
      );
    }

    // Return updated plan
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  exportCustomerAdoptionToExcel: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');

    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        customer: true,
        product: true,
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product not found');
    }

    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { customerProductId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Customer Adoption Data');

    // Headers
    worksheet.columns = [
      { header: 'Customer ID', key: 'customerId', width: 20 },
      { header: 'Customer Name', key: 'customerName', width: 30 },
      { header: 'Product ID', key: 'productId', width: 20 },
      { header: 'Product Name', key: 'productName', width: 30 },
      { header: 'License Level', key: 'licenseLevel', width: 15 },
      { header: 'Task Sequence', key: 'taskSequence', width: 12 },
      { header: 'Task Name', key: 'taskName', width: 40 },
      { header: 'Task Status', key: 'taskStatus', width: 15 },
      { header: 'Telemetry Attribute', key: 'telemetryAttribute', width: 30 },
      { header: 'Attribute Type', key: 'attributeType', width: 15 },
      { header: 'Required', key: 'required', width: 10 },
      { header: 'Current Value', key: 'currentValue', width: 30 },
      { header: 'Last Updated', key: 'lastUpdated', width: 20 },
      { header: 'Criteria Met', key: 'criteriaMet', width: 12 },
    ];

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    };

    if (adoptionPlan.tasks && adoptionPlan.tasks.length > 0) {
      for (const task of adoptionPlan.tasks) {
        if (task.telemetryAttributes.length === 0) {
          // Task with no telemetry
          worksheet.addRow({
            customerId: customerProduct.customer.id,
            customerName: customerProduct.customer.name,
            productId: customerProduct.product.id,
            productName: customerProduct.product.name,
            licenseLevel: customerProduct.licenseLevel,
            taskSequence: task.sequenceNumber,
            taskName: task.name,
            taskStatus: task.status,
            telemetryAttribute: '',
            attributeType: '',
            required: '',
            currentValue: '',
            lastUpdated: '',
            criteriaMet: '',
          });
        } else {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            worksheet.addRow({
              customerId: customerProduct.customer.id,
              customerName: customerProduct.customer.name,
              productId: customerProduct.product.id,
              productName: customerProduct.product.name,
              licenseLevel: customerProduct.licenseLevel,
              taskSequence: task.sequenceNumber,
              taskName: task.name,
              taskStatus: task.status,
              telemetryAttribute: attr.name,
              attributeType: attr.attributeType,
              required: attr.isRequired ? 'Yes' : 'No',
              currentValue: latestValue ? JSON.stringify(latestValue.value) : '',
              lastUpdated: latestValue ? latestValue.createdAt.toISOString() : '',
              criteriaMet: criteriaMet === null ? '' : criteriaMet ? 'Yes' : 'No',
            });
          }
        }
      }
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const content = Buffer.from(buffer).toString('base64');
    const filename = `${customerProduct.customer.name}_${customerProduct.product.name}_adoption.xlsx`;

    await logAudit('EXPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { filename }, ctx.user?.id);

    return {
      filename,
      content,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      size: buffer.byteLength,
      stats: {
        tasksExported: adoptionPlan?.tasks.length || 0,
        customAttributesExported: 0,
        licensesExported: 0,
        outcomesExported: 0,
        releasesExported: 0,
        telemetryAttributesExported: adoptionPlan?.tasks.reduce((sum: number, t: any) => sum + t.telemetryAttributes.length, 0) || 0,
      },
    };
  },

  importCustomerAdoptionFromExcel: async (_: any, { content }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');
    const workbook = new ExcelJS.Workbook();
    const buffer = Buffer.from(content, 'base64');
    await workbook.xlsx.load(buffer.buffer as ArrayBuffer);

    const worksheet = workbook.getWorksheet('Customer Adoption Data');
    if (!worksheet) {
      throw new Error('Worksheet "Customer Adoption Data" not found');
    }

    const errors: any[] = [];
    const warnings: any[] = [];
    let telemetryValuesImported = 0;
    let taskStatusesUpdated = 0;
    let attributesCreated = 0;

    let customerId = '';
    let customerName = '';
    let customerProductId = '';
    let productName = '';

    const rows: any[] = [];
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header
      rows.push({
        rowNumber,
        customerId: row.getCell(1).value,
        customerName: row.getCell(2).value,
        productId: row.getCell(3).value,
        productName: row.getCell(4).value,
        licenseLevel: row.getCell(5).value,
        taskSequence: row.getCell(6).value,
        taskName: row.getCell(7).value,
        taskStatus: row.getCell(8).value,
        telemetryAttribute: row.getCell(9).value,
        attributeType: row.getCell(10).value,
        required: row.getCell(11).value,
        currentValue: row.getCell(12).value,
        lastUpdated: row.getCell(13).value,
        criteriaMet: row.getCell(14).value,
      });
    });

    if (rows.length === 0) {
      throw new Error('No data rows found in worksheet');
    }

    // Get customer and product from first row
    const firstRow = rows[0];
    customerId = firstRow.customerId;
    customerName = firstRow.customerName;
    productName = firstRow.productName;

    // Find customer product
    const customerProduct = await prisma.customerProduct.findFirst({
      where: {
        customerId: customerId,
        productId: firstRow.productId,
      },
      include: {
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
              },
            },
          },
        },
      },
    });

    if (!customerProduct) {
      throw new Error(`Customer product assignment not found for customer ${customerName} and product ${productName}`);
    }

    customerProductId = customerProduct.id;
    const adoptionPlan = customerProduct.adoptionPlans[0];

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    // Process each row
    for (const row of rows) {
      try {
        // Find task by sequence number
        const task = adoptionPlan.tasks.find((t: any) => t.sequenceNumber === Number(row.taskSequence));

        if (!task) {
          warnings.push({
            row: row.rowNumber,
            field: 'taskSequence',
            message: `Task with sequence ${row.taskSequence} not found`,
          });
          continue;
        }

        // Update task status if changed
        if (row.taskStatus && row.taskStatus !== task.status) {
          await prisma.customerTask.update({
            where: { id: task.id },
            data: {
              status: row.taskStatus as any,
              statusUpdatedBy: 'import',
              statusUpdateSource: 'IMPORT',
              statusUpdatedAt: new Date(),
            },
          });
          taskStatusesUpdated++;
        }

        // Process telemetry if present
        if (row.telemetryAttribute && row.currentValue) {
          // Find or create telemetry attribute
          let attribute = task.telemetryAttributes.find((a: any) => a.name === row.telemetryAttribute);

          if (!attribute) {
            attribute = await prisma.customerTelemetryAttribute.create({
              data: {
                customerTaskId: task.id,
                name: row.telemetryAttribute,
                attributeType: row.attributeType || 'TEXT',
                isRequired: row.required === 'Yes',
                isActive: true,
              },
            });
            attributesCreated++;
          }

          // Parse value
          let parsedValue: any;
          try {
            parsedValue = JSON.parse(row.currentValue);
          } catch {
            parsedValue = row.currentValue;
          }

          // Create telemetry value
          await prisma.customerTelemetryValue.create({
            data: {
              customerAttributeId: attribute.id,
              value: parsedValue,
              batchId: `import_${Date.now()}`,
            },
          });
          telemetryValuesImported++;
        }
      } catch (error: any) {
        errors.push({
          row: row.rowNumber,
          field: 'general',
          message: error.message,
        });
      }
    }

    // Recalculate progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: adoptionPlan.id },
    });

    const progress = calculateProgress(allTasks);

    await prisma.adoptionPlan.update({
      where: { id: adoptionPlan.id },
      data: progress,
    });

    await logAudit('IMPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { telemetryValuesImported, taskStatusesUpdated }, ctx.user?.id);

    return {
      success: errors.length === 0,
      customerId,
      customerName,
      customerProductId,
      productName,
      stats: {
        telemetryValuesImported,
        taskStatusesUpdated,
        attributesCreated,
      },
      errors,
      warnings,
    };
  },

  // Export telemetry template
  exportAdoptionPlanTelemetryTemplate: async (_: any, { adoptionPlanId }: { adoptionPlanId: string }, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    // Get metadata first
    const metadata = await CustomerTelemetryExportService.getTemplateMetadata(adoptionPlanId);

    // Generate the Excel template
    const buffer = await CustomerTelemetryExportService.generateTelemetryTemplate(adoptionPlanId);

    // Create temp directory if it doesn't exist
    const tempDir = path.join(process.cwd(), 'temp', 'telemetry-exports');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    // Generate unique filename with sanitized names (replace special characters with underscores)
    const sanitizedCustomer = metadata.customerName.replace(/[^a-z0-9]/gi, '_');
    const sanitizedProduct = metadata.productName.replace(/[^a-z0-9]/gi, '_');
    const filename = `telemetry_template_${sanitizedCustomer}_${sanitizedProduct}_${Date.now()}.xlsx`;
    const filePath = path.join(tempDir, filename);

    // Write buffer to file
    fs.writeFileSync(filePath, buffer);

    // Generate download URL (filename is already sanitized, no special encoding needed)
    const url = `/api/downloads/telemetry-exports/${filename}`;

    await logAudit('EXPORT_TELEMETRY_TEMPLATE', 'AdoptionPlan', adoptionPlanId, metadata, ctx.user?.id);

    return {
      url,
      filename,
      taskCount: metadata.taskCount,
      attributeCount: metadata.attributeCount,
      customerName: metadata.customerName,
      productName: metadata.productName,
      assignmentName: metadata.assignmentName,
    };
  },

  // Import telemetry data
  importAdoptionPlanTelemetry: async (_: any, { adoptionPlanId, file }: { adoptionPlanId: string; file: any }, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    // Handle file upload - file is an Upload scalar
    const { createReadStream } = await file;
    const stream = createReadStream();

    // Read stream into buffer
    const chunks: Buffer[] = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    const fileBuffer = Buffer.concat(chunks);

    // Import the telemetry values
    const result = await CustomerTelemetryImportService.importTelemetryValues(adoptionPlanId, fileBuffer);

    // Evaluate all task statuses immediately after import
    await CustomerAdoptionMutationResolvers.evaluateAllTasksTelemetry(_, { adoptionPlanId }, ctx);

    await logAudit('IMPORT_TELEMETRY_DATA', 'AdoptionPlan', adoptionPlanId, result.summary, ctx.user?.id);

    return result;
  },
};

// Field resolvers
export const CustomerProductWithPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  customerSolution: async (parent: any) => {
    if (!parent.customerSolutionId) return null;

    return await prisma.customerSolution.findUnique({
      where: { id: parent.customerSolutionId },
      include: {
        customer: true,
        solution: {
          include: {
            outcomes: true,
            releases: true,
            products: {
              include: {
                product: true
              }
            }
          }
        },
        adoptionPlan: true
      }
    });
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];

    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) return [];

    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },
  adoptionPlan: async (parent: any) => {
    // Find the adoption plan for this customer product
    return await prisma.adoptionPlan.findUnique({
      where: { customerProductId: parent.id },
    });
  },
};

export const AdoptionPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];

    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) return [];

    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },

  tasks: async (parent: any) => {
    // Return all tasks for this adoption plan
    return await prisma.customerTask.findMany({
      where: { adoptionPlanId: parent.id },
      orderBy: { sequenceNumber: 'asc' },
    });
  },

  tasksByStatus: async (parent: any, { status }: any) => {
    const where: any = { adoptionPlanId: parent.id };
    if (status) where.status = status;

    return await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
  },

  needsSync: async (parent: any) => {
    if (!parent.lastSyncedAt) return true;

    // Check if product has been updated since last sync
    const product = await prisma.product.findUnique({
      where: { id: parent.productId },
    });

    if (!product) return false;

    return product.updatedAt > parent.lastSyncedAt;
  },
};

export const CustomerTaskResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  telemetryAttributes: async (parent: any) => {
    // Return all telemetry attributes for this customer task
    return await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
      orderBy: { order: 'asc' },
    });
  },
  outcomes: async (parent: any) => {
    const taskOutcomes = await prisma.customerTaskOutcome.findMany({
      where: { customerTaskId: parent.id },
      include: { outcome: true },
    });

    return taskOutcomes.map((to: any) => to.outcome);
  },

  releases: async (parent: any) => {
    const taskReleases = await prisma.customerTaskRelease.findMany({
      where: { customerTaskId: parent.id },
      include: { release: true },
    });

    return taskReleases.map((tr: any) => tr.release);
  },

  telemetryProgress: async (parent: any) => {
    const attributes = await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
    });

    const totalAttributes = attributes.filter((a: any) => a.isActive).length;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive).length;
    const metAttributes = attributes.filter((a: any) => a.isMet && a.isActive).length;
    const metRequiredAttributes = attributes.filter((a: any) => a.isMet && a.isRequired && a.isActive).length;

    const completionPercentage = totalAttributes > 0 ? (metAttributes / totalAttributes) * 100 : 0;
    const allRequiredMet = requiredAttributes > 0 && metRequiredAttributes === requiredAttributes;

    return {
      totalAttributes,
      requiredAttributes,
      metAttributes,
      metRequiredAttributes,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
      allRequiredMet,
    };
  },
};

export const CustomerTelemetryAttributeResolvers = {
  values: async (parent: any, args: any) => {
    const limit = args.limit;
    const values = await prisma.customerTelemetryValue.findMany({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
      ...(limit && { take: limit }),
      include: {
        customerAttribute: true, // Include for criteriaMet resolver
      },
    });

    return values || []; // Always return array, never null
  },
  latestValue: async (parent: any) => {
    const value = await prisma.customerTelemetryValue.findFirst({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
    });

    return value;
  },
};

export const CustomerTelemetryValueResolvers = {
  criteriaMet: async (parent: any) => {
    // If no success criteria, return null (cannot evaluate)
    if (!parent.customerAttribute?.successCriteria) {
      return null;
    }

    // Need to fetch the attribute if not included
    let attribute = parent.customerAttribute;
    if (!attribute || !attribute.successCriteria) {
      attribute = await prisma.customerTelemetryAttribute.findUnique({
        where: { id: parent.customerAttributeId },
      });
    }

    if (!attribute?.successCriteria) {
      return null;
    }

    const criteria = typeof attribute.successCriteria === 'string'
      ? JSON.parse(attribute.successCriteria)
      : attribute.successCriteria;

    // Get the value - for STRING datatype, value is already a string in the DB
    // For other types, it may be stored as JSON
    let value = parent.value;
    if (typeof parent.value === 'string' && attribute.dataType !== 'STRING') {
      try {
        value = JSON.parse(parent.value);
      } catch {
        // If parsing fails, use the raw value
        value = parent.value;
      }
    }

    if (criteria.type === 'boolean_equals') {
      return value === criteria.expectedValue;
    } else if (criteria.type === 'number_threshold') {
      const numValue = Number(value);
      const threshold = Number(criteria.threshold);

      switch (criteria.operator) {
        case 'greater_than': return numValue > threshold;
        case 'greater_than_or_equal': return numValue >= threshold;
        case 'less_than': return numValue < threshold;
        case 'less_than_or_equal': return numValue <= threshold;
        case 'equals': return numValue === threshold;
        default: return false;
      }
    } else if (criteria.type === 'string_contains') {
      const strValue = String(value).toLowerCase();
      const expectedStr = String(criteria.expectedValue).toLowerCase();
      return strValue.includes(expectedStr);
    }

    return null;
  },
};
