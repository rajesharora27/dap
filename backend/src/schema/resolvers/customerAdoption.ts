import { prisma } from '../../context';
import { ensureRole } from '../../lib/auth';
import { logAudit } from '../../lib/audit';
import { LicenseLevel } from '@prisma/client';

// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';

// Helper function to calculate progress
function calculateProgress(tasks: any[]): {
  totalTasks: number;
  completedTasks: number;
  totalWeight: number;
  completedWeight: number;
  progressPercentage: number;
} {
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(t => t.status === 'DONE').length;
  
  const totalWeight = tasks.reduce((sum, task) => {
    const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
      ? task.weight.toNumber() 
      : Number(task.weight || 0);
    return sum + weight;
  }, 0);
  
  const completedWeight = tasks
    .filter(t => t.status === 'DONE')
    .reduce((sum, task) => {
      const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
        ? task.weight.toNumber() 
        : Number(task.weight || 0);
      return sum + weight;
    }, 0);
  
  const progressPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;
  
  return {
    totalTasks,
    completedTasks,
    totalWeight,
    completedWeight,
    progressPercentage: Math.round(progressPercentage * 100) / 100, // Round to 2 decimals
  };
}

// Helper function to evaluate telemetry criteria
function evaluateCriteria(criteria: any, value: any): boolean {
  try {
    if (!criteria || typeof criteria !== 'object') return false;
    
    const { operator, targetValue, conditions } = criteria;
    
    // Handle AND/OR logic for multiple conditions
    if (conditions && Array.isArray(conditions)) {
      if (operator === 'AND') {
        return conditions.every((cond: any) => evaluateCriteria(cond, value));
      } else if (operator === 'OR') {
        return conditions.some((cond: any) => evaluateCriteria(cond, value));
      }
    }
    
    // Handle single condition
    if (!operator || targetValue === undefined) return false;
    
    switch (operator.toUpperCase()) {
      case 'EQUALS':
      case 'EQ':
        return value === targetValue;
      case 'NOT_EQUALS':
      case 'NE':
        return value !== targetValue;
      case 'GREATER_THAN':
      case 'GT':
        return Number(value) > Number(targetValue);
      case 'GREATER_THAN_OR_EQUAL':
      case 'GTE':
        return Number(value) >= Number(targetValue);
      case 'LESS_THAN':
      case 'LT':
        return Number(value) < Number(targetValue);
      case 'LESS_THAN_OR_EQUAL':
      case 'LTE':
        return Number(value) <= Number(targetValue);
      case 'CONTAINS':
        return String(value).includes(String(targetValue));
      case 'STARTS_WITH':
        return String(value).startsWith(String(targetValue));
      case 'ENDS_WITH':
        return String(value).endsWith(String(targetValue));
      case 'IS_TRUE':
        return value === true;
      case 'IS_FALSE':
        return value === false;
      case 'EXISTS':
        return value !== null && value !== undefined;
      default:
        return false;
    }
  } catch (error) {
    console.error('Error evaluating criteria:', error);
    return false;
  }
}

// Helper function to check if task should be included based on license and outcomes
function shouldIncludeTask(task: any, customerLicenseLevel: LicenseLevel, selectedOutcomeIds: string[]): boolean {
  // Check license level (hierarchical: ESSENTIAL < ADVANTAGE < SIGNATURE)
  const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];
  const customerLevel = licenseLevels.indexOf(customerLicenseLevel);
  const taskLevel = licenseLevels.indexOf(task.licenseLevel);
  
  if (taskLevel > customerLevel) {
    return false; // Task requires higher license
  }
  
  // Check if task belongs to selected outcomes (if outcomes are specified)
  if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
    // Get task outcomes
    const taskOutcomeIds = task.outcomes?.map((o: any) => o.outcomeId) || [];
    // Task must have at least one matching outcome
    const hasMatchingOutcome = taskOutcomeIds.some((oid: string) => selectedOutcomeIds.includes(oid));
    if (!hasMatchingOutcome) {
      return false;
    }
  }
  
  return true;
}

export const CustomerAdoptionQueryResolvers = {
  customer: async (_: any, { id }: any, ctx: any) => {
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        products: {
          include: {
            product: true,
            adoptionPlan: {
              include: {
                tasks: true,
              },
            },
          },
        },
        solutions: {
          include: {
            solution: true,
          },
        },
      },
    });
    return customer;
  },

  adoptionPlan: async (_: any, { id }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: {
              include: {
                outcome: true,
              },
            },
            releases: {
              include: {
                release: true,
              },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    return plan;
  },

  adoptionPlansForCustomer: async (_: any, { customerId }: any, ctx: any) => {
    const customerProducts = await prisma.customerProduct.findMany({
      where: { customerId },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
      },
    });
    
    return customerProducts
      .filter((cp: any) => cp.adoptionPlan)
      .map((cp: any) => cp.adoptionPlan);
  },

  customerTask: async (_: any, { id }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            customerProduct: {
              include: {
                customer: true,
                product: true,
              },
            },
          },
        },
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
            },
          },
          orderBy: { order: 'asc' },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
    });
    return task;
  },

  customerTasksForPlan: async (_: any, { adoptionPlanId, status }: any, ctx: any) => {
    const where: any = { adoptionPlanId };
    if (status) {
      where.status = status;
    }
    
    const tasks = await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
    return tasks;
  },
};

export const CustomerAdoptionMutationResolvers = {
  assignProductToCustomer: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerId, productId, licenseLevel, selectedOutcomeIds } = input;
    
    // Check if assignment already exists
    const existing = await prisma.customerProduct.findUnique({
      where: {
        customerId_productId: { customerId, productId },
      },
    });
    
    if (existing) {
      throw new Error('Product already assigned to customer. Use updateCustomerProduct to modify.');
    }
    
    // Validate product exists
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });
    
    if (!product) {
      throw new Error('Product not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    // Create customer product assignment
    const customerProduct = await prisma.customerProduct.create({
      data: {
        customerId,
        productId,
        licenseLevel,
        selectedOutcomes: selectedOutcomeIds || [],
      },
      include: {
        customer: true,
        product: true,
      },
    });
    
    await logAudit('ASSIGN_PRODUCT_TO_CUSTOMER', 'CustomerProduct', customerProduct.id, { input }, ctx.user?.id);
    
    return customerProduct;
  },

  updateCustomerProduct: async (_: any, { id, input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { licenseLevel, selectedOutcomeIds } = input;
    
    const before = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: true,
      },
    });
    
    if (!before) {
      throw new Error('Customer product assignment not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId: before.productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    const updateData: any = {};
    if (licenseLevel) updateData.licenseLevel = licenseLevel;
    if (selectedOutcomeIds) updateData.selectedOutcomes = selectedOutcomeIds;
    
    const updated = await prisma.customerProduct.update({
      where: { id },
      data: updateData,
      include: {
        customer: true,
        product: true,
        adoptionPlan: true,
      },
    });
    
    // If adoption plan exists and license/outcomes changed, mark it for sync
    if (before.adoptionPlan) {
      await prisma.adoptionPlan.update({
        where: { id: before.adoptionPlan.id },
        data: { lastSyncedAt: null }, // Mark as needing sync
      });
    }
    
    await logAudit('UPDATE_CUSTOMER_PRODUCT', 'CustomerProduct', id, { before, after: updated }, ctx.user?.id);
    
    return updated;
  },

  removeProductFromCustomerEnhanced: async (_: any, { id }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id },
      include: { adoptionPlan: { include: { tasks: true } } },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    // Delete will cascade to adoption plan and tasks
    await prisma.customerProduct.delete({
      where: { id },
    });
    
    await logAudit('REMOVE_PRODUCT_FROM_CUSTOMER', 'CustomerProduct', id, {}, ctx.user?.id);
    
    return { success: true, message: 'Product removed from customer successfully' };
  },

  createAdoptionPlan: async (_: any, { customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    if (customerProduct.adoptionPlan) {
      throw new Error('Adoption plan already exists for this customer product');
    }
    
    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    
    // Filter tasks based on license level and outcomes
    const eligibleTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds)
    );
    
    // Calculate initial progress
    const progress = calculateProgress(eligibleTasks.map((t: any) => ({ ...t, status: 'NOT_STARTED' })));
    
    // Create adoption plan
    const adoptionPlan = await prisma.adoptionPlan.create({
      data: {
        customerProductId,
        productId: customerProduct.productId,
        productName: customerProduct.product.name,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        totalTasks: progress.totalTasks,
        completedTasks: 0,
        totalWeight: progress.totalWeight,
        completedWeight: 0,
        progressPercentage: 0,
        lastSyncedAt: new Date(),
      },
    });
    
    // Create customer tasks (snapshots of product tasks)
    for (const task of eligibleTasks) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: adoptionPlan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          priority: task.priority,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy outcome relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: {
            customerTaskId: customerTask.id,
            outcomeId: taskOutcome.outcomeId,
          },
        });
      }
      
      // Copy release relationships
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: {
            customerTaskId: customerTask.id,
            releaseId: taskRelease.releaseId,
          },
        });
      }
    }
    
    await logAudit('CREATE_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlan.id, { customerProductId }, ctx.user?.id);
    
    // Fetch complete plan with relations
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlan.id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: {
              include: { outcome: true },
            },
            releases: {
              include: { release: true },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  syncAdoptionPlan: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            product: {
              include: {
                tasks: {
                  where: { deletedAt: null },
                  include: {
                    telemetryAttributes: true,
                    outcomes: true,
                    releases: true,
                  },
                },
              },
            },
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: true,
            releases: true,
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    const { customerProduct } = plan;
    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    
    // Get current eligible tasks from product
    const eligibleProductTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds)
    );
    
    const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
    const currentCustomerTaskOriginalIds = plan.tasks.map((t: any) => t.originalTaskId);
    
    // Find tasks to remove (no longer eligible)
    const tasksToRemove = plan.tasks.filter(
      (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
    );
    
    // Find tasks to add (newly eligible)
    const tasksToAdd = eligibleProductTasks.filter(
      (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
    );
    
    // Remove obsolete tasks
    for (const task of tasksToRemove) {
      await prisma.customerTask.delete({ where: { id: task.id } });
    }
    
    // Add new tasks
    for (const task of tasksToAdd) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: plan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          priority: task.priority,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: { customerTaskId: customerTask.id, outcomeId: taskOutcome.outcomeId },
        });
      }
      
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: { customerTaskId: customerTask.id, releaseId: taskRelease.releaseId },
        });
      }
    }
    
    // Recalculate progress
    const updatedTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(updatedTasks);
    
    // Update adoption plan
    const updatedPlan = await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: {
        ...progress,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        lastSyncedAt: new Date(),
      },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    
    await logAudit('SYNC_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlanId, { tasksRemoved: tasksToRemove.length, tasksAdded: tasksToAdd.length }, ctx.user?.id);
    
    return updatedPlan;
  },

  updateCustomerTaskStatus: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerTaskId, status, notes } = input;
    
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: { adoptionPlan: true },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusNotes: notes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };
    
    const updated = await prisma.customerTask.update({
      where: { id: customerTaskId },
      data: updateData,
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: task.adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: task.adoptionPlanId },
      data: progress,
    });
    
    await logAudit('UPDATE_CUSTOMER_TASK_STATUS', 'CustomerTask', customerTaskId, { status, notes }, ctx.user?.id);
    
    return updated;
  },

  bulkUpdateCustomerTaskStatus: async (_: any, { adoptionPlanId, taskIds, status, notes }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusNotes: notes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };
    
    await prisma.customerTask.updateMany({
      where: {
        id: { in: taskIds },
        adoptionPlanId,
      },
      data: updateData,
    });
    
    // Fetch updated tasks
    const updatedTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
      },
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: progress,
    });
    
    await logAudit('BULK_UPDATE_CUSTOMER_TASK_STATUS', 'AdoptionPlan', adoptionPlanId, { taskIds, status, notes }, ctx.user?.id);
    
    return updatedTasks;
  },

  addCustomerTelemetryValue: async (_: any, { input }: any, ctx: any) => {
    const { customerAttributeId, value, source, batchId, notes } = input;
    
    const attribute = await prisma.customerTelemetryAttribute.findUnique({
      where: { id: customerAttributeId },
      include: { customerTask: { include: { adoptionPlan: true } } },
    });
    
    if (!attribute) {
      throw new Error('Customer telemetry attribute not found');
    }
    
    const telemetryValue = await prisma.customerTelemetryValue.create({
      data: {
        customerAttributeId,
        value,
        source: source || 'manual',
        batchId,
        notes,
      },
      include: {
        customerAttribute: true,
      },
    });
    
    await logAudit('ADD_CUSTOMER_TELEMETRY_VALUE', 'CustomerTelemetryValue', telemetryValue.id, { input }, ctx.user?.id);
    
    return telemetryValue;
  },

  bulkAddCustomerTelemetryValues: async (_: any, { inputs }: any, ctx: any) => {
    const createdValues = [];
    
    for (const input of inputs) {
      const { customerAttributeId, value, source, batchId, notes } = input;
      
      const telemetryValue = await prisma.customerTelemetryValue.create({
        data: {
          customerAttributeId,
          value,
          source: source || 'api',
          batchId,
          notes,
        },
        include: {
          customerAttribute: true,
        },
      });
      
      createdValues.push(telemetryValue);
    }
    
    await logAudit('BULK_ADD_CUSTOMER_TELEMETRY_VALUES', 'CustomerTelemetryValue', 'bulk', { count: inputs.length }, ctx.user?.id);
    
    return createdValues;
  },

  evaluateTaskTelemetry: async (_: any, { customerTaskId }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
      },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    // Skip if status was manually set by a user
    if (task.statusUpdatedBy && task.statusUpdatedBy !== 'telemetry') {
      // Don't override manual status changes
      return task;
    }
    
    const attributes = task.telemetryAttributes;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive);
    
    // Evaluate each attribute
    let metCount = 0;
    let metRequiredCount = 0;
    
    for (const attr of attributes) {
      if (!attr.isActive) continue;
      
      const latestValue = attr.values[0];
      if (!latestValue) continue;
      
      const isMet = evaluateCriteria(attr.successCriteria, latestValue.value);
      
      // Update attribute isMet status
      await prisma.customerTelemetryAttribute.update({
        where: { id: attr.id },
        data: {
          isMet,
          lastCheckedAt: new Date(),
        },
      });
      
      if (isMet) {
        metCount++;
        if (attr.isRequired) metRequiredCount++;
      }
    }
    
    // Determine new status
    let newStatus: CustomerTaskStatus = task.status;
    
    if (requiredAttributes.length > 0) {
      if (metRequiredCount === requiredAttributes.length) {
        newStatus = 'DONE';
      } else if (metCount > 0) {
        newStatus = 'IN_PROGRESS';
      } else {
        newStatus = 'NOT_STARTED';
      }
    }
    
    // Update task status if changed
    if (newStatus !== task.status) {
      const updated = await prisma.customerTask.update({
        where: { id: customerTaskId },
        data: {
          status: newStatus,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: 'telemetry',
          statusNotes: 'Automatically updated based on telemetry criteria',
          isComplete: newStatus === 'DONE',
          completedAt: newStatus === 'DONE' ? new Date() : null,
          completedBy: newStatus === 'DONE' ? 'telemetry' : null,
        },
        include: {
          adoptionPlan: true,
          telemetryAttributes: {
            include: {
              values: {
                orderBy: { createdAt: 'desc' },
                take: 1,
              },
            },
          },
          outcomes: { include: { outcome: true } },
          releases: { include: { release: true } },
        },
      });
      
      // Recalculate adoption plan progress
      const allTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId: task.adoptionPlanId },
      });
      
      const progress = calculateProgress(allTasks);
      
      await prisma.adoptionPlan.update({
        where: { id: task.adoptionPlanId },
        data: progress,
      });
      
      await logAudit('EVALUATE_TASK_TELEMETRY', 'CustomerTask', customerTaskId, { oldStatus: task.status, newStatus }, ctx.user?.id);
      
      return updated;
    }
    
    return task;
  },

  evaluateAllTasksTelemetry: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    // Evaluate each task
    for (const task of plan.tasks) {
      // Only update tasks with telemetry-driven status
      if (!task.statusUpdatedBy || task.statusUpdatedBy === 'telemetry') {
        await CustomerAdoptionMutationResolvers.evaluateTaskTelemetry(
          _,
          { customerTaskId: task.id },
          ctx
        );
      }
    }
    
    // Return updated plan
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },
};

// Field resolvers
export const CustomerProductWithPlanResolvers = {
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
};

export const AdoptionPlanResolvers = {
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  
  tasksByStatus: async (parent: any, { status }: any) => {
    const where: any = { adoptionPlanId: parent.id };
    if (status) where.status = status;
    
    return await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
  },
  
  needsSync: async (parent: any) => {
    if (!parent.lastSyncedAt) return true;
    
    // Check if product has been updated since last sync
    const product = await prisma.product.findUnique({
      where: { id: parent.productId },
    });
    
    if (!product) return false;
    
    return product.updatedAt > parent.lastSyncedAt;
  },
};

export const CustomerTaskResolvers = {
  outcomes: async (parent: any) => {
    const taskOutcomes = await prisma.customerTaskOutcome.findMany({
      where: { customerTaskId: parent.id },
      include: { outcome: true },
    });
    
    return taskOutcomes.map((to: any) => to.outcome);
  },
  
  releases: async (parent: any) => {
    const taskReleases = await prisma.customerTaskRelease.findMany({
      where: { customerTaskId: parent.id },
      include: { release: true },
    });
    
    return taskReleases.map((tr: any) => tr.release);
  },
  
  telemetryProgress: async (parent: any) => {
    const attributes = await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
    });
    
    const totalAttributes = attributes.filter((a: any) => a.isActive).length;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive).length;
    const metAttributes = attributes.filter((a: any) => a.isMet && a.isActive).length;
    const metRequiredAttributes = attributes.filter((a: any) => a.isMet && a.isRequired && a.isActive).length;
    
    const completionPercentage = totalAttributes > 0 ? (metAttributes / totalAttributes) * 100 : 0;
    const allRequiredMet = requiredAttributes > 0 && metRequiredAttributes === requiredAttributes;
    
    return {
      totalAttributes,
      requiredAttributes,
      metAttributes,
      metRequiredAttributes,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
      allRequiredMet,
    };
  },
};

export const CustomerTelemetryAttributeResolvers = {
  latestValue: async (parent: any) => {
    const value = await prisma.customerTelemetryValue.findFirst({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
    });
    
    return value;
  },
};
