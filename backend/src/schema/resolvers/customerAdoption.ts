import { prisma } from '../../context';
import { ensureRole } from '../../lib/auth';
import { logAudit } from '../../lib/audit';
import { LicenseLevel } from '@prisma/client';

// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';

// Helper function to calculate progress
function calculateProgress(tasks: any[]): {
  totalTasks: number;
  completedTasks: number;
  totalWeight: number;
  completedWeight: number;
  progressPercentage: number;
} {
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(t => t.status === 'DONE').length;
  
  const totalWeight = tasks.reduce((sum, task) => {
    const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
      ? task.weight.toNumber() 
      : Number(task.weight || 0);
    return sum + weight;
  }, 0);
  
  const completedWeight = tasks
    .filter(t => t.status === 'DONE')
    .reduce((sum, task) => {
      const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
        ? task.weight.toNumber() 
        : Number(task.weight || 0);
      return sum + weight;
    }, 0);
  
  const progressPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;
  
  return {
    totalTasks,
    completedTasks,
    totalWeight,
    completedWeight,
    progressPercentage: Math.round(progressPercentage * 100) / 100, // Round to 2 decimals
  };
}

// Helper function to evaluate telemetry criteria
function evaluateCriteria(criteria: any, value: any): boolean {
  try {
    if (!criteria || typeof criteria !== 'object') return false;
    
    const { operator, targetValue, conditions } = criteria;
    
    // Handle AND/OR logic for multiple conditions
    if (conditions && Array.isArray(conditions)) {
      if (operator === 'AND') {
        return conditions.every((cond: any) => evaluateCriteria(cond, value));
      } else if (operator === 'OR') {
        return conditions.some((cond: any) => evaluateCriteria(cond, value));
      }
    }
    
    // Handle single condition
    if (!operator || targetValue === undefined) return false;
    
    switch (operator.toUpperCase()) {
      case 'EQUALS':
      case 'EQ':
        return value === targetValue;
      case 'NOT_EQUALS':
      case 'NE':
        return value !== targetValue;
      case 'GREATER_THAN':
      case 'GT':
        return Number(value) > Number(targetValue);
      case 'GREATER_THAN_OR_EQUAL':
      case 'GTE':
        return Number(value) >= Number(targetValue);
      case 'LESS_THAN':
      case 'LT':
        return Number(value) < Number(targetValue);
      case 'LESS_THAN_OR_EQUAL':
      case 'LTE':
        return Number(value) <= Number(targetValue);
      case 'CONTAINS':
        return String(value).includes(String(targetValue));
      case 'STARTS_WITH':
        return String(value).startsWith(String(targetValue));
      case 'ENDS_WITH':
        return String(value).endsWith(String(targetValue));
      case 'IS_TRUE':
        return value === true;
      case 'IS_FALSE':
        return value === false;
      case 'EXISTS':
        return value !== null && value !== undefined;
      default:
        return false;
    }
  } catch (error) {
    console.error('Error evaluating criteria:', error);
    return false;
  }
}

// Helper function to check if task should be included based on license and outcomes
function shouldIncludeTask(task: any, customerLicenseLevel: LicenseLevel, selectedOutcomeIds: string[]): boolean {
  // Check license level (hierarchical: ESSENTIAL < ADVANTAGE < SIGNATURE)
  const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];
  const customerLevel = licenseLevels.indexOf(customerLicenseLevel);
  const taskLevel = licenseLevels.indexOf(task.licenseLevel);
  
  if (taskLevel > customerLevel) {
    return false; // Task requires higher license
  }
  
  // Check if task belongs to selected outcomes (if outcomes are specified)
  if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
    // Get task outcomes
    const taskOutcomeIds = task.outcomes?.map((o: any) => o.outcomeId) || [];
    // Task must have at least one matching outcome
    const hasMatchingOutcome = taskOutcomeIds.some((oid: string) => selectedOutcomeIds.includes(oid));
    if (!hasMatchingOutcome) {
      return false;
    }
  }
  
  return true;
}

export const CustomerAdoptionQueryResolvers = {
  customer: async (_: any, { id }: any, ctx: any) => {
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        products: {
          include: {
            product: true,
            adoptionPlan: {
              include: {
                tasks: true,
              },
            },
          },
        },
        solutions: {
          include: {
            solution: true,
          },
        },
      },
    });
    return customer;
  },

  adoptionPlan: async (_: any, { id }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: {
              include: {
                outcome: true,
              },
            },
            releases: {
              include: {
                release: true,
              },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    return plan;
  },

  adoptionPlansForCustomer: async (_: any, { customerId }: any, ctx: any) => {
    const customerProducts = await prisma.customerProduct.findMany({
      where: { customerId },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
      },
    });
    
    return customerProducts
      .filter((cp: any) => cp.adoptionPlan)
      .map((cp: any) => cp.adoptionPlan);
  },

  customerTask: async (_: any, { id }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            customerProduct: {
              include: {
                customer: true,
                product: true,
              },
            },
          },
        },
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
            },
          },
          orderBy: { order: 'asc' },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
    });
    return task;
  },

  customerTasksForPlan: async (_: any, { adoptionPlanId, status }: any, ctx: any) => {
    const where: any = { adoptionPlanId };
    if (status) {
      where.status = status;
    }
    
    const tasks = await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
    return tasks;
  },

  customerTelemetryDatabase: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    const where: any = {};
    
    if (customerProductId) {
      where.customerProductId = customerProductId;
    } else if (customerId) {
      where.customerId = customerId;
    }

    const customerProducts = await prisma.customerProduct.findMany({
      where,
      include: {
        customer: true,
        product: true,
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: {
                  where: { isActive: true },
                  include: {
                    values: {
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    const records: any[] = [];

    for (const cp of customerProducts) {
      for (const plan of cp.adoptionPlans) {
        for (const task of plan.tasks) {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            records.push({
              customerId: cp.customer.id,
              customerName: cp.customer.name,
              customerProductId: cp.id,
              productId: cp.product.id,
              productName: cp.product.name,
              licenseLevel: cp.licenseLevel,
              adoptionPlanId: plan.id,
              taskId: task.id,
              taskName: task.name,
              taskSequenceNumber: task.sequenceNumber,
              attributeId: attr.id,
              attributeName: attr.name,
              attributeType: attr.attributeType,
              attributeRequired: attr.isRequired,
              attributeCriteria: attr.successCriteria,
              latestValue: latestValue?.value || null,
              latestValueDate: latestValue?.createdAt || null,
              criteriaMet,
              taskStatus: task.status,
            });
          }
        }
      }
    }

    return records;
  },
};

export const CustomerAdoptionMutationResolvers = {
  assignProductToCustomer: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerId, productId, licenseLevel, selectedOutcomeIds } = input;
    
    // Check if assignment already exists
    const existing = await prisma.customerProduct.findUnique({
      where: {
        customerId_productId: { customerId, productId },
      },
    });
    
    if (existing) {
      throw new Error('Product already assigned to customer. Use updateCustomerProduct to modify.');
    }
    
    // Validate product exists
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });
    
    if (!product) {
      throw new Error('Product not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    // Create customer product assignment
    const customerProduct = await prisma.customerProduct.create({
      data: {
        customerId,
        productId,
        licenseLevel,
        selectedOutcomes: selectedOutcomeIds || [],
      },
      include: {
        customer: true,
        product: true,
      },
    });
    
    await logAudit('ASSIGN_PRODUCT_TO_CUSTOMER', 'CustomerProduct', customerProduct.id, { input }, ctx.user?.id);
    
    return customerProduct;
  },

  updateCustomerProduct: async (_: any, { id, input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { licenseLevel, selectedOutcomeIds } = input;
    
    const before = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: true,
      },
    });
    
    if (!before) {
      throw new Error('Customer product assignment not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId: before.productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    const updateData: any = {};
    if (licenseLevel) updateData.licenseLevel = licenseLevel;
    if (selectedOutcomeIds) updateData.selectedOutcomes = selectedOutcomeIds;
    
    const updated = await prisma.customerProduct.update({
      where: { id },
      data: updateData,
      include: {
        customer: true,
        product: true,
        adoptionPlan: true,
      },
    });
    
    // If adoption plan exists and license/outcomes changed, mark it for sync
    if (before.adoptionPlan) {
      await prisma.adoptionPlan.update({
        where: { id: before.adoptionPlan.id },
        data: { lastSyncedAt: null }, // Mark as needing sync
      });
    }
    
    await logAudit('UPDATE_CUSTOMER_PRODUCT', 'CustomerProduct', id, { before, after: updated }, ctx.user?.id);
    
    return updated;
  },

  removeProductFromCustomerEnhanced: async (_: any, { id }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id },
      include: { adoptionPlan: { include: { tasks: true } } },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    // Delete will cascade to adoption plan and tasks
    await prisma.customerProduct.delete({
      where: { id },
    });
    
    await logAudit('REMOVE_PRODUCT_FROM_CUSTOMER', 'CustomerProduct', id, {}, ctx.user?.id);
    
    return { success: true, message: 'Product removed from customer successfully' };
  },

  createAdoptionPlan: async (_: any, { customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    if (customerProduct.adoptionPlan) {
      throw new Error('Adoption plan already exists for this customer product');
    }
    
    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    
    // Filter tasks based on license level and outcomes
    const eligibleTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds)
    );
    
    // Calculate initial progress
    const progress = calculateProgress(eligibleTasks.map((t: any) => ({ ...t, status: 'NOT_STARTED' })));
    
    // Create adoption plan
    const adoptionPlan = await prisma.adoptionPlan.create({
      data: {
        customerProductId,
        productId: customerProduct.productId,
        productName: customerProduct.product.name,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        totalTasks: progress.totalTasks,
        completedTasks: 0,
        totalWeight: progress.totalWeight,
        completedWeight: 0,
        progressPercentage: 0,
        lastSyncedAt: new Date(),
      },
    });
    
    // Create customer tasks (snapshots of product tasks)
    for (const task of eligibleTasks) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: adoptionPlan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          priority: task.priority,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy outcome relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: {
            customerTaskId: customerTask.id,
            outcomeId: taskOutcome.outcomeId,
          },
        });
      }
      
      // Copy release relationships
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: {
            customerTaskId: customerTask.id,
            releaseId: taskRelease.releaseId,
          },
        });
      }
    }
    
    await logAudit('CREATE_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlan.id, { customerProductId }, ctx.user?.id);
    
    // Fetch complete plan with relations
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlan.id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: {
              include: { outcome: true },
            },
            releases: {
              include: { release: true },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  syncAdoptionPlan: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            product: {
              include: {
                tasks: {
                  where: { deletedAt: null },
                  include: {
                    telemetryAttributes: true,
                    outcomes: true,
                    releases: true,
                  },
                },
              },
            },
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: true,
            releases: true,
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    const { customerProduct } = plan;
    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    
    // Get current eligible tasks from product
    const eligibleProductTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds)
    );
    
    const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
    const currentCustomerTaskOriginalIds = plan.tasks.map((t: any) => t.originalTaskId);
    
    // Find tasks to remove (no longer eligible)
    const tasksToRemove = plan.tasks.filter(
      (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
    );
    
    // Find tasks to add (newly eligible)
    const tasksToAdd = eligibleProductTasks.filter(
      (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
    );
    
    // Remove obsolete tasks
    for (const task of tasksToRemove) {
      await prisma.customerTask.delete({ where: { id: task.id } });
    }
    
    // Add new tasks
    for (const task of tasksToAdd) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: plan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          priority: task.priority,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: { customerTaskId: customerTask.id, outcomeId: taskOutcome.outcomeId },
        });
      }
      
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: { customerTaskId: customerTask.id, releaseId: taskRelease.releaseId },
        });
      }
    }
    
    // Recalculate progress
    const updatedTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(updatedTasks);
    
    // Update adoption plan
    const updatedPlan = await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: {
        ...progress,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        lastSyncedAt: new Date(),
      },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    
    await logAudit('SYNC_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlanId, { tasksRemoved: tasksToRemove.length, tasksAdded: tasksToAdd.length }, ctx.user?.id);
    
    return updatedPlan;
  },

  updateCustomerTaskStatus: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerTaskId, status, notes } = input;
    
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: { adoptionPlan: true },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusNotes: notes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };
    
    const updated = await prisma.customerTask.update({
      where: { id: customerTaskId },
      data: updateData,
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: task.adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: task.adoptionPlanId },
      data: progress,
    });
    
    await logAudit('UPDATE_CUSTOMER_TASK_STATUS', 'CustomerTask', customerTaskId, { status, notes }, ctx.user?.id);
    
    return updated;
  },

  bulkUpdateCustomerTaskStatus: async (_: any, { adoptionPlanId, taskIds, status, notes }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusNotes: notes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };
    
    await prisma.customerTask.updateMany({
      where: {
        id: { in: taskIds },
        adoptionPlanId,
      },
      data: updateData,
    });
    
    // Fetch updated tasks
    const updatedTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
      },
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: progress,
    });
    
    await logAudit('BULK_UPDATE_CUSTOMER_TASK_STATUS', 'AdoptionPlan', adoptionPlanId, { taskIds, status, notes }, ctx.user?.id);
    
    return updatedTasks;
  },

  addCustomerTelemetryValue: async (_: any, { input }: any, ctx: any) => {
    const { customerAttributeId, value, source, batchId, notes } = input;
    
    const attribute = await prisma.customerTelemetryAttribute.findUnique({
      where: { id: customerAttributeId },
      include: { customerTask: { include: { adoptionPlan: true } } },
    });
    
    if (!attribute) {
      throw new Error('Customer telemetry attribute not found');
    }
    
    const telemetryValue = await prisma.customerTelemetryValue.create({
      data: {
        customerAttributeId,
        value,
        source: source || 'manual',
        batchId,
        notes,
      },
      include: {
        customerAttribute: true,
      },
    });
    
    await logAudit('ADD_CUSTOMER_TELEMETRY_VALUE', 'CustomerTelemetryValue', telemetryValue.id, { input }, ctx.user?.id);
    
    return telemetryValue;
  },

  bulkAddCustomerTelemetryValues: async (_: any, { inputs }: any, ctx: any) => {
    const createdValues = [];
    
    for (const input of inputs) {
      const { customerAttributeId, value, source, batchId, notes } = input;
      
      const telemetryValue = await prisma.customerTelemetryValue.create({
        data: {
          customerAttributeId,
          value,
          source: source || 'api',
          batchId,
          notes,
        },
        include: {
          customerAttribute: true,
        },
      });
      
      createdValues.push(telemetryValue);
    }
    
    await logAudit('BULK_ADD_CUSTOMER_TELEMETRY_VALUES', 'CustomerTelemetryValue', 'bulk', { count: inputs.length }, ctx.user?.id);
    
    return createdValues;
  },

  evaluateTaskTelemetry: async (_: any, { customerTaskId }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
      },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    // Skip if status was manually set by a user
    if (task.statusUpdatedBy && task.statusUpdatedBy !== 'telemetry') {
      // Don't override manual status changes
      return task;
    }
    
    const attributes = task.telemetryAttributes;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive);
    
    // Evaluate each attribute
    let metCount = 0;
    let metRequiredCount = 0;
    
    for (const attr of attributes) {
      if (!attr.isActive) continue;
      
      const latestValue = attr.values[0];
      if (!latestValue) continue;
      
      const isMet = evaluateCriteria(attr.successCriteria, latestValue.value);
      
      // Update attribute isMet status
      await prisma.customerTelemetryAttribute.update({
        where: { id: attr.id },
        data: {
          isMet,
          lastCheckedAt: new Date(),
        },
      });
      
      if (isMet) {
        metCount++;
        if (attr.isRequired) metRequiredCount++;
      }
    }
    
    // Determine new status
    let newStatus: CustomerTaskStatus = task.status;
    
    if (requiredAttributes.length > 0) {
      if (metRequiredCount === requiredAttributes.length) {
        newStatus = 'DONE';
      } else if (metCount > 0) {
        newStatus = 'IN_PROGRESS';
      } else {
        newStatus = 'NOT_STARTED';
      }
    }
    
    // Update task status if changed
    if (newStatus !== task.status) {
      const updated = await prisma.customerTask.update({
        where: { id: customerTaskId },
        data: {
          status: newStatus,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: 'telemetry',
          statusNotes: 'Automatically updated based on telemetry criteria',
          isComplete: newStatus === 'DONE',
          completedAt: newStatus === 'DONE' ? new Date() : null,
          completedBy: newStatus === 'DONE' ? 'telemetry' : null,
        },
        include: {
          adoptionPlan: true,
          telemetryAttributes: {
            include: {
              values: {
                orderBy: { createdAt: 'desc' },
                take: 1,
              },
            },
          },
          outcomes: { include: { outcome: true } },
          releases: { include: { release: true } },
        },
      });
      
      // Recalculate adoption plan progress
      const allTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId: task.adoptionPlanId },
      });
      
      const progress = calculateProgress(allTasks);
      
      await prisma.adoptionPlan.update({
        where: { id: task.adoptionPlanId },
        data: progress,
      });
      
      await logAudit('EVALUATE_TASK_TELEMETRY', 'CustomerTask', customerTaskId, { oldStatus: task.status, newStatus }, ctx.user?.id);
      
      return updated;
    }
    
    return task;
  },

  evaluateAllTasksTelemetry: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    // Evaluate each task
    for (const task of plan.tasks) {
      // Only update tasks with telemetry-driven status
      if (!task.statusUpdatedBy || task.statusUpdatedBy === 'telemetry') {
        await CustomerAdoptionMutationResolvers.evaluateTaskTelemetry(
          _,
          { customerTaskId: task.id },
          ctx
        );
      }
    }
    
    // Return updated plan
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  exportCustomerAdoptionToExcel: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        customer: true,
        product: true,
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: {
                  include: {
                    values: {
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
                outcomes: { include: { outcome: true } },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Customer Adoption Data');

    // Headers
    worksheet.columns = [
      { header: 'Customer ID', key: 'customerId', width: 20 },
      { header: 'Customer Name', key: 'customerName', width: 30 },
      { header: 'Product ID', key: 'productId', width: 20 },
      { header: 'Product Name', key: 'productName', width: 30 },
      { header: 'License Level', key: 'licenseLevel', width: 15 },
      { header: 'Task Sequence', key: 'taskSequence', width: 12 },
      { header: 'Task Name', key: 'taskName', width: 40 },
      { header: 'Task Status', key: 'taskStatus', width: 15 },
      { header: 'Telemetry Attribute', key: 'telemetryAttribute', width: 30 },
      { header: 'Attribute Type', key: 'attributeType', width: 15 },
      { header: 'Required', key: 'required', width: 10 },
      { header: 'Current Value', key: 'currentValue', width: 30 },
      { header: 'Last Updated', key: 'lastUpdated', width: 20 },
      { header: 'Criteria Met', key: 'criteriaMet', width: 12 },
    ];

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    };

    const adoptionPlan = customerProduct.adoptionPlans[0];
    if (adoptionPlan) {
      for (const task of adoptionPlan.tasks) {
        if (task.telemetryAttributes.length === 0) {
          // Task with no telemetry
          worksheet.addRow({
            customerId: customerProduct.customer.id,
            customerName: customerProduct.customer.name,
            productId: customerProduct.product.id,
            productName: customerProduct.product.name,
            licenseLevel: customerProduct.licenseLevel,
            taskSequence: task.sequenceNumber,
            taskName: task.name,
            taskStatus: task.status,
            telemetryAttribute: '',
            attributeType: '',
            required: '',
            currentValue: '',
            lastUpdated: '',
            criteriaMet: '',
          });
        } else {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            worksheet.addRow({
              customerId: customerProduct.customer.id,
              customerName: customerProduct.customer.name,
              productId: customerProduct.product.id,
              productName: customerProduct.product.name,
              licenseLevel: customerProduct.licenseLevel,
              taskSequence: task.sequenceNumber,
              taskName: task.name,
              taskStatus: task.status,
              telemetryAttribute: attr.name,
              attributeType: attr.attributeType,
              required: attr.isRequired ? 'Yes' : 'No',
              currentValue: latestValue ? JSON.stringify(latestValue.value) : '',
              lastUpdated: latestValue ? latestValue.createdAt.toISOString() : '',
              criteriaMet: criteriaMet === null ? '' : criteriaMet ? 'Yes' : 'No',
            });
          }
        }
      }
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const content = Buffer.from(buffer).toString('base64');
    const filename = `${customerProduct.customer.name}_${customerProduct.product.name}_adoption.xlsx`;

    await logAudit('EXPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { filename }, ctx.user?.id);

    return {
      filename,
      content,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      size: buffer.byteLength,
      stats: {
        tasksExported: adoptionPlan?.tasks.length || 0,
        customAttributesExported: 0,
        licensesExported: 0,
        outcomesExported: 0,
        releasesExported: 0,
        telemetryAttributesExported: adoptionPlan?.tasks.reduce((sum: any, t: any) => sum + t.telemetryAttributes.length, 0) || 0,
      },
    };
  },

  importCustomerAdoptionFromExcel: async (_: any, { content }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');
    const workbook = new ExcelJS.Workbook();
    const buffer = Buffer.from(content, 'base64');
    await workbook.xlsx.load(buffer.buffer as ArrayBuffer);

    const worksheet = workbook.getWorksheet('Customer Adoption Data');
    if (!worksheet) {
      throw new Error('Worksheet "Customer Adoption Data" not found');
    }

    const errors: any[] = [];
    const warnings: any[] = [];
    let telemetryValuesImported = 0;
    let taskStatusesUpdated = 0;
    let attributesCreated = 0;

    let customerId = '';
    let customerName = '';
    let customerProductId = '';
    let productName = '';

    const rows: any[] = [];
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header
      rows.push({
        rowNumber,
        customerId: row.getCell(1).value,
        customerName: row.getCell(2).value,
        productId: row.getCell(3).value,
        productName: row.getCell(4).value,
        licenseLevel: row.getCell(5).value,
        taskSequence: row.getCell(6).value,
        taskName: row.getCell(7).value,
        taskStatus: row.getCell(8).value,
        telemetryAttribute: row.getCell(9).value,
        attributeType: row.getCell(10).value,
        required: row.getCell(11).value,
        currentValue: row.getCell(12).value,
        lastUpdated: row.getCell(13).value,
        criteriaMet: row.getCell(14).value,
      });
    });

    if (rows.length === 0) {
      throw new Error('No data rows found in worksheet');
    }

    // Get customer and product from first row
    const firstRow = rows[0];
    customerId = firstRow.customerId;
    customerName = firstRow.customerName;
    productName = firstRow.productName;

    // Find customer product
    const customerProduct = await prisma.customerProduct.findFirst({
      where: {
        customerId: customerId,
        productId: firstRow.productId,
      },
      include: {
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
              },
            },
          },
        },
      },
    });

    if (!customerProduct) {
      throw new Error(`Customer product assignment not found for customer ${customerName} and product ${productName}`);
    }

    customerProductId = customerProduct.id;
    const adoptionPlan = customerProduct.adoptionPlans[0];

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    // Process each row
    for (const row of rows) {
      try {
        // Find task by sequence number
        const task = adoptionPlan.tasks.find((t: any) => t.sequenceNumber === Number(row.taskSequence));
        
        if (!task) {
          warnings.push({
            row: row.rowNumber,
            field: 'taskSequence',
            message: `Task with sequence ${row.taskSequence} not found`,
          });
          continue;
        }

        // Update task status if changed
        if (row.taskStatus && row.taskStatus !== task.status) {
          await prisma.customerTask.update({
            where: { id: task.id },
            data: {
              status: row.taskStatus as any,
              statusUpdatedBy: 'import',
              statusUpdatedAt: new Date(),
            },
          });
          taskStatusesUpdated++;
        }

        // Process telemetry if present
        if (row.telemetryAttribute && row.currentValue) {
          // Find or create telemetry attribute
          let attribute = task.telemetryAttributes.find((a: any) => a.name === row.telemetryAttribute);
          
          if (!attribute) {
            attribute = await prisma.customerTelemetryAttribute.create({
              data: {
                customerTaskId: task.id,
                name: row.telemetryAttribute,
                attributeType: row.attributeType || 'TEXT',
                isRequired: row.required === 'Yes',
                isActive: true,
              },
            });
            attributesCreated++;
          }

          // Parse value
          let parsedValue: any;
          try {
            parsedValue = JSON.parse(row.currentValue);
          } catch {
            parsedValue = row.currentValue;
          }

          // Create telemetry value
          await prisma.customerTelemetryValue.create({
            data: {
              customerAttributeId: attribute.id,
              value: parsedValue,
              batchId: `import_${Date.now()}`,
            },
          });
          telemetryValuesImported++;
        }
      } catch (error: any) {
        errors.push({
          row: row.rowNumber,
          field: 'general',
          message: error.message,
        });
      }
    }

    // Recalculate progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: adoptionPlan.id },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: adoptionPlan.id },
      data: progress,
    });

    await logAudit('IMPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { telemetryValuesImported, taskStatusesUpdated }, ctx.user?.id);

    return {
      success: errors.length === 0,
      customerId,
      customerName,
      customerProductId,
      productName,
      stats: {
        telemetryValuesImported,
        taskStatusesUpdated,
        attributesCreated,
      },
      errors,
      warnings,
    };
  },
};

// Field resolvers
export const CustomerProductWithPlanResolvers = {
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
};

export const AdoptionPlanResolvers = {
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  
  tasksByStatus: async (parent: any, { status }: any) => {
    const where: any = { adoptionPlanId: parent.id };
    if (status) where.status = status;
    
    return await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
  },
  
  needsSync: async (parent: any) => {
    if (!parent.lastSyncedAt) return true;
    
    // Check if product has been updated since last sync
    const product = await prisma.product.findUnique({
      where: { id: parent.productId },
    });
    
    if (!product) return false;
    
    return product.updatedAt > parent.lastSyncedAt;
  },
};

export const CustomerTaskResolvers = {
  outcomes: async (parent: any) => {
    const taskOutcomes = await prisma.customerTaskOutcome.findMany({
      where: { customerTaskId: parent.id },
      include: { outcome: true },
    });
    
    return taskOutcomes.map((to: any) => to.outcome);
  },
  
  releases: async (parent: any) => {
    const taskReleases = await prisma.customerTaskRelease.findMany({
      where: { customerTaskId: parent.id },
      include: { release: true },
    });
    
    return taskReleases.map((tr: any) => tr.release);
  },
  
  telemetryProgress: async (parent: any) => {
    const attributes = await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
    });
    
    const totalAttributes = attributes.filter((a: any) => a.isActive).length;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive).length;
    const metAttributes = attributes.filter((a: any) => a.isMet && a.isActive).length;
    const metRequiredAttributes = attributes.filter((a: any) => a.isMet && a.isRequired && a.isActive).length;
    
    const completionPercentage = totalAttributes > 0 ? (metAttributes / totalAttributes) * 100 : 0;
    const allRequiredMet = requiredAttributes > 0 && metRequiredAttributes === requiredAttributes;
    
    return {
      totalAttributes,
      requiredAttributes,
      metAttributes,
      metRequiredAttributes,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
      allRequiredMet,
    };
  },
};

export const CustomerTelemetryAttributeResolvers = {
  latestValue: async (parent: any) => {
    const value = await prisma.customerTelemetryValue.findFirst({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
    });
    
    return value;
  },
};
