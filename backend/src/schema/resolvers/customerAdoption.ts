import { prisma } from '../../context';
import { ensureRole } from '../../lib/auth';
import { logAudit } from '../../lib/audit';
import { LicenseLevel } from '@prisma/client';
import { CustomerTelemetryExportService } from '../../services/telemetry/CustomerTelemetryExportService';
import { CustomerTelemetryImportService } from '../../services/telemetry/CustomerTelemetryImportService';
import { evaluateTelemetryAttribute } from '../../services/telemetry/evaluationEngine';
import * as fs from 'fs';
import * as path from 'path';

// Import CustomerTaskStatus enum (generated by Prisma)
type CustomerTaskStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'DONE' | 'NOT_APPLICABLE';

// Helper function to calculate progress
function calculateProgress(tasks: any[]): {
  totalTasks: number;
  completedTasks: number;
  totalWeight: number;
  completedWeight: number;
  progressPercentage: number;
} {
  // Filter out NOT_APPLICABLE tasks - they should not count towards progress
  const applicableTasks = tasks.filter(t => t.status !== 'NOT_APPLICABLE');
  
  const totalTasks = applicableTasks.length;
  const completedTasks = applicableTasks.filter(t => t.status === 'COMPLETED' || t.status === 'DONE').length;
  
  const totalWeight = applicableTasks.reduce((sum, task) => {
    const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
      ? task.weight.toNumber() 
      : Number(task.weight || 0);
    return sum + weight;
  }, 0);
  
  const completedWeight = applicableTasks
    .filter(t => t.status === 'COMPLETED' || t.status === 'DONE')
    .reduce((sum, task) => {
      const weight = typeof task.weight === 'object' && 'toNumber' in task.weight 
        ? task.weight.toNumber() 
        : Number(task.weight || 0);
      return sum + weight;
    }, 0);
  
  const progressPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;
  
  return {
    totalTasks,
    completedTasks,
    totalWeight,
    completedWeight,
    progressPercentage: Math.round(progressPercentage * 100) / 100, // Round to 2 decimals
  };
}

// Helper function to evaluate telemetry criteria
function evaluateCriteria(criteria: any, value: any): boolean {
  try {
    if (!criteria || typeof criteria !== 'object') return false;
    
    const { operator, targetValue, conditions } = criteria;
    
    // Handle AND/OR logic for multiple conditions
    if (conditions && Array.isArray(conditions)) {
      if (operator === 'AND') {
        return conditions.every((cond: any) => evaluateCriteria(cond, value));
      } else if (operator === 'OR') {
        return conditions.some((cond: any) => evaluateCriteria(cond, value));
      }
    }
    
    // Handle single condition
    if (!operator || targetValue === undefined) return false;
    
    switch (operator.toUpperCase()) {
      case 'EQUALS':
      case 'EQ':
        return value === targetValue;
      case 'NOT_EQUALS':
      case 'NE':
        return value !== targetValue;
      case 'GREATER_THAN':
      case 'GT':
        return Number(value) > Number(targetValue);
      case 'GREATER_THAN_OR_EQUAL':
      case 'GTE':
        return Number(value) >= Number(targetValue);
      case 'LESS_THAN':
      case 'LT':
        return Number(value) < Number(targetValue);
      case 'LESS_THAN_OR_EQUAL':
      case 'LTE':
        return Number(value) <= Number(targetValue);
      case 'CONTAINS':
        return String(value).includes(String(targetValue));
      case 'STARTS_WITH':
        return String(value).startsWith(String(targetValue));
      case 'ENDS_WITH':
        return String(value).endsWith(String(targetValue));
      case 'IS_TRUE':
        return value === true;
      case 'IS_FALSE':
        return value === false;
      case 'EXISTS':
        return value !== null && value !== undefined;
      default:
        return false;
    }
  } catch (error) {
    console.error('Error evaluating criteria:', error);
    return false;
  }
}

// Helper function to check if task should be included based on license and outcomes
function shouldIncludeTask(
  task: any, 
  customerLicenseLevel: LicenseLevel, 
  selectedOutcomeIds: string[],
  selectedReleaseIds?: string[]
): boolean {
  // Check license level (hierarchical comparison using case-insensitive matching)
  // Support both uppercase enum (ESSENTIAL) and capitalized (Essential) formats
  const licenseLevels = ['ESSENTIAL', 'ADVANTAGE', 'SIGNATURE'];
  
  const customerLevel = licenseLevels.indexOf(customerLicenseLevel.toUpperCase());
  const taskLevel = licenseLevels.indexOf(task.licenseLevel.toUpperCase());
  
  // If license level not found in hierarchy, skip this task (safety check)
  if (taskLevel === -1) {
    console.warn(`Unknown task license level: ${task.licenseLevel}`);
    return false;
  }
  
  if (customerLevel === -1) {
    console.warn(`Unknown customer license level: ${customerLicenseLevel}`);
    return false;
  }
  
  if (taskLevel > customerLevel) {
    return false; // Task requires higher license
  }
  
  // Check if task belongs to selected outcomes (if outcomes are specified)
  if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
    // Get task outcomes
    const taskOutcomeIds = task.outcomes?.map((o: any) => o.outcomeId) || [];
    // Task must have at least one matching outcome
    const hasMatchingOutcome = taskOutcomeIds.some((oid: string) => selectedOutcomeIds.includes(oid));
    if (!hasMatchingOutcome) {
      return false;
    }
  }
  
  // Check if task belongs to selected releases (if releases are specified)
  if (selectedReleaseIds && selectedReleaseIds.length > 0) {
    // Get task releases
    const taskReleaseIds = task.releases?.map((r: any) => r.releaseId) || [];
    // Task must have at least one matching release
    const hasMatchingRelease = taskReleaseIds.some((rid: string) => selectedReleaseIds.includes(rid));
    if (!hasMatchingRelease) {
      return false;
    }
  }
  
  return true;
}

export const CustomerAdoptionQueryResolvers = {
  customer: async (_: any, { id }: any, ctx: any) => {
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        products: {
          include: {
            product: true,
            adoptionPlan: {
              include: {
                tasks: true,
              },
            },
          },
        },
        solutions: {
          include: {
            solution: true,
          },
        },
      },
    });
    return customer;
  },

  adoptionPlan: async (_: any, { id }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: {
              include: {
                outcome: true,
              },
            },
            releases: {
              include: {
                release: true,
              },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    return plan;
  },

  adoptionPlansForCustomer: async (_: any, { customerId }: any, ctx: any) => {
    const customerProducts = await prisma.customerProduct.findMany({
      where: { customerId },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
      },
    });
    
    return customerProducts
      .filter((cp: any) => cp.adoptionPlan)
      .map((cp: any) => cp.adoptionPlan);
  },

  customerTask: async (_: any, { id }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            customerProduct: {
              include: {
                customer: true,
                product: true,
              },
            },
          },
        },
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
            },
          },
          orderBy: { order: 'asc' },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
    });
    return task;
  },

  customerTasksForPlan: async (_: any, { adoptionPlanId, status }: any, ctx: any) => {
    const where: any = { adoptionPlanId };
    if (status) {
      where.status = status;
    }
    
    const tasks = await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: {
          include: {
            outcome: true,
          },
        },
        releases: {
          include: {
            release: true,
          },
        },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
    return tasks;
  },

  customerTelemetryDatabase: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    const where: any = {};
    
    if (customerProductId) {
      where.customerProductId = customerProductId;
    } else if (customerId) {
      where.customerId = customerId;
    }

    const customerProducts = await prisma.customerProduct.findMany({
      where,
      include: {
        customer: true,
        product: true,
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: {
                  where: { isActive: true },
                  include: {
                    values: {
                      orderBy: { createdAt: 'desc' },
                      take: 1,
                    },
                  },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });

    const records: any[] = [];

    for (const cp of customerProducts) {
      for (const plan of cp.adoptionPlans) {
        for (const task of plan.tasks) {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            records.push({
              customerId: cp.customer.id,
              customerName: cp.customer.name,
              customerProductId: cp.id,
              productId: cp.product.id,
              productName: cp.product.name,
              licenseLevel: cp.licenseLevel,
              adoptionPlanId: plan.id,
              taskId: task.id,
              taskName: task.name,
              taskSequenceNumber: task.sequenceNumber,
              attributeId: attr.id,
              attributeName: attr.name,
              attributeType: attr.attributeType,
              attributeRequired: attr.isRequired,
              attributeCriteria: attr.successCriteria,
              latestValue: latestValue?.value || null,
              latestValueDate: latestValue?.createdAt || null,
              criteriaMet,
              taskStatus: task.status,
            });
          }
        }
      }
    }

    return records;
  },
};

export const CustomerAdoptionMutationResolvers = {
  assignProductToCustomer: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerId, productId, name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;
    
    // Note: Removed unique constraint check - customers can now have the same product multiple times
    // Each assignment must be differentiated by a required name
    
    // Validate product exists
    const product = await prisma.product.findUnique({
      where: { id: productId },
    });
    
    if (!product) {
      throw new Error('Product not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds && selectedOutcomeIds.length > 0) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    // Validate release IDs if provided
    if (selectedReleaseIds && selectedReleaseIds.length > 0) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds}, productId },
      });
      
      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }
    
    // Convert GraphQL enum (PascalCase) to Prisma enum (UPPERCASE)
    const prismaLicenseLevel = licenseLevel.toUpperCase() as 'ESSENTIAL' | 'ADVANTAGE' | 'SIGNATURE';
    
    // Create customer product assignment
    const customerProduct = await prisma.customerProduct.create({
      data: {
        customerId,
        productId,
        name, // Required field
        licenseLevel: prismaLicenseLevel,
        selectedOutcomes: selectedOutcomeIds || [],
        selectedReleases: selectedReleaseIds || [],
      },
      include: {
        customer: true,
        product: true,
        adoptionPlan: true,
      },
    });
    
    await logAudit('ASSIGN_PRODUCT_TO_CUSTOMER', 'CustomerProduct', customerProduct.id, { input }, ctx.user?.id);
    
    return customerProduct;
  },

  updateCustomerProduct: async (_: any, { id, input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { name, licenseLevel, selectedOutcomeIds, selectedReleaseIds } = input;
    
    const before = await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        adoptionPlan: {
          include: {
            tasks: true,
          },
        },
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });
    
    if (!before) {
      throw new Error('Customer product assignment not found');
    }
    
    // Validate outcome IDs if provided
    if (selectedOutcomeIds) {
      const outcomes = await prisma.outcome.findMany({
        where: { id: { in: selectedOutcomeIds }, productId: before.productId },
      });
      
      if (outcomes.length !== selectedOutcomeIds.length) {
        throw new Error('Some outcome IDs are invalid or do not belong to this product');
      }
    }
    
    // Validate release IDs if provided
    if (selectedReleaseIds) {
      const releases = await prisma.release.findMany({
        where: { id: { in: selectedReleaseIds }, productId: before.productId },
      });
      
      if (releases.length !== selectedReleaseIds.length) {
        throw new Error('Some release IDs are invalid or do not belong to this product');
      }
    }
    
    const updateData: any = {};
    if (name !== undefined) updateData.name = name || null;
    if (licenseLevel) updateData.licenseLevel = licenseLevel.toUpperCase();
    if (selectedOutcomeIds !== undefined) updateData.selectedOutcomes = selectedOutcomeIds;
    if (selectedReleaseIds !== undefined) updateData.selectedReleases = selectedReleaseIds;
    
    // Update customer product first
    const updated = await prisma.customerProduct.update({
      where: { id },
      data: updateData,
      include: {
        customer: true,
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });
    
    // If adoption plan exists, update it intelligently to preserve status and telemetry
    // Instead of deleting and recreating, we'll add/remove tasks as needed (like sync does)
    if (before.adoptionPlan) {
      console.log(`Updating adoption plan for customer product ${id} due to entitlement changes`);
      
      const adoptionPlanId = before.adoptionPlan.id;
      
      // Get the new license level, outcomes, and releases from the updated product
      const newLicenseLevel = updated.licenseLevel;
      const newSelectedOutcomeIds = updated.selectedOutcomes as string[] || [];
      const newSelectedReleaseIds = updated.selectedReleases as string[] || [];
      
      // Filter tasks based on NEW license level, outcomes, and releases
      const eligibleProductTasks = updated.product.tasks.filter((task: any) =>
        shouldIncludeTask(task, newLicenseLevel, newSelectedOutcomeIds, newSelectedReleaseIds)
      );
      
      const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
      const currentCustomerTaskOriginalIds = before.adoptionPlan.tasks.map((t: any) => t.originalTaskId);
      
      // Find tasks to remove (no longer eligible)
      const tasksToRemove = before.adoptionPlan.tasks.filter(
        (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
      );
      
      // Find tasks to add (newly eligible)
      const tasksToAdd = eligibleProductTasks.filter(
        (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
      );
      
      // Remove tasks that are no longer eligible
      for (const task of tasksToRemove) {
        await prisma.customerTask.delete({ where: { id: task.id } });
      }
      
      // Add new eligible tasks
      for (const task of tasksToAdd) {
        const customerTask = await prisma.customerTask.create({
          data: {
            adoptionPlanId: adoptionPlanId,
            originalTaskId: task.id,
            name: task.name,
            description: task.description,
            estMinutes: task.estMinutes,
            weight: task.weight,
            sequenceNumber: task.sequenceNumber,
            howToDoc: task.howToDoc,
            howToVideo: task.howToVideo,
            notes: task.notes,
            licenseLevel: task.licenseLevel,
            status: 'NOT_STARTED',
            statusUpdateSource: 'SYSTEM',
          },
        });
        
        // Copy telemetry attributes
        for (const attr of task.telemetryAttributes) {
          await prisma.customerTelemetryAttribute.create({
            data: {
              customerTaskId: customerTask.id,
              originalAttributeId: attr.id,
              name: attr.name,
              description: attr.description,
              dataType: attr.dataType,
              isRequired: attr.isRequired,
              successCriteria: attr.successCriteria,
              order: attr.order,
              isActive: attr.isActive,
            },
          });
        }
        
        // Copy outcome relationships
        for (const taskOutcome of task.outcomes) {
          await prisma.customerTaskOutcome.create({
            data: {
              customerTaskId: customerTask.id,
              outcomeId: taskOutcome.outcomeId,
            },
          });
        }
        
        // Copy release relationships
        for (const taskRelease of task.releases) {
          await prisma.customerTaskRelease.create({
            data: {
              customerTaskId: customerTask.id,
              releaseId: taskRelease.releaseId,
            },
          });
        }
      }
      
      // Recalculate progress based on remaining tasks
      const updatedTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId },
      });
      
      const progress = calculateProgress(updatedTasks);
      
      // Update adoption plan metadata
      await prisma.adoptionPlan.update({
        where: { id: adoptionPlanId },
        data: {
          licenseLevel: newLicenseLevel,
          selectedOutcomes: newSelectedOutcomeIds,
          selectedReleases: newSelectedReleaseIds,
          ...progress,
          lastSyncedAt: new Date(),
        },
      });
      
      console.log(`Updated adoption plan: removed ${tasksToRemove.length} tasks, added ${tasksToAdd.length} tasks`);
    }
    
    await logAudit('UPDATE_CUSTOMER_PRODUCT', 'CustomerProduct', id, { before: { licenseLevel: before.licenseLevel, selectedOutcomes: before.selectedOutcomes }, after: { licenseLevel: updated.licenseLevel, selectedOutcomes: updated.selectedOutcomes } }, ctx.user?.id);
    
    // Return with fresh adoption plan data
    return await prisma.customerProduct.findUnique({
      where: { id },
      include: {
        customer: true,
        product: true,
        adoptionPlan: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
                outcomes: {
                  include: { outcome: true },
                },
                releases: {
                  include: { release: true },
                },
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
      },
    });
  },

  removeProductFromCustomerEnhanced: async (_: any, { id }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id },
      include: { adoptionPlan: { include: { tasks: true } } },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    // Delete will cascade to adoption plan and tasks
    await prisma.customerProduct.delete({
      where: { id },
    });
    
    await logAudit('REMOVE_PRODUCT_FROM_CUSTOMER', 'CustomerProduct', id, {}, ctx.user?.id);
    
    return { success: true, message: 'Product removed from customer successfully' };
  },

  createAdoptionPlan: async (_: any, { customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        product: {
          include: {
            tasks: {
              where: { deletedAt: null },
              include: {
                telemetryAttributes: true,
                outcomes: true,
                releases: true,
              },
              orderBy: { sequenceNumber: 'asc' },
            },
          },
        },
        adoptionPlan: true,
      },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product assignment not found');
    }
    
    if (customerProduct.adoptionPlan) {
      throw new Error('Adoption plan already exists for this customer product');
    }
    
    const selectedOutcomeIds = customerProduct.selectedOutcomes as string[] || [];
    const selectedReleaseIds = customerProduct.selectedReleases as string[] || [];
    
    // Filter tasks based on license level, outcomes, and releases
    const eligibleTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds, selectedReleaseIds)
    );
    
    // Calculate initial progress
    const progress = calculateProgress(eligibleTasks.map((t: any) => ({ ...t, status: 'NOT_STARTED' })));
    
    // Create adoption plan
    const adoptionPlan = await prisma.adoptionPlan.create({
      data: {
        customerProductId,
        productId: customerProduct.productId,
        productName: customerProduct.product.name,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        selectedReleases: selectedReleaseIds,
        totalTasks: progress.totalTasks,
        completedTasks: 0,
        totalWeight: progress.totalWeight,
        completedWeight: 0,
        progressPercentage: 0,
        lastSyncedAt: new Date(),
      },
    });
    
    // Create customer tasks (snapshots of product tasks)
    for (const task of eligibleTasks) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: adoptionPlan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
          statusUpdateSource: 'SYSTEM',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy outcome relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: {
            customerTaskId: customerTask.id,
            outcomeId: taskOutcome.outcomeId,
          },
        });
      }
      
      // Copy release relationships
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: {
            customerTaskId: customerTask.id,
            releaseId: taskRelease.releaseId,
          },
        });
      }
    }
    
    await logAudit('CREATE_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlan.id, { customerProductId }, ctx.user?.id);
    
    // Fetch complete plan with relations
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlan.id },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: {
              include: { outcome: true },
            },
            releases: {
              include: { release: true },
            },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  syncAdoptionPlan: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            product: {
              include: {
                tasks: {
                  where: { deletedAt: null },
                  include: {
                    telemetryAttributes: true,
                    outcomes: true,
                    releases: true,
                  },
                },
                outcomes: true,  // Fetch all product outcomes
                releases: true,  // Fetch all product releases
              },
            },
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: true,
            releases: true,
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    const { customerProduct } = plan;
    
    // Track original selections for audit
    const originalOutcomeIds = (customerProduct.selectedOutcomes as string[]) || [];
    const originalReleaseIds = (customerProduct.selectedReleases as string[]) || [];
    
    // STEP 1: Update customer's selected outcomes and releases with all available from product
    // This ensures new outcomes/releases added to product are automatically included
    const allProductOutcomeIds = customerProduct.product.outcomes.map((o: any) => o.id);
    const allProductReleaseIds = customerProduct.product.releases.map((r: any) => r.id);
    
    // Calculate what's new
    const newOutcomes = allProductOutcomeIds.filter((id: string) => !originalOutcomeIds.includes(id));
    const newReleases = allProductReleaseIds.filter((id: string) => !originalReleaseIds.includes(id));
    
    // Update customer product selections to include all product outcomes and releases
    await prisma.customerProduct.update({
      where: { id: customerProduct.id },
      data: {
        selectedOutcomes: allProductOutcomeIds,
        selectedReleases: allProductReleaseIds,
      },
    });
    
    // Use updated selections for task filtering
    const selectedOutcomeIds = allProductOutcomeIds;
    const selectedReleaseIds = allProductReleaseIds;
    
    // STEP 2: Get current eligible tasks from product
    const eligibleProductTasks = customerProduct.product.tasks.filter((task: any) =>
      shouldIncludeTask(task, customerProduct.licenseLevel, selectedOutcomeIds, selectedReleaseIds)
    );
    
    const eligibleProductTaskIds = eligibleProductTasks.map((t: any) => t.id);
    const currentCustomerTaskOriginalIds = plan.tasks.map((t: any) => t.originalTaskId);
    
    // Find tasks to remove (no longer eligible)
    const tasksToRemove = plan.tasks.filter(
      (ct: any) => !eligibleProductTaskIds.includes(ct.originalTaskId)
    );
    
    // Find tasks to add (newly eligible)
    const tasksToAdd = eligibleProductTasks.filter(
      (pt: any) => !currentCustomerTaskOriginalIds.includes(pt.id)
    );
    
    // Find tasks to update (existing tasks that may have changed in product)
    const tasksToUpdate = plan.tasks.filter(
      (ct: any) => eligibleProductTaskIds.includes(ct.originalTaskId)
    );
    
    // Remove obsolete tasks
    for (const task of tasksToRemove) {
      await prisma.customerTask.delete({ where: { id: task.id } });
    }
    
    // Update existing tasks with product changes
    let tasksUpdated = 0;
    for (const customerTask of tasksToUpdate) {
      const productTask = eligibleProductTasks.find((pt: any) => pt.id === customerTask.originalTaskId);
      if (!productTask) continue;
      
      // Check if task attributes have changed
      const hasChanges = 
        customerTask.name !== productTask.name ||
        customerTask.description !== productTask.description ||
        customerTask.estMinutes !== productTask.estMinutes ||
        customerTask.weight !== productTask.weight ||
        customerTask.sequenceNumber !== productTask.sequenceNumber ||
        customerTask.howToDoc !== productTask.howToDoc ||
        customerTask.howToVideo !== productTask.howToVideo ||
        customerTask.notes !== productTask.notes ||
        customerTask.licenseLevel !== productTask.licenseLevel;
      
      if (hasChanges) {
        // Update customer task with product task data
        // IMPORTANT: This update preserves all status-related fields:
        // - status, isComplete, completedAt, completedBy
        // - statusUpdatedAt, statusUpdatedBy, statusUpdateSource, statusNotes
        // These are NOT included in the data object, so they remain unchanged
        await prisma.customerTask.update({
          where: { id: customerTask.id },
          data: {
            name: productTask.name,
            description: productTask.description,
            estMinutes: productTask.estMinutes,
            weight: productTask.weight,
            sequenceNumber: productTask.sequenceNumber,
            howToDoc: productTask.howToDoc,
            howToVideo: productTask.howToVideo,
            notes: productTask.notes,
            licenseLevel: productTask.licenseLevel,
          },
        });
        tasksUpdated++;
      }
      
      // Update telemetry attributes
      // Note: This preserves existing telemetry values and evaluation state (isMet, lastCheckedAt)
      // Delete removed attributes (and their values will cascade delete)
      const productAttrIds = productTask.telemetryAttributes.map((a: any) => a.id);
      await prisma.customerTelemetryAttribute.deleteMany({
        where: {
          customerTaskId: customerTask.id,
          originalAttributeId: { notIn: productAttrIds },
        },
      });
      
      // Add or update attributes
      for (const productAttr of productTask.telemetryAttributes) {
        const existingAttr = await prisma.customerTelemetryAttribute.findFirst({
          where: {
            customerTaskId: customerTask.id,
            originalAttributeId: productAttr.id,
          },
        });
        
        if (existingAttr) {
          // Update existing attribute with product changes
          // IMPORTANT: This preserves telemetry evaluation state:
          // - isMet (whether criteria are met)
          // - lastCheckedAt (when last evaluated)
          // - values (all historical telemetry values via foreign key)
          // Only configuration fields are updated to match product
          await prisma.customerTelemetryAttribute.update({
            where: { id: existingAttr.id },
            data: {
              name: productAttr.name,
              description: productAttr.description,
              dataType: productAttr.dataType,
              isRequired: productAttr.isRequired,
              successCriteria: productAttr.successCriteria,
              order: productAttr.order,
              isActive: productAttr.isActive,
            },
          });
        } else {
          // Add new attribute
          await prisma.customerTelemetryAttribute.create({
            data: {
              customerTaskId: customerTask.id,
              originalAttributeId: productAttr.id,
              name: productAttr.name,
              description: productAttr.description,
              dataType: productAttr.dataType,
              isRequired: productAttr.isRequired,
              successCriteria: productAttr.successCriteria,
              order: productAttr.order,
              isActive: productAttr.isActive,
            },
          });
        }
      }
      
      // Update outcomes - delete and recreate
      await prisma.customerTaskOutcome.deleteMany({
        where: { customerTaskId: customerTask.id },
      });
      for (const taskOutcome of productTask.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: { customerTaskId: customerTask.id, outcomeId: taskOutcome.outcomeId },
        });
      }
      
      // Update releases - delete and recreate
      await prisma.customerTaskRelease.deleteMany({
        where: { customerTaskId: customerTask.id },
      });
      for (const taskRelease of productTask.releases) {
        await prisma.customerTaskRelease.create({
          data: { customerTaskId: customerTask.id, releaseId: taskRelease.releaseId },
        });
      }
    }
    
    // Add new tasks
    for (const task of tasksToAdd) {
      const customerTask = await prisma.customerTask.create({
        data: {
          adoptionPlanId: plan.id,
          originalTaskId: task.id,
          name: task.name,
          description: task.description,
          estMinutes: task.estMinutes,
          weight: task.weight,
          sequenceNumber: task.sequenceNumber,
          howToDoc: task.howToDoc,
          howToVideo: task.howToVideo,
          notes: task.notes,
          licenseLevel: task.licenseLevel,
          status: 'NOT_STARTED',
          statusUpdateSource: 'SYSTEM',
        },
      });
      
      // Copy telemetry attributes
      for (const attr of task.telemetryAttributes) {
        await prisma.customerTelemetryAttribute.create({
          data: {
            customerTaskId: customerTask.id,
            originalAttributeId: attr.id,
            name: attr.name,
            description: attr.description,
            dataType: attr.dataType,
            isRequired: attr.isRequired,
            successCriteria: attr.successCriteria,
            order: attr.order,
            isActive: attr.isActive,
          },
        });
      }
      
      // Copy relationships
      for (const taskOutcome of task.outcomes) {
        await prisma.customerTaskOutcome.create({
          data: { customerTaskId: customerTask.id, outcomeId: taskOutcome.outcomeId },
        });
      }
      
      for (const taskRelease of task.releases) {
        await prisma.customerTaskRelease.create({
          data: { customerTaskId: customerTask.id, releaseId: taskRelease.releaseId },
        });
      }
    }
    
    // Recalculate progress
    const updatedTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(updatedTasks);
    
    // Update adoption plan
    const updatedPlan = await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: {
        ...progress,
        licenseLevel: customerProduct.licenseLevel,
        selectedOutcomes: selectedOutcomeIds,
        lastSyncedAt: new Date(),
      },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: true,
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
    
    await logAudit('SYNC_ADOPTION_PLAN', 'AdoptionPlan', adoptionPlanId, { 
      tasksRemoved: tasksToRemove.length, 
      tasksAdded: tasksToAdd.length,
      tasksUpdated,
      outcomesAdded: newOutcomes.length,
      releasesAdded: newReleases.length
    }, ctx.user?.id);
    
    return updatedPlan;
  },

  updateCustomerTaskStatus: async (_: any, { input }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    const { customerTaskId, status, notes, updateSource } = input;
    
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: { adoptionPlan: true },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    // Append new notes to existing notes with timestamp and status change
    let updatedNotes = task.statusNotes || '';
    if (notes && notes.trim()) {
      const timestamp = new Date().toISOString();
      const user = ctx.user?.id || 'unknown';
      const source = updateSource || 'MANUAL';
      const statusChange = `[${timestamp}] Status changed to ${status} by ${user} (via ${source}):\n${notes.trim()}\n\n`;
      updatedNotes = updatedNotes ? `${updatedNotes}${statusChange}` : statusChange;
    }
    
    const updateData: any = {
      status,
      statusUpdatedAt: new Date(),
      statusUpdatedBy: ctx.user?.id || 'unknown',
      statusUpdateSource: updateSource || 'MANUAL',
      statusNotes: updatedNotes,
      isComplete: status === 'DONE',
      completedAt: status === 'DONE' ? new Date() : null,
      completedBy: status === 'DONE' ? (ctx.user?.id || 'unknown') : null,
    };
    
    const updated = await prisma.customerTask.update({
      where: { id: customerTaskId },
      data: updateData,
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: task.adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: task.adoptionPlanId },
      data: progress,
    });
    
    await logAudit('UPDATE_CUSTOMER_TASK_STATUS', 'CustomerTask', customerTaskId, { status, notes }, ctx.user?.id);
    
    return updated;
  },

  bulkUpdateCustomerTaskStatus: async (_: any, { adoptionPlanId, taskIds, status, notes }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    // Fetch existing tasks to preserve their notes
    const existingTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
        adoptionPlanId,
      },
    });
    
    // Update each task individually to append notes
    const timestamp = new Date().toISOString();
    const user = ctx.user?.id || 'unknown';
    const statusChange = notes && notes.trim() 
      ? `[${timestamp}] Status changed to ${status} by ${user}:\n${notes.trim()}\n\n`
      : '';
    
    const updatePromises = existingTasks.map((task: any) => {
      const updatedNotes = statusChange 
        ? (task.statusNotes || '') + statusChange
        : task.statusNotes;
      
      return prisma.customerTask.update({
        where: { id: task.id },
        data: {
          status,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: user,
          statusUpdateSource: 'MANUAL',
          statusNotes: updatedNotes,
          isComplete: status === 'DONE',
          completedAt: status === 'DONE' ? new Date() : null,
          completedBy: status === 'DONE' ? user : null,
        },
      });
    });
    
    await Promise.all(updatePromises);
    
    // Fetch updated tasks
    const updatedTasks = await prisma.customerTask.findMany({
      where: {
        id: { in: taskIds },
      },
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
    });
    
    // Recalculate adoption plan progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: adoptionPlanId },
      data: progress,
    });
    
    await logAudit('BULK_UPDATE_CUSTOMER_TASK_STATUS', 'AdoptionPlan', adoptionPlanId, { taskIds, status, notes }, ctx.user?.id);
    
    return updatedTasks;
  },

  addCustomerTelemetryValue: async (_: any, { input }: any, ctx: any) => {
    const { customerAttributeId, value, source, batchId, notes } = input;
    
    const attribute = await prisma.customerTelemetryAttribute.findUnique({
      where: { id: customerAttributeId },
      include: { customerTask: { include: { adoptionPlan: true } } },
    });
    
    if (!attribute) {
      throw new Error('Customer telemetry attribute not found');
    }
    
    const telemetryValue = await prisma.customerTelemetryValue.create({
      data: {
        customerAttributeId,
        value,
        source: source || 'manual',
        batchId,
        notes,
      },
      include: {
        customerAttribute: true,
      },
    });
    
    await logAudit('ADD_CUSTOMER_TELEMETRY_VALUE', 'CustomerTelemetryValue', telemetryValue.id, { input }, ctx.user?.id);
    
    return telemetryValue;
  },

  bulkAddCustomerTelemetryValues: async (_: any, { inputs }: any, ctx: any) => {
    const createdValues = [];
    
    for (const input of inputs) {
      const { customerAttributeId, value, source, batchId, notes } = input;
      
      const telemetryValue = await prisma.customerTelemetryValue.create({
        data: {
          customerAttributeId,
          value,
          source: source || 'api',
          batchId,
          notes,
        },
        include: {
          customerAttribute: true,
        },
      });
      
      createdValues.push(telemetryValue);
    }
    
    await logAudit('BULK_ADD_CUSTOMER_TELEMETRY_VALUES', 'CustomerTelemetryValue', 'bulk', { count: inputs.length }, ctx.user?.id);
    
    return createdValues;
  },

  evaluateTaskTelemetry: async (_: any, { customerTaskId }: any, ctx: any) => {
    const task = await prisma.customerTask.findUnique({
      where: { id: customerTaskId },
      include: {
        adoptionPlan: true,
        telemetryAttributes: {
          include: {
            values: {
              orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],
              take: 1,
            },
          },
        },
      },
    });
    
    if (!task) {
      throw new Error('Customer task not found');
    }
    
    const attributes = task.telemetryAttributes;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive);
    
    // Manual status takes precedence over telemetry (except for NOT_STARTED)
    // If user manually set status to IN_PROGRESS, DONE, or NOT_APPLICABLE, respect that
    const hasManualStatus = task.statusUpdatedBy && 
                           task.statusUpdatedBy !== 'telemetry' && 
                           task.status !== 'NOT_STARTED';
    
    // Evaluate each attribute (always evaluate to update isMet status for display)
    let metCount = 0;
    let metRequiredCount = 0;
    
    for (const attr of attributes) {
      if (!attr.isActive) continue;
      
      const latestValue = attr.values[0];
      if (!latestValue) continue;
      
      // Use the proper evaluation engine that handles the criteria structure from SimpleCriteriaBuilder
      let isMet = false;
      if (attr.successCriteria) {
        try {
          const evaluationResult = await evaluateTelemetryAttribute(attr);
          isMet = evaluationResult.success;
        } catch (evalError) {
          console.error(`Failed to evaluate criteria for ${attr.name}:`, evalError);
          isMet = false;
        }
      }
      
      // Update attribute isMet status
      await prisma.customerTelemetryAttribute.update({
        where: { id: attr.id },
        data: {
          isMet,
          lastCheckedAt: new Date(),
        },
      });
      
      if (isMet) {
        metCount++;
        if (attr.isRequired) metRequiredCount++;
      }
    }
    
    // Determine new status based on telemetry
    let newStatus: CustomerTaskStatus = task.status;
    
    if (requiredAttributes.length > 0) {
      if (metRequiredCount === requiredAttributes.length) {
        newStatus = 'DONE';
      } else if (metCount > 0) {
        newStatus = 'IN_PROGRESS';
      } else if (metCount === 0 && (task.status === 'DONE' || task.status === 'COMPLETED' || task.status === 'NO_LONGER_USING')) {
        // Feature was done but telemetry shows it's no longer being used
        // This is a critical status change that overrides manual status
        // Keep NO_LONGER_USING if already set, or set it if coming from DONE/COMPLETED
        newStatus = 'NO_LONGER_USING';
      } else {
        newStatus = 'NOT_STARTED';
      }
    }
    
    // Special case: NO_LONGER_USING overrides manual status because it indicates regression
    const shouldOverrideManual = newStatus === 'NO_LONGER_USING' && (task.status === 'DONE' || task.status === 'COMPLETED' || task.status === 'NO_LONGER_USING');
    
    // Only update task status if:
    // 1. Status has changed, AND
    // 2. Either no manual status was set, OR current status is NOT_STARTED, OR it's NO_LONGER_USING override
    if (newStatus !== task.status && (!hasManualStatus || shouldOverrideManual)) {
      const updated = await prisma.customerTask.update({
        where: { id: customerTaskId },
        data: {
          status: newStatus,
          statusUpdatedAt: new Date(),
          statusUpdatedBy: 'telemetry',
          statusUpdateSource: 'TELEMETRY',
          statusNotes: 'Automatically updated based on telemetry criteria',
          isComplete: newStatus === 'DONE',
          completedAt: newStatus === 'DONE' ? new Date() : null,
          completedBy: newStatus === 'DONE' ? 'telemetry' : null,
        },
        include: {
          adoptionPlan: true,
          telemetryAttributes: {
            include: {
              values: {
                orderBy: { createdAt: 'desc' },
                take: 1,
              },
            },
          },
          outcomes: { include: { outcome: true } },
          releases: { include: { release: true } },
        },
      });
      
      // Recalculate adoption plan progress
      const allTasks = await prisma.customerTask.findMany({
        where: { adoptionPlanId: task.adoptionPlanId },
      });
      
      const progress = calculateProgress(allTasks);
      
      await prisma.adoptionPlan.update({
        where: { id: task.adoptionPlanId },
        data: progress,
      });
      
      await logAudit('EVALUATE_TASK_TELEMETRY', 'CustomerTask', customerTaskId, { oldStatus: task.status, newStatus }, ctx.user?.id);
      
      return updated;
    }
    
    // Status not updated - either no change or manual status takes precedence
    return task;
  },

  evaluateAllTasksTelemetry: async (_: any, { adoptionPlanId }: any, ctx: any) => {
    const plan = await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
          },
        },
      },
    });
    
    if (!plan) {
      throw new Error('Adoption plan not found');
    }
    
    // Evaluate each task
    // Note: evaluateTaskTelemetry handles manual vs telemetry status precedence internally
    for (const task of plan.tasks) {
      await CustomerAdoptionMutationResolvers.evaluateTaskTelemetry(
        _,
        { customerTaskId: task.id },
        ctx
      );
    }
    
    // Return updated plan
    return await prisma.adoptionPlan.findUnique({
      where: { id: adoptionPlanId },
      include: {
        customerProduct: {
          include: {
            customer: true,
            product: true,
          },
        },
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
            releases: { include: { release: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });
  },

  exportCustomerAdoptionToExcel: async (_: any, { customerId, customerProductId }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');
    
    const customerProduct = await prisma.customerProduct.findUnique({
      where: { id: customerProductId },
      include: {
        customer: true,
        product: true,
      },
    });
    
    if (!customerProduct) {
      throw new Error('Customer product not found');
    }
    
    const adoptionPlan = await prisma.adoptionPlan.findUnique({
      where: { customerProductId },
      include: {
        tasks: {
          include: {
            telemetryAttributes: {
              include: {
                values: {
                  orderBy: { createdAt: 'desc' },
                  take: 1,
                },
              },
            },
            outcomes: { include: { outcome: true } },
          },
          orderBy: { sequenceNumber: 'asc' },
        },
      },
    });

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Customer Adoption Data');

    // Headers
    worksheet.columns = [
      { header: 'Customer ID', key: 'customerId', width: 20 },
      { header: 'Customer Name', key: 'customerName', width: 30 },
      { header: 'Product ID', key: 'productId', width: 20 },
      { header: 'Product Name', key: 'productName', width: 30 },
      { header: 'License Level', key: 'licenseLevel', width: 15 },
      { header: 'Task Sequence', key: 'taskSequence', width: 12 },
      { header: 'Task Name', key: 'taskName', width: 40 },
      { header: 'Task Status', key: 'taskStatus', width: 15 },
      { header: 'Telemetry Attribute', key: 'telemetryAttribute', width: 30 },
      { header: 'Attribute Type', key: 'attributeType', width: 15 },
      { header: 'Required', key: 'required', width: 10 },
      { header: 'Current Value', key: 'currentValue', width: 30 },
      { header: 'Last Updated', key: 'lastUpdated', width: 20 },
      { header: 'Criteria Met', key: 'criteriaMet', width: 12 },
    ];

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    };

    if (adoptionPlan.tasks && adoptionPlan.tasks.length > 0) {
      for (const task of adoptionPlan.tasks) {
        if (task.telemetryAttributes.length === 0) {
          // Task with no telemetry
          worksheet.addRow({
            customerId: customerProduct.customer.id,
            customerName: customerProduct.customer.name,
            productId: customerProduct.product.id,
            productName: customerProduct.product.name,
            licenseLevel: customerProduct.licenseLevel,
            taskSequence: task.sequenceNumber,
            taskName: task.name,
            taskStatus: task.status,
            telemetryAttribute: '',
            attributeType: '',
            required: '',
            currentValue: '',
            lastUpdated: '',
            criteriaMet: '',
          });
        } else {
          for (const attr of task.telemetryAttributes) {
            const latestValue = attr.values[0];
            const criteriaMet = latestValue && attr.successCriteria
              ? evaluateCriteria(attr.successCriteria, latestValue.value)
              : null;

            worksheet.addRow({
              customerId: customerProduct.customer.id,
              customerName: customerProduct.customer.name,
              productId: customerProduct.product.id,
              productName: customerProduct.product.name,
              licenseLevel: customerProduct.licenseLevel,
              taskSequence: task.sequenceNumber,
              taskName: task.name,
              taskStatus: task.status,
              telemetryAttribute: attr.name,
              attributeType: attr.attributeType,
              required: attr.isRequired ? 'Yes' : 'No',
              currentValue: latestValue ? JSON.stringify(latestValue.value) : '',
              lastUpdated: latestValue ? latestValue.createdAt.toISOString() : '',
              criteriaMet: criteriaMet === null ? '' : criteriaMet ? 'Yes' : 'No',
            });
          }
        }
      }
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const content = Buffer.from(buffer).toString('base64');
    const filename = `${customerProduct.customer.name}_${customerProduct.product.name}_adoption.xlsx`;

    await logAudit('EXPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { filename }, ctx.user?.id);

    return {
      filename,
      content,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      size: buffer.byteLength,
      stats: {
        tasksExported: adoptionPlan?.tasks.length || 0,
        customAttributesExported: 0,
        licensesExported: 0,
        outcomesExported: 0,
        releasesExported: 0,
        telemetryAttributesExported: adoptionPlan?.tasks.reduce((sum: any, t: any) => sum + t.telemetryAttributes.length, 0) || 0,
      },
    };
  },

  importCustomerAdoptionFromExcel: async (_: any, { content }: any, ctx: any) => {
    ensureRole(ctx, 'ADMIN');

    const ExcelJS = await import('exceljs');
    const workbook = new ExcelJS.Workbook();
    const buffer = Buffer.from(content, 'base64');
    await workbook.xlsx.load(buffer.buffer as ArrayBuffer);

    const worksheet = workbook.getWorksheet('Customer Adoption Data');
    if (!worksheet) {
      throw new Error('Worksheet "Customer Adoption Data" not found');
    }

    const errors: any[] = [];
    const warnings: any[] = [];
    let telemetryValuesImported = 0;
    let taskStatusesUpdated = 0;
    let attributesCreated = 0;

    let customerId = '';
    let customerName = '';
    let customerProductId = '';
    let productName = '';

    const rows: any[] = [];
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header
      rows.push({
        rowNumber,
        customerId: row.getCell(1).value,
        customerName: row.getCell(2).value,
        productId: row.getCell(3).value,
        productName: row.getCell(4).value,
        licenseLevel: row.getCell(5).value,
        taskSequence: row.getCell(6).value,
        taskName: row.getCell(7).value,
        taskStatus: row.getCell(8).value,
        telemetryAttribute: row.getCell(9).value,
        attributeType: row.getCell(10).value,
        required: row.getCell(11).value,
        currentValue: row.getCell(12).value,
        lastUpdated: row.getCell(13).value,
        criteriaMet: row.getCell(14).value,
      });
    });

    if (rows.length === 0) {
      throw new Error('No data rows found in worksheet');
    }

    // Get customer and product from first row
    const firstRow = rows[0];
    customerId = firstRow.customerId;
    customerName = firstRow.customerName;
    productName = firstRow.productName;

    // Find customer product
    const customerProduct = await prisma.customerProduct.findFirst({
      where: {
        customerId: customerId,
        productId: firstRow.productId,
      },
      include: {
        adoptionPlans: {
          include: {
            tasks: {
              include: {
                telemetryAttributes: true,
              },
            },
          },
        },
      },
    });

    if (!customerProduct) {
      throw new Error(`Customer product assignment not found for customer ${customerName} and product ${productName}`);
    }

    customerProductId = customerProduct.id;
    const adoptionPlan = customerProduct.adoptionPlans[0];

    if (!adoptionPlan) {
      throw new Error('No adoption plan found for this customer product');
    }

    // Process each row
    for (const row of rows) {
      try {
        // Find task by sequence number
        const task = adoptionPlan.tasks.find((t: any) => t.sequenceNumber === Number(row.taskSequence));
        
        if (!task) {
          warnings.push({
            row: row.rowNumber,
            field: 'taskSequence',
            message: `Task with sequence ${row.taskSequence} not found`,
          });
          continue;
        }

        // Update task status if changed
        if (row.taskStatus && row.taskStatus !== task.status) {
          await prisma.customerTask.update({
            where: { id: task.id },
            data: {
              status: row.taskStatus as any,
              statusUpdatedBy: 'import',
              statusUpdateSource: 'IMPORT',
              statusUpdatedAt: new Date(),
            },
          });
          taskStatusesUpdated++;
        }

        // Process telemetry if present
        if (row.telemetryAttribute && row.currentValue) {
          // Find or create telemetry attribute
          let attribute = task.telemetryAttributes.find((a: any) => a.name === row.telemetryAttribute);
          
          if (!attribute) {
            attribute = await prisma.customerTelemetryAttribute.create({
              data: {
                customerTaskId: task.id,
                name: row.telemetryAttribute,
                attributeType: row.attributeType || 'TEXT',
                isRequired: row.required === 'Yes',
                isActive: true,
              },
            });
            attributesCreated++;
          }

          // Parse value
          let parsedValue: any;
          try {
            parsedValue = JSON.parse(row.currentValue);
          } catch {
            parsedValue = row.currentValue;
          }

          // Create telemetry value
          await prisma.customerTelemetryValue.create({
            data: {
              customerAttributeId: attribute.id,
              value: parsedValue,
              batchId: `import_${Date.now()}`,
            },
          });
          telemetryValuesImported++;
        }
      } catch (error: any) {
        errors.push({
          row: row.rowNumber,
          field: 'general',
          message: error.message,
        });
      }
    }

    // Recalculate progress
    const allTasks = await prisma.customerTask.findMany({
      where: { adoptionPlanId: adoptionPlan.id },
    });
    
    const progress = calculateProgress(allTasks);
    
    await prisma.adoptionPlan.update({
      where: { id: adoptionPlan.id },
      data: progress,
    });

    await logAudit('IMPORT_CUSTOMER_ADOPTION', 'CustomerProduct', customerProductId, { telemetryValuesImported, taskStatusesUpdated }, ctx.user?.id);

    return {
      success: errors.length === 0,
      customerId,
      customerName,
      customerProductId,
      productName,
      stats: {
        telemetryValuesImported,
        taskStatusesUpdated,
        attributesCreated,
      },
      errors,
      warnings,
    };
  },

  // Export telemetry template
  exportAdoptionPlanTelemetryTemplate: async (_: any, { adoptionPlanId }: { adoptionPlanId: string }, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    // Get metadata first
    const metadata = await CustomerTelemetryExportService.getTemplateMetadata(adoptionPlanId);
    
    // Generate the Excel template
    const buffer = await CustomerTelemetryExportService.generateTelemetryTemplate(adoptionPlanId);
    
    // Create temp directory if it doesn't exist
    const tempDir = path.join(process.cwd(), 'temp', 'telemetry-exports');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    // Generate unique filename
    const filename = `telemetry_template_${metadata.customerName}_${metadata.productName}_${Date.now()}.xlsx`;
    const filePath = path.join(tempDir, filename);
    
    // Write buffer to file
    fs.writeFileSync(filePath, buffer);
    
    // Generate download URL with properly encoded filename
    const encodedFilename = encodeURIComponent(filename);
    const url = `/api/downloads/telemetry-exports/${encodedFilename}`;
    
    await logAudit('EXPORT_TELEMETRY_TEMPLATE', 'AdoptionPlan', adoptionPlanId, metadata, ctx.user?.id);
    
    return {
      url,
      filename,
      taskCount: metadata.taskCount,
      attributeCount: metadata.attributeCount,
      customerName: metadata.customerName,
      productName: metadata.productName,
      assignmentName: metadata.assignmentName,
    };
  },

  // Import telemetry data
  importAdoptionPlanTelemetry: async (_: any, { adoptionPlanId, file }: { adoptionPlanId: string; file: any }, ctx: any) => {
    ensureRole(ctx, 'ADMIN');
    
    // Handle file upload - file is an Upload scalar
    const { createReadStream } = await file;
    const stream = createReadStream();
    
    // Read stream into buffer
    const chunks: Buffer[] = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    const fileBuffer = Buffer.concat(chunks);
    
    // Import the telemetry values
    const result = await CustomerTelemetryImportService.importTelemetryValues(adoptionPlanId, fileBuffer);
    
    // Evaluate all task statuses immediately after import
    await CustomerAdoptionMutationResolvers.evaluateAllTasksTelemetry(_, { adoptionPlanId }, ctx);
    
    await logAudit('IMPORT_TELEMETRY_DATA', 'AdoptionPlan', adoptionPlanId, result.summary, ctx.user?.id);
    
    return result;
  },
};

// Field resolvers
export const CustomerProductWithPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) return [];
    
    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },
  adoptionPlan: async (parent: any) => {
    // Find the adoption plan for this customer product
    return await prisma.adoptionPlan.findUnique({
      where: { customerProductId: parent.id },
    });
  },
};

export const AdoptionPlanResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  selectedOutcomes: async (parent: any) => {
    const outcomeIds = parent.selectedOutcomes as string[] || [];
    if (outcomeIds.length === 0) return [];
    
    return await prisma.outcome.findMany({
      where: { id: { in: outcomeIds } },
    });
  },
  selectedReleases: async (parent: any) => {
    const releaseIds = parent.selectedReleases as string[] || [];
    if (releaseIds.length === 0) return [];
    
    return await prisma.release.findMany({
      where: { id: { in: releaseIds } },
    });
  },
  
  tasks: async (parent: any) => {
    // Return all tasks for this adoption plan
    return await prisma.customerTask.findMany({
      where: { adoptionPlanId: parent.id },
      orderBy: { sequenceNumber: 'asc' },
    });
  },
  
  tasksByStatus: async (parent: any, { status }: any) => {
    const where: any = { adoptionPlanId: parent.id };
    if (status) where.status = status;
    
    return await prisma.customerTask.findMany({
      where,
      include: {
        telemetryAttributes: {
          include: {
            values: {
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
        outcomes: { include: { outcome: true } },
        releases: { include: { release: true } },
      },
      orderBy: { sequenceNumber: 'asc' },
    });
  },
  
  needsSync: async (parent: any) => {
    if (!parent.lastSyncedAt) return true;
    
    // Check if product has been updated since last sync
    const product = await prisma.product.findUnique({
      where: { id: parent.productId },
    });
    
    if (!product) return false;
    
    return product.updatedAt > parent.lastSyncedAt;
  },
};

export const CustomerTaskResolvers = {
  licenseLevel: (parent: any) => {
    // Convert Prisma enum (UPPERCASE) to GraphQL enum (PascalCase)
    const level = parent.licenseLevel;
    if (!level) return null;
    return level.charAt(0) + level.slice(1).toLowerCase();
  },
  telemetryAttributes: async (parent: any) => {
    // Return all telemetry attributes for this customer task
    return await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
      orderBy: { order: 'asc' },
    });
  },
  outcomes: async (parent: any) => {
    const taskOutcomes = await prisma.customerTaskOutcome.findMany({
      where: { customerTaskId: parent.id },
      include: { outcome: true },
    });
    
    return taskOutcomes.map((to: any) => to.outcome);
  },
  
  releases: async (parent: any) => {
    const taskReleases = await prisma.customerTaskRelease.findMany({
      where: { customerTaskId: parent.id },
      include: { release: true },
    });
    
    return taskReleases.map((tr: any) => tr.release);
  },
  
  telemetryProgress: async (parent: any) => {
    const attributes = await prisma.customerTelemetryAttribute.findMany({
      where: { customerTaskId: parent.id },
    });
    
    const totalAttributes = attributes.filter((a: any) => a.isActive).length;
    const requiredAttributes = attributes.filter((a: any) => a.isRequired && a.isActive).length;
    const metAttributes = attributes.filter((a: any) => a.isMet && a.isActive).length;
    const metRequiredAttributes = attributes.filter((a: any) => a.isMet && a.isRequired && a.isActive).length;
    
    const completionPercentage = totalAttributes > 0 ? (metAttributes / totalAttributes) * 100 : 0;
    const allRequiredMet = requiredAttributes > 0 && metRequiredAttributes === requiredAttributes;
    
    return {
      totalAttributes,
      requiredAttributes,
      metAttributes,
      metRequiredAttributes,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
      allRequiredMet,
    };
  },
};

export const CustomerTelemetryAttributeResolvers = {
  values: async (parent: any, args: any) => {
    const limit = args.limit;
    const values = await prisma.customerTelemetryValue.findMany({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
      ...(limit && { take: limit }),
      include: {
        customerAttribute: true, // Include for criteriaMet resolver
      },
    });
    
    return values || []; // Always return array, never null
  },
  latestValue: async (parent: any) => {
    const value = await prisma.customerTelemetryValue.findFirst({
      where: { customerAttributeId: parent.id },
      orderBy: { createdAt: 'desc' },
    });
    
    return value;
  },
};

export const CustomerTelemetryValueResolvers = {
  criteriaMet: async (parent: any) => {
    // If no success criteria, return null (cannot evaluate)
    if (!parent.customerAttribute?.successCriteria) {
      return null;
    }

    // Need to fetch the attribute if not included
    let attribute = parent.customerAttribute;
    if (!attribute || !attribute.successCriteria) {
      attribute = await prisma.customerTelemetryAttribute.findUnique({
        where: { id: parent.customerAttributeId },
      });
    }

    if (!attribute?.successCriteria) {
      return null;
    }

    const criteria = typeof attribute.successCriteria === 'string'
      ? JSON.parse(attribute.successCriteria)
      : attribute.successCriteria;

    // Get the value - for STRING datatype, value is already a string in the DB
    // For other types, it may be stored as JSON
    let value = parent.value;
    if (typeof parent.value === 'string' && attribute.dataType !== 'STRING') {
      try {
        value = JSON.parse(parent.value);
      } catch {
        // If parsing fails, use the raw value
        value = parent.value;
      }
    }

    if (criteria.type === 'boolean_equals') {
      return value === criteria.expectedValue;
    } else if (criteria.type === 'number_threshold') {
      const numValue = Number(value);
      const threshold = Number(criteria.threshold);
      
      switch (criteria.operator) {
        case 'greater_than': return numValue > threshold;
        case 'greater_than_or_equal': return numValue >= threshold;
        case 'less_than': return numValue < threshold;
        case 'less_than_or_equal': return numValue <= threshold;
        case 'equals': return numValue === threshold;
        default: return false;
      }
    } else if (criteria.type === 'string_contains') {
      const strValue = String(value).toLowerCase();
      const expectedStr = String(criteria.expectedValue).toLowerCase();
      return strValue.includes(expectedStr);
    }

    return null;
  },
};
