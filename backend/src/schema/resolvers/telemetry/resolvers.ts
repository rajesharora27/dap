/**
 * Telemetry GraphQL Resolvers
 * 
 * This module contains all GraphQL resolvers for telemetry-related operations.
 * It uses the TelemetryService for business logic and provides clean error handling.
 * 
 * Features:
 * - Type-safe resolvers with comprehensive error handling
 * - Integration with audit logging and user authentication
 * - Optimized queries with proper includes and ordering
 * - Batch operations support
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */

import { fallbackActive } from '../../../context';
import { requireUser } from '../../../lib/auth';
import { TelemetryService } from '../../../services/telemetry';

/**
 * Telemetry Attribute type resolvers
 */
export const TelemetryAttributeResolvers = {
  task: async (parent: any) => {
    if (fallbackActive) {
      return null;
    }
    try {
      const { prisma } = await import('../../../context');
      return await prisma.task.findUnique({ where: { id: parent.taskId } });
    } catch (error) {
      console.error('Error resolving telemetry attribute task:', error);
      return null;
    }
  },
  
  values: async (parent: any, { limit = 50 }: any) => {
    if (fallbackActive) {
      return [];
    }
    try {
      return await TelemetryService.getValuesForAttribute(parent.id, Math.min(limit, 200));
    } catch (error) {
      console.error('Error resolving telemetry attribute values:', error);
      return [];
    }
  },
  
  currentValue: async (parent: any) => {
    if (fallbackActive) {
      return null;
    }
    try {
      const values = await TelemetryService.getValuesForAttribute(parent.id, 1);
      return values.length > 0 ? values[0] : null;
    } catch (error) {
      console.error('Error resolving telemetry attribute current value:', error);
      return null;
    }
  },
  
  isSuccessful: async (parent: any) => {
    if (fallbackActive) {
      return false;
    }
    try {
      const { evaluateTelemetryAttribute } = await import('../../../services/telemetry');
      const result = await evaluateTelemetryAttribute(parent);
      return result.success;
    } catch (error) {
      console.error('Error evaluating telemetry attribute success:', error);
      return false;
    }
  }
};

/**
 * Telemetry Value type resolvers
 */
export const TelemetryValueResolvers = {
  attribute: async (parent: any) => {
    if (fallbackActive) {
      return null;
    }
    try {
      return await TelemetryService.getAttributeById(parent.attributeId, false);
    } catch (error) {
      console.error('Error resolving telemetry value attribute:', error);
      return null;
    }
  }
};

/**
 * Telemetry Query resolvers
 */
export const TelemetryQueryResolvers = {
  telemetryAttribute: async (_: any, { id }: any) => {
    if (fallbackActive) {
      return null;
    }
    try {
      return await TelemetryService.getAttributeById(id, true);
    } catch (error) {
      console.error('Error fetching telemetry attribute:', error);
      return null;
    }
  },
  
  telemetryAttributes: async (_: any, { taskId }: any) => {
    if (fallbackActive) {
      return [];
    }
    try {
      return await TelemetryService.getAttributesForTask(taskId, true);
    } catch (error) {
      console.error('Error fetching telemetry attributes:', error);
      return [];
    }
  },
  
  telemetryValue: async (_: any, { id }: any) => {
    if (fallbackActive) {
      return null;
    }
    try {
      const { prisma } = await import('../../../context');
      return await prisma.telemetryValue.findUnique({ 
        where: { id }, 
        include: { attribute: true } 
      });
    } catch (error) {
      console.error('Error fetching telemetry value:', error);
      return null;
    }
  },
  
  telemetryValues: async (_: any, { attributeId, limit = 50 }: any) => {
    if (fallbackActive) {
      return [];
    }
    try {
      return await TelemetryService.getValuesForAttribute(attributeId, limit);
    } catch (error) {
      console.error('Error fetching telemetry values:', error);
      return [];
    }
  },
  
  telemetryValuesByBatch: async (_: any, { batchId }: any) => {
    if (fallbackActive) {
      return [];
    }
    try {
      const { prisma } = await import('../../../context');
      return await prisma.telemetryValue.findMany({ 
        where: { batchId }, 
        orderBy: { createdAt: 'desc' }, 
        include: { attribute: true } 
      });
    } catch (error) {
      console.error('Error fetching telemetry values by batch:', error);
      return [];
    }
  }
};

/**
 * Telemetry Mutation resolvers
 */
export const TelemetryMutationResolvers = {
  createTelemetryAttribute: async (_: any, { input }: any, ctx: any) => {
    requireUser(ctx);
    try {
      return await TelemetryService.createAttribute(
        input.taskId,
        {
          name: input.name,
          description: input.description,
          dataType: input.dataType,
          successCriteria: input.successCriteria ? JSON.parse(input.successCriteria) : undefined,
          order: input.order,
          isRequired: input.isRequired
        },
        ctx.user?.id
      );
    } catch (error) {
      console.error('Error creating telemetry attribute:', error);
      throw new Error(`Failed to create telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  updateTelemetryAttribute: async (_: any, { id, input }: any, ctx: any) => {
    requireUser(ctx);
    try {
      return await TelemetryService.updateAttribute(
        id,
        {
          name: input.name,
          description: input.description,
          dataType: input.dataType,
          successCriteria: input.successCriteria ? JSON.parse(input.successCriteria) : undefined,
          order: input.order,
          isRequired: input.isRequired
        },
        ctx.user?.id
      );
    } catch (error) {
      console.error('Error updating telemetry attribute:', error);
      throw new Error(`Failed to update telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  deleteTelemetryAttribute: async (_: any, { id }: any, ctx: any) => {
    requireUser(ctx);
    try {
      const success = await TelemetryService.deleteAttribute(id, ctx.user?.id);
      return success;
    } catch (error) {
      console.error('Error deleting telemetry attribute:', error);
      throw new Error(`Failed to delete telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  addTelemetryValue: async (_: any, { input }: any, ctx: any) => {
    requireUser(ctx);
    try {
      return await TelemetryService.addValue(
        input.attributeId,
        {
          value: input.value,
          notes: input.notes,
          batchId: input.batchId
        },
        ctx.user?.id
      );
    } catch (error) {
      console.error('Error adding telemetry value:', error);
      throw new Error(`Failed to add telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  addBatchTelemetryValues: async (_: any, { input }: any, ctx: any) => {
    requireUser(ctx);
    try {
      return await TelemetryService.addBatchValues(input, ctx.user?.id);
    } catch (error) {
      console.error('Error adding batch telemetry values:', error);
      throw new Error(`Failed to add batch telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  updateTelemetryValue: async (_: any, { id, value, notes }: any, ctx: any) => {
    requireUser(ctx);
    try {
      return await TelemetryService.updateValue(
        id,
        { value, notes },
        ctx.user?.id
      );
    } catch (error) {
      console.error('Error updating telemetry value:', error);
      throw new Error(`Failed to update telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
  
  deleteTelemetryValue: async (_: any, { id }: any, ctx: any) => {
    requireUser(ctx);
    try {
      const success = await TelemetryService.deleteValue(id, ctx.user?.id);
      return success;
    } catch (error) {
      console.error('Error deleting telemetry value:', error);
      throw new Error(`Failed to delete telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
};

/**
 * Task resolver extensions for telemetry
 */
export const TaskTelemetryResolvers = {
  telemetryAttributes: async (parent: any) => {
    if (fallbackActive) {
      return [];
    }
    try {
      return await TelemetryService.getAttributesForTask(parent.id, true);
    } catch (error) {
      console.error('Error resolving task telemetry attributes:', error);
      return [];
    }
  },
  
  isCompleteBasedOnTelemetry: async (parent: any) => {
    if (fallbackActive) {
      return false;
    }
    try {
      const summary = await TelemetryService.getTaskCompletionSummary(parent.id);
      return summary.isComplete;
    } catch (error) {
      console.error('Error resolving task telemetry completion:', error);
      return false;
    }
  },
  
  telemetryCompletionPercentage: async (parent: any) => {
    if (fallbackActive) {
      return 0;
    }
    try {
      const summary = await TelemetryService.getTaskCompletionSummary(parent.id);
      return summary.completionPercentage;
    } catch (error) {
      console.error('Error resolving task telemetry completion percentage:', error);
      return 0;
    }
  }
};