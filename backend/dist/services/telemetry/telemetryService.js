"use strict";
/**
 * Telemetry Service
 *
 * This service provides high-level operations for managing telemetry attributes and values.
 * It encapsulates business logic, validation, and data access patterns for the telemetry system.
 *
 * Features:
 * - CRUD operations for telemetry attributes and values
 * - Batch operations for bulk telemetry updates
 * - Task completion calculation based on telemetry
 * - Comprehensive error handling and validation
 * - Audit logging integration
 *
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryService = void 0;
const context_1 = require("../../context");
const audit_1 = require("../../lib/audit");
const evaluationEngine_1 = require("./evaluationEngine");
/**
 * Main telemetry service class
 */
class TelemetryService {
    /**
     * Creates a new telemetry attribute for a task
     *
     * @param taskId - The ID of the task
     * @param attributeData - The attribute data
     * @param userId - The user creating the attribute (for audit logging)
     * @returns Promise<TelemetryAttribute> - The created attribute
     */
    static async createAttribute(taskId, attributeData, userId) {
        try {
            // Validate task exists
            const task = await context_1.prisma.task.findUnique({ where: { id: taskId } });
            if (!task) {
                throw new Error(`Task with ID ${taskId} not found`);
            }
            // Calculate order if not provided
            let order = attributeData.order;
            if (order === undefined) {
                const maxOrder = await context_1.prisma.telemetryAttribute.aggregate({
                    where: { taskId },
                    _max: { order: true }
                });
                order = (maxOrder._max.order || 0) + 1;
            }
            // Create the attribute
            const attribute = await context_1.prisma.telemetryAttribute.create({
                data: {
                    taskId,
                    name: attributeData.name,
                    description: attributeData.description,
                    dataType: attributeData.dataType,
                    successCriteria: attributeData.successCriteria ? JSON.stringify(attributeData.successCriteria) : null,
                    order,
                    isRequired: attributeData.isRequired ?? false
                },
                include: {
                    task: true,
                    values: {
                        orderBy: { createdAt: 'desc' },
                        take: 1
                    }
                }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('CREATE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attribute.id, attributeData, userId);
            }
            return attribute;
        }
        catch (error) {
            throw new Error(`Failed to create telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Updates an existing telemetry attribute
     *
     * @param attributeId - The ID of the attribute to update
     * @param updateData - The data to update
     * @param userId - The user updating the attribute (for audit logging)
     * @returns Promise<TelemetryAttribute> - The updated attribute
     */
    static async updateAttribute(attributeId, updateData, userId) {
        try {
            // Check if attribute exists
            const existingAttribute = await context_1.prisma.telemetryAttribute.findUnique({
                where: { id: attributeId }
            });
            if (!existingAttribute) {
                throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
            }
            // Prepare update data
            const updatePayload = {};
            if (updateData.name !== undefined)
                updatePayload.name = updateData.name;
            if (updateData.description !== undefined)
                updatePayload.description = updateData.description;
            if (updateData.dataType !== undefined)
                updatePayload.dataType = updateData.dataType;
            if (updateData.successCriteria !== undefined) {
                updatePayload.successCriteria = updateData.successCriteria ? JSON.stringify(updateData.successCriteria) : null;
            }
            if (updateData.order !== undefined)
                updatePayload.order = updateData.order;
            if (updateData.isRequired !== undefined)
                updatePayload.isRequired = updateData.isRequired;
            // Update the attribute
            const updatedAttribute = await context_1.prisma.telemetryAttribute.update({
                where: { id: attributeId },
                data: updatePayload,
                include: {
                    task: true,
                    values: {
                        orderBy: { createdAt: 'desc' },
                        take: 1
                    }
                }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('UPDATE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attributeId, updateData, userId);
            }
            return updatedAttribute;
        }
        catch (error) {
            throw new Error(`Failed to update telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Deletes a telemetry attribute and all its values
     *
     * @param attributeId - The ID of the attribute to delete
     * @param userId - The user deleting the attribute (for audit logging)
     * @returns Promise<boolean> - True if deletion was successful
     */
    static async deleteAttribute(attributeId, userId) {
        try {
            // Check if attribute exists
            const attribute = await context_1.prisma.telemetryAttribute.findUnique({
                where: { id: attributeId }
            });
            if (!attribute) {
                throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
            }
            // Delete the attribute (cascade will handle values)
            await context_1.prisma.telemetryAttribute.delete({
                where: { id: attributeId }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('DELETE_TELEMETRY_ATTRIBUTE', 'TelemetryAttribute', attributeId, {}, userId);
            }
            return true;
        }
        catch (error) {
            throw new Error(`Failed to delete telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Adds a telemetry value to an attribute
     *
     * @param attributeId - The ID of the attribute
     * @param valueData - The value data
     * @param userId - The user adding the value (for audit logging)
     * @returns Promise<TelemetryValue> - The created value
     */
    static async addValue(attributeId, valueData, userId) {
        try {
            // Validate attribute exists
            const attribute = await context_1.prisma.telemetryAttribute.findUnique({
                where: { id: attributeId }
            });
            if (!attribute) {
                throw new Error(`Telemetry attribute with ID ${attributeId} not found`);
            }
            // Create the value
            const telemetryValue = await context_1.prisma.telemetryValue.create({
                data: {
                    attributeId,
                    value: valueData.value,
                    notes: valueData.notes,
                    batchId: valueData.batchId
                },
                include: {
                    attribute: true
                }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('ADD_TELEMETRY_VALUE', 'TelemetryValue', telemetryValue.id, valueData, userId);
            }
            return telemetryValue;
        }
        catch (error) {
            throw new Error(`Failed to add telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Adds multiple telemetry values in a batch
     *
     * @param batchData - The batch data
     * @param userId - The user adding the batch (for audit logging)
     * @returns Promise<TelemetryValue[]> - The created values
     */
    static async addBatchValues(batchData, userId) {
        try {
            const { batchId, values } = batchData;
            // Validate all attributes exist
            const attributeIds = values.map(v => v.attributeId);
            const attributes = await context_1.prisma.telemetryAttribute.findMany({
                where: { id: { in: attributeIds } }
            });
            if (attributes.length !== attributeIds.length) {
                const foundIds = attributes.map((a) => a.id);
                const missingIds = attributeIds.filter(id => !foundIds.includes(id));
                throw new Error(`Telemetry attributes not found: ${missingIds.join(', ')}`);
            }
            // Create all values
            const valuePromises = values.map(valueInput => context_1.prisma.telemetryValue.create({
                data: {
                    attributeId: valueInput.attributeId,
                    value: valueInput.value,
                    notes: valueInput.notes,
                    batchId
                },
                include: {
                    attribute: true
                }
            }));
            const createdValues = await Promise.all(valuePromises);
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('ADD_BATCH_TELEMETRY_VALUES', 'TelemetryValue', batchId, { count: values.length }, userId);
            }
            return createdValues;
        }
        catch (error) {
            throw new Error(`Failed to add batch telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Gets telemetry completion summary for a task
     *
     * @param taskId - The ID of the task
     * @returns Promise<TelemetryCompletionSummary> - The completion summary
     */
    static async getTaskCompletionSummary(taskId) {
        try {
            // Get all telemetry attributes for the task
            const attributes = await context_1.prisma.telemetryAttribute.findMany({
                where: { taskId },
                include: {
                    values: {
                        orderBy: { createdAt: 'desc' },
                        take: 1
                    }
                },
                orderBy: { order: 'asc' }
            });
            if (attributes.length === 0) {
                return {
                    totalAttributes: 0,
                    successfulAttributes: 0,
                    completionPercentage: 0,
                    isComplete: false,
                    failedAttributes: []
                };
            }
            // Evaluate each attribute
            const evaluationResults = await (0, evaluationEngine_1.evaluateMultipleAttributes)(attributes);
            // Calculate summary
            const successfulCount = evaluationResults.filter(result => result.success).length;
            const completionPercentage = (successfulCount / attributes.length) * 100;
            const failedAttributes = evaluationResults
                .filter(result => !result.success)
                .map((result, index) => ({
                id: attributes[index].id,
                name: attributes[index].name,
                reason: result.details || result.error || 'Unknown failure'
            }));
            return {
                totalAttributes: attributes.length,
                successfulAttributes: successfulCount,
                completionPercentage,
                isComplete: successfulCount === attributes.length,
                failedAttributes
            };
        }
        catch (error) {
            throw new Error(`Failed to get task completion summary: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Gets all telemetry attributes for a task
     *
     * @param taskId - The ID of the task
     * @param includeValues - Whether to include values
     * @returns Promise<TelemetryAttribute[]> - The attributes
     */
    static async getAttributesForTask(taskId, includeValues = true) {
        try {
            return await context_1.prisma.telemetryAttribute.findMany({
                where: { taskId },
                include: {
                    values: includeValues ? {
                        orderBy: { createdAt: 'desc' },
                        take: 50
                    } : false
                },
                orderBy: { order: 'asc' }
            });
        }
        catch (error) {
            throw new Error(`Failed to get telemetry attributes: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Gets a single telemetry attribute by ID
     *
     * @param attributeId - The ID of the attribute
     * @param includeValues - Whether to include values
     * @returns Promise<TelemetryAttribute | null> - The attribute or null if not found
     */
    static async getAttributeById(attributeId, includeValues = true) {
        try {
            return await context_1.prisma.telemetryAttribute.findUnique({
                where: { id: attributeId },
                include: {
                    task: true,
                    values: includeValues ? {
                        orderBy: { createdAt: 'desc' },
                        take: 50
                    } : false
                }
            });
        }
        catch (error) {
            throw new Error(`Failed to get telemetry attribute: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Gets telemetry values for an attribute
     *
     * @param attributeId - The ID of the attribute
     * @param limit - Maximum number of values to return
     * @returns Promise<TelemetryValue[]> - The values
     */
    static async getValuesForAttribute(attributeId, limit = 50) {
        try {
            return await context_1.prisma.telemetryValue.findMany({
                where: { attributeId },
                include: {
                    attribute: true
                },
                orderBy: { createdAt: 'desc' },
                take: Math.min(limit, 200)
            });
        }
        catch (error) {
            throw new Error(`Failed to get telemetry values: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Updates a telemetry value
     *
     * @param valueId - The ID of the value to update
     * @param updateData - The data to update
     * @param userId - The user updating the value (for audit logging)
     * @returns Promise<TelemetryValue> - The updated value
     */
    static async updateValue(valueId, updateData, userId) {
        try {
            // Check if value exists
            const existingValue = await context_1.prisma.telemetryValue.findUnique({
                where: { id: valueId }
            });
            if (!existingValue) {
                throw new Error(`Telemetry value with ID ${valueId} not found`);
            }
            // Update the value
            const updatedValue = await context_1.prisma.telemetryValue.update({
                where: { id: valueId },
                data: updateData,
                include: {
                    attribute: true
                }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('UPDATE_TELEMETRY_VALUE', 'TelemetryValue', valueId, updateData, userId);
            }
            return updatedValue;
        }
        catch (error) {
            throw new Error(`Failed to update telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Deletes a telemetry value
     *
     * @param valueId - The ID of the value to delete
     * @param userId - The user deleting the value (for audit logging)
     * @returns Promise<boolean> - True if deletion was successful
     */
    static async deleteValue(valueId, userId) {
        try {
            // Check if value exists
            const value = await context_1.prisma.telemetryValue.findUnique({
                where: { id: valueId }
            });
            if (!value) {
                throw new Error(`Telemetry value with ID ${valueId} not found`);
            }
            // Delete the value
            await context_1.prisma.telemetryValue.delete({
                where: { id: valueId }
            });
            // Log audit trail
            if (userId) {
                await (0, audit_1.logAudit)('DELETE_TELEMETRY_VALUE', 'TelemetryValue', valueId, {}, userId);
            }
            return true;
        }
        catch (error) {
            throw new Error(`Failed to delete telemetry value: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}
exports.TelemetryService = TelemetryService;
