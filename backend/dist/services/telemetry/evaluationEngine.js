"use strict";
/**
 * Telemetry Evaluation Engine
 *
 * This module provides the core evaluation logic for telemetry success criteria.
 * It supports complex AND/OR logic with multiple data types and comparison modes.
 *
 * Features:
 * - Recursive evaluation of composite criteria (AND/OR)
 * - Type-safe evaluation for boolean, number, string, and timestamp data
 * - Comprehensive error handling and validation
 * - Detailed evaluation results with failure reasons
 *
 * @author Generated by GitHub Copilot
 * @version 1.0.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryEvaluationEngine = void 0;
exports.evaluateTelemetryAttribute = evaluateTelemetryAttribute;
exports.evaluateMultipleAttributes = evaluateMultipleAttributes;
const types_1 = require("./types");
/**
 * Main evaluation engine class for telemetry success criteria
 */
class TelemetryEvaluationEngine {
    /**
     * Evaluates a telemetry attribute against its success criteria
     *
     * @param attribute - The telemetry attribute with success criteria
     * @returns Promise<EvaluationResult> - The evaluation result
     */
    static async evaluateAttribute(attribute) {
        try {
            // Check if attribute has values
            if (!attribute.values || attribute.values.length === 0) {
                return {
                    success: false,
                    details: 'No telemetry values found for evaluation'
                };
            }
            // Check if success criteria is defined
            if (!attribute.successCriteria) {
                return {
                    success: true,
                    details: 'No success criteria defined - considered successful'
                };
            }
            // Get the latest value for evaluation
            const latestValue = attribute.values[0]; // Assuming values are ordered by createdAt desc
            // Parse success criteria from JSON if needed
            let criteria;
            if (typeof attribute.successCriteria === 'string') {
                criteria = JSON.parse(attribute.successCriteria);
            }
            else {
                criteria = attribute.successCriteria;
            }
            // Evaluate the criteria
            return await this.evaluateCriteria(criteria, latestValue, attribute.dataType);
        }
        catch (error) {
            return {
                success: false,
                error: `Evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Evaluates success criteria against a telemetry value
     *
     * @param criteria - The success criteria to evaluate
     * @param value - The telemetry value to evaluate against
     * @param dataType - The data type of the telemetry attribute
     * @returns Promise<EvaluationResult> - The evaluation result
     */
    static async evaluateCriteria(criteria, value, dataType) {
        switch (criteria.type) {
            case types_1.SuccessCriteriaType.BOOLEAN_FLAG:
                return this.evaluateBooleanFlag(criteria, value);
            case types_1.SuccessCriteriaType.NUMBER_THRESHOLD:
                return this.evaluateNumberThreshold(criteria, value);
            case types_1.SuccessCriteriaType.STRING_MATCH:
                return this.evaluateStringMatch(criteria, value);
            case types_1.SuccessCriteriaType.TIMESTAMP_COMPARISON:
                return this.evaluateTimestampComparison(criteria, value);
            case types_1.SuccessCriteriaType.COMPOSITE_AND:
                return this.evaluateCompositeAnd(criteria, value, dataType);
            case types_1.SuccessCriteriaType.COMPOSITE_OR:
                return this.evaluateCompositeOr(criteria, value, dataType);
            default:
                return {
                    success: false,
                    error: `Unknown criteria type: ${criteria.type}`
                };
        }
    }
    /**
     * Evaluates boolean flag criteria
     */
    static evaluateBooleanFlag(criteria, value) {
        try {
            const boolValue = this.parseBoolean(value.value);
            const success = boolValue === criteria.expectedValue;
            return {
                success,
                details: success
                    ? `Boolean value ${boolValue} matches expected ${criteria.expectedValue}`
                    : `Boolean value ${boolValue} does not match expected ${criteria.expectedValue}`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `Failed to parse boolean value: ${value.value}`
            };
        }
    }
    /**
     * Evaluates number threshold criteria
     */
    static evaluateNumberThreshold(criteria, value) {
        try {
            const numValue = parseFloat(value.value);
            if (isNaN(numValue)) {
                return {
                    success: false,
                    error: `Invalid number value: ${value.value}`
                };
            }
            let success = false;
            let comparison = '';
            switch (criteria.operator) {
                case types_1.NumberOperator.GREATER_THAN:
                    success = numValue > criteria.threshold;
                    comparison = `${numValue} > ${criteria.threshold}`;
                    break;
                case types_1.NumberOperator.LESS_THAN:
                    success = numValue < criteria.threshold;
                    comparison = `${numValue} < ${criteria.threshold}`;
                    break;
                case types_1.NumberOperator.EQUALS:
                    success = numValue === criteria.threshold;
                    comparison = `${numValue} = ${criteria.threshold}`;
                    break;
                case types_1.NumberOperator.GREATER_THAN_OR_EQUAL:
                    success = numValue >= criteria.threshold;
                    comparison = `${numValue} >= ${criteria.threshold}`;
                    break;
                case types_1.NumberOperator.LESS_THAN_OR_EQUAL:
                    success = numValue <= criteria.threshold;
                    comparison = `${numValue} <= ${criteria.threshold}`;
                    break;
            }
            return {
                success,
                details: `Number comparison: ${comparison} = ${success}`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `Number threshold evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Evaluates string match criteria
     */
    static evaluateStringMatch(criteria, value) {
        try {
            const stringValue = value.value;
            let pattern = criteria.pattern;
            // Handle case sensitivity
            if (!criteria.caseSensitive) {
                pattern = pattern.toLowerCase();
            }
            const testValue = criteria.caseSensitive ? stringValue : stringValue.toLowerCase();
            let success = false;
            let method = '';
            switch (criteria.mode) {
                case types_1.StringMatchMode.EXACT:
                    success = testValue === pattern;
                    method = 'exact match';
                    break;
                case types_1.StringMatchMode.CONTAINS:
                    success = testValue.includes(pattern);
                    method = 'contains';
                    break;
                case types_1.StringMatchMode.REGEX:
                    const regex = new RegExp(criteria.pattern, criteria.caseSensitive ? 'g' : 'gi');
                    success = regex.test(stringValue);
                    method = 'regex match';
                    break;
            }
            return {
                success,
                details: `String ${method}: "${stringValue}" ${success ? 'matches' : 'does not match'} pattern "${criteria.pattern}"`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `String match evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Evaluates timestamp comparison criteria
     */
    static evaluateTimestampComparison(criteria, value) {
        try {
            const timestamp = new Date(value.value);
            if (isNaN(timestamp.getTime())) {
                return {
                    success: false,
                    error: `Invalid timestamp value: ${value.value}`
                };
            }
            const now = new Date();
            let referenceTime;
            if (criteria.referenceTime === 'now' || !criteria.referenceTime) {
                referenceTime = now;
            }
            else {
                referenceTime = new Date(criteria.referenceTime);
                if (isNaN(referenceTime.getTime())) {
                    return {
                        success: false,
                        error: `Invalid reference time: ${criteria.referenceTime}`
                    };
                }
            }
            let success = false;
            let comparison = '';
            switch (criteria.mode) {
                case types_1.TimestampMode.BEFORE:
                    success = timestamp < referenceTime;
                    comparison = `${timestamp.toISOString()} before ${referenceTime.toISOString()}`;
                    break;
                case types_1.TimestampMode.AFTER:
                    success = timestamp > referenceTime;
                    comparison = `${timestamp.toISOString()} after ${referenceTime.toISOString()}`;
                    break;
                case types_1.TimestampMode.WITHIN_DAYS:
                    if (!criteria.withinDays) {
                        return {
                            success: false,
                            error: 'withinDays parameter required for within_days mode'
                        };
                    }
                    const daysDiff = Math.abs((timestamp.getTime() - referenceTime.getTime()) / (1000 * 60 * 60 * 24));
                    success = daysDiff <= criteria.withinDays;
                    comparison = `${daysDiff.toFixed(1)} days difference, within ${criteria.withinDays} days`;
                    break;
            }
            return {
                success,
                details: `Timestamp comparison: ${comparison} = ${success}`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `Timestamp comparison evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Evaluates composite AND criteria (all must be true)
     */
    static async evaluateCompositeAnd(criteria, value, dataType) {
        try {
            const results = [];
            for (const subCriteria of criteria.criteria) {
                const result = await this.evaluateCriteria(subCriteria, value, dataType);
                results.push(result);
                // Early exit if any criteria fails
                if (!result.success) {
                    return {
                        success: false,
                        details: `AND criteria failed at: ${result.details || result.error}`
                    };
                }
            }
            return {
                success: true,
                details: `All ${criteria.criteria.length} AND criteria passed`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `Composite AND evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Evaluates composite OR criteria (at least one must be true)
     */
    static async evaluateCompositeOr(criteria, value, dataType) {
        try {
            const results = [];
            const failures = [];
            for (const subCriteria of criteria.criteria) {
                const result = await this.evaluateCriteria(subCriteria, value, dataType);
                results.push(result);
                // Early exit if any criteria succeeds
                if (result.success) {
                    return {
                        success: true,
                        details: `OR criteria passed: ${result.details}`
                    };
                }
                failures.push(result.details || result.error || 'Unknown failure');
            }
            return {
                success: false,
                details: `All ${criteria.criteria.length} OR criteria failed: ${failures.join('; ')}`
            };
        }
        catch (error) {
            return {
                success: false,
                error: `Composite OR evaluation error: ${error instanceof Error ? error.message : 'Unknown error'}`
            };
        }
    }
    /**
     * Parses a string value to boolean
     */
    static parseBoolean(value) {
        const lowercaseValue = value.toLowerCase();
        if (['true', '1', 'yes', 'on'].includes(lowercaseValue)) {
            return true;
        }
        if (['false', '0', 'no', 'off'].includes(lowercaseValue)) {
            return false;
        }
        throw new Error(`Cannot parse "${value}" as boolean`);
    }
}
exports.TelemetryEvaluationEngine = TelemetryEvaluationEngine;
/**
 * Convenience function for evaluating a single telemetry attribute
 *
 * @param attribute - The telemetry attribute to evaluate
 * @returns Promise<EvaluationResult> - The evaluation result
 */
async function evaluateTelemetryAttribute(attribute) {
    return TelemetryEvaluationEngine.evaluateAttribute(attribute);
}
/**
 * Convenience function for batch evaluation of multiple attributes
 *
 * @param attributes - Array of telemetry attributes to evaluate
 * @returns Promise<Array<EvaluationResult & { attributeId: string }>> - Array of evaluation results
 */
async function evaluateMultipleAttributes(attributes) {
    const evaluationPromises = attributes.map(async (attribute) => {
        const result = await TelemetryEvaluationEngine.evaluateAttribute(attribute);
        return {
            ...result,
            attributeId: attribute.id
        };
    });
    return Promise.all(evaluationPromises);
}
